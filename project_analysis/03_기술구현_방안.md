# STOM 기술 구현 방안

## 🏗️ 시스템 아키텍처

### 전체 구조
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Frontend  │    │   CLI Tools     │    │   GUI Auto      │
│   (React)       │    │   (Typer)       │    │   (PyQt6)       │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                    ┌─────────────▼───────────────┐
                    │      FastAPI Server        │
                    │   (REST API + WebSocket)   │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────▼───────────────┐
                    │     Business Logic         │
                    │  (기존 STOM 로직 재사용)    │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────▼───────────────┐
                    │      Data Layer            │
                    │  PostgreSQL + Redis        │
                    └─────────────────────────────┘
```

## 💻 웹 프론트엔드 구현

### React 컴포넌트 구조
```typescript
// 주요 컴포넌트
src/
├── components/
│   ├── Chart/              # 차트 컴포넌트
│   ├── OrderBook/          # 호가창
│   ├── Portfolio/          # 포트폴리오
│   ├── Strategy/           # 전략 편집기
│   └── Common/             # 공통 컴포넌트
├── pages/
│   ├── Dashboard/          # 대시보드
│   ├── Trading/            # 트레이딩
│   ├── Backtest/           # 백테스트
│   └── Settings/           # 설정
└── services/
    ├── api.ts              # API 서비스
    ├── websocket.ts        # WebSocket 서비스
    └── auth.ts             # 인증 서비스
```

### 실시간 데이터 처리
```typescript
// WebSocket 연결 관리
class RealtimeService {
  private ws: WebSocket;
  
  connect() {
    this.ws = new WebSocket('ws://localhost:8000/ws/realtime');
    this.ws.onmessage = this.handleMessage;
  }
  
  handleMessage(event: MessageEvent) {
    const data = JSON.parse(event.data);
    // 실시간 데이터 처리
  }
}
```

## 🔧 백엔드 API 구현

### FastAPI 서버 구조
```python
# main.py
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="STOM API")
app.add_middleware(CORSMiddleware)

# API 라우터
app.include_router(auth_router, prefix="/auth")
app.include_router(trading_router, prefix="/trading")
app.include_router(backtest_router, prefix="/backtest")

@app.websocket("/ws/realtime")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # 실시간 데이터 스트리밍
```

### 데이터 모델
```python
# models.py
from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Trade(Base):
    __tablename__ = "trades"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String, nullable=False)
    price = Column(Float, nullable=False)
    quantity = Column(Float, nullable=False)
    timestamp = Column(DateTime, nullable=False)
```

## 🖥️ CLI 도구 구현

### 명령어 구조
```python
# cli/main.py
import typer
from typing import Optional

app = typer.Typer()

@app.command()
def backtest(
    strategy: str,
    start_date: str,
    end_date: str,
    initial_capital: float = 1000000
):
    """백테스트 실행"""
    # 백테스트 로직

@app.command()
def trade(
    strategy: str,
    mode: str = "paper",
    dry_run: bool = False
):
    """실시간 트레이딩 시작"""
    # 트레이딩 로직

if __name__ == "__main__":
    app()
```

## 🤖 GUI 자동화 구현

### 시스템 트레이 애플리케이션
```python
# gui_automation/tray_app.py
import sys
from PyQt6.QtWidgets import QSystemTrayIcon, QMenu
from PyQt6.QtCore import QTimer
from apscheduler.schedulers.background import BackgroundScheduler

class TradingTrayApp:
    def __init__(self):
        self.tray = QSystemTrayIcon()
        self.scheduler = BackgroundScheduler()
        self.setup_ui()
        
    def setup_ui(self):
        menu = QMenu()
        menu.addAction("시작", self.start_trading)
        menu.addAction("중지", self.stop_trading)
        menu.addAction("설정", self.show_settings)
        self.tray.setContextMenu(menu)
        
    def start_trading(self):
        # 자동 트레이딩 시작
        pass
```

## 📊 데이터베이스 설계

### PostgreSQL 스키마
```sql
-- 사용자 테이블
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 거래 테이블
CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(4) NOT NULL, -- 'buy' or 'sell'
    price DECIMAL(15,8) NOT NULL,
    quantity DECIMAL(15,8) NOT NULL,
    executed_at TIMESTAMP NOT NULL
);

-- 전략 테이블
CREATE TABLE strategies (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    name VARCHAR(100) NOT NULL,
    code TEXT NOT NULL,
    parameters JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 🔄 실시간 데이터 처리

### WebSocket 서버
```python
# websocket_manager.py
import asyncio
import json
from typing import Dict, List
from fastapi import WebSocket

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        
    async def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
        
    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            await connection.send_text(json.dumps(message))

manager = ConnectionManager()
```

## 🔐 보안 구현

### JWT 인증
```python
# auth.py
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

## 📈 성능 최적화

### 캐싱 전략
```python
# cache.py
import redis
import json
from typing import Any, Optional

class CacheManager:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        
    def get(self, key: str) -> Optional[Any]:
        data = self.redis_client.get(key)
        return json.loads(data) if data else None
        
    def set(self, key: str, value: Any, ttl: int = 300):
        self.redis_client.setex(key, ttl, json.dumps(value))
```

## 🐳 Docker 배포

### Dockerfile
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# 의존성 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 애플리케이션 복사
COPY . .

# 포트 노출
EXPOSE 8000

# 애플리케이션 실행
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### docker-compose.yml
```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/stom
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: stom
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

## 🧪 테스트 전략

### 단위 테스트
```python
# tests/test_trading.py
import pytest
from unittest.mock import Mock
from services.trading import TradingService

def test_place_order():
    trading_service = TradingService()
    result = trading_service.place_order("AAPL", "buy", 100, 150.0)
    assert result.success is True
```

---

*이 문서는 STOM 웹 변환 프로젝트의 핵심 기술 구현 방안을 제시합니다.*