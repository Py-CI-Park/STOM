# STOM ê¸°ìˆ  êµ¬í˜„ ë°©ì•ˆ

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ì „ì²´ êµ¬ì¡°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Web Frontend  â”‚    â”‚   CLI Tools     â”‚    â”‚   GUI Auto      â”‚
â”‚   (React)       â”‚    â”‚   (Typer)       â”‚    â”‚   (PyQt6)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      FastAPI Server        â”‚
                    â”‚   (REST API + WebSocket)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     Business Logic         â”‚
                    â”‚  (ê¸°ì¡´ STOM ë¡œì§ ì¬ì‚¬ìš©)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Data Layer            â”‚
                    â”‚  PostgreSQL + Redis        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» ì›¹ í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„

### React ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°
```typescript
// ì£¼ìš” ì»´í¬ë„ŒíŠ¸
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Chart/              # ì°¨íŠ¸ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ OrderBook/          # í˜¸ê°€ì°½
â”‚   â”œâ”€â”€ Portfolio/          # í¬íŠ¸í´ë¦¬ì˜¤
â”‚   â”œâ”€â”€ Strategy/           # ì „ëµ í¸ì§‘ê¸°
â”‚   â””â”€â”€ Common/             # ê³µí†µ ì»´í¬ë„ŒíŠ¸
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Dashboard/          # ëŒ€ì‹œë³´ë“œ
â”‚   â”œâ”€â”€ Trading/            # íŠ¸ë ˆì´ë”©
â”‚   â”œâ”€â”€ Backtest/           # ë°±í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ Settings/           # ì„¤ì •
â””â”€â”€ services/
    â”œâ”€â”€ api.ts              # API ì„œë¹„ìŠ¤
    â”œâ”€â”€ websocket.ts        # WebSocket ì„œë¹„ìŠ¤
    â””â”€â”€ auth.ts             # ì¸ì¦ ì„œë¹„ìŠ¤
```

### ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
```typescript
// WebSocket ì—°ê²° ê´€ë¦¬
class RealtimeService {
  private ws: WebSocket;
  
  connect() {
    this.ws = new WebSocket('ws://localhost:8000/ws/realtime');
    this.ws.onmessage = this.handleMessage;
  }
  
  handleMessage(event: MessageEvent) {
    const data = JSON.parse(event.data);
    // ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
  }
}
```

## ğŸ”§ ë°±ì—”ë“œ API êµ¬í˜„

### FastAPI ì„œë²„ êµ¬ì¡°
```python
# main.py
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="STOM API")
app.add_middleware(CORSMiddleware)

# API ë¼ìš°í„°
app.include_router(auth_router, prefix="/auth")
app.include_router(trading_router, prefix="/trading")
app.include_router(backtest_router, prefix="/backtest")

@app.websocket("/ws/realtime")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë°
```

### ë°ì´í„° ëª¨ë¸
```python
# models.py
from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Trade(Base):
    __tablename__ = "trades"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String, nullable=False)
    price = Column(Float, nullable=False)
    quantity = Column(Float, nullable=False)
    timestamp = Column(DateTime, nullable=False)
```

## ğŸ–¥ï¸ CLI ë„êµ¬ êµ¬í˜„

### ëª…ë ¹ì–´ êµ¬ì¡°
```python
# cli/main.py
import typer
from typing import Optional

app = typer.Typer()

@app.command()
def backtest(
    strategy: str,
    start_date: str,
    end_date: str,
    initial_capital: float = 1000000
):
    """ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    # ë°±í…ŒìŠ¤íŠ¸ ë¡œì§

@app.command()
def trade(
    strategy: str,
    mode: str = "paper",
    dry_run: bool = False
):
    """ì‹¤ì‹œê°„ íŠ¸ë ˆì´ë”© ì‹œì‘"""
    # íŠ¸ë ˆì´ë”© ë¡œì§

if __name__ == "__main__":
    app()
```

## ğŸ¤– GUI ìë™í™” êµ¬í˜„

### ì‹œìŠ¤í…œ íŠ¸ë ˆì´ ì• í”Œë¦¬ì¼€ì´ì…˜
```python
# gui_automation/tray_app.py
import sys
from PyQt6.QtWidgets import QSystemTrayIcon, QMenu
from PyQt6.QtCore import QTimer
from apscheduler.schedulers.background import BackgroundScheduler

class TradingTrayApp:
    def __init__(self):
        self.tray = QSystemTrayIcon()
        self.scheduler = BackgroundScheduler()
        self.setup_ui()
        
    def setup_ui(self):
        menu = QMenu()
        menu.addAction("ì‹œì‘", self.start_trading)
        menu.addAction("ì¤‘ì§€", self.stop_trading)
        menu.addAction("ì„¤ì •", self.show_settings)
        self.tray.setContextMenu(menu)
        
    def start_trading(self):
        # ìë™ íŠ¸ë ˆì´ë”© ì‹œì‘
        pass
```

## ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### PostgreSQL ìŠ¤í‚¤ë§ˆ
```sql
-- ì‚¬ìš©ì í…Œì´ë¸”
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ê±°ë˜ í…Œì´ë¸”
CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(4) NOT NULL, -- 'buy' or 'sell'
    price DECIMAL(15,8) NOT NULL,
    quantity DECIMAL(15,8) NOT NULL,
    executed_at TIMESTAMP NOT NULL
);

-- ì „ëµ í…Œì´ë¸”
CREATE TABLE strategies (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    name VARCHAR(100) NOT NULL,
    code TEXT NOT NULL,
    parameters JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## ğŸ”„ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬

### WebSocket ì„œë²„
```python
# websocket_manager.py
import asyncio
import json
from typing import Dict, List
from fastapi import WebSocket

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        
    async def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
        
    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            await connection.send_text(json.dumps(message))

manager = ConnectionManager()
```

## ğŸ” ë³´ì•ˆ êµ¬í˜„

### JWT ì¸ì¦
```python
# auth.py
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### ìºì‹± ì „ëµ
```python
# cache.py
import redis
import json
from typing import Any, Optional

class CacheManager:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        
    def get(self, key: str) -> Optional[Any]:
        data = self.redis_client.get(key)
        return json.loads(data) if data else None
        
    def set(self, key: str, value: Any, ttl: int = 300):
        self.redis_client.setex(key, ttl, json.dumps(value))
```

## ğŸ³ Docker ë°°í¬

### Dockerfile
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# ì˜ì¡´ì„± ì„¤ì¹˜
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë³µì‚¬
COPY . .

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8000

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### docker-compose.yml
```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/stom
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: stom
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```python
# tests/test_trading.py
import pytest
from unittest.mock import Mock
from services.trading import TradingService

def test_place_order():
    trading_service = TradingService()
    result = trading_service.place_order("AAPL", "buy", 100, 150.0)
    assert result.success is True
```

---

*ì´ ë¬¸ì„œëŠ” STOM ì›¹ ë³€í™˜ í”„ë¡œì íŠ¸ì˜ í•µì‹¬ ê¸°ìˆ  êµ¬í˜„ ë°©ì•ˆì„ ì œì‹œí•©ë‹ˆë‹¤.*