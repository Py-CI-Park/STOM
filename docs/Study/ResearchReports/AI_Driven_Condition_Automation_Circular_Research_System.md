# AI ê¸°ë°˜ ì¡°ê±´ì‹ ìë™í™” ë° ìˆœí™˜ ì—°êµ¬ ì‹œìŠ¤í…œ

**ë¬¸ì„œ ë²„ì „**: 1.1
**ì‘ì„±ì¼**: 2025-12-01
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-12-03
**ì—…ë°ì´íŠ¸ ë‚´ìš©**: GUI í”„ë¡œì„¸ìŠ¤ ì¶”ê°€ (Section 3.3), DB ì €ì¥ ë‹¨ê³„ ì¶”ê°€ (Section 5.4), 8ë‹¨ê³„ ìë™í™” í”Œë¡œìš° ë°˜ì˜
**ì—°êµ¬ ë²”ìœ„**: STOM V1 ì¡°ê±´ì‹ ìë™í™” ë° AI ê¸°ë°˜ ìˆœí™˜ ê°œì„  ì‹œìŠ¤í…œ
**ëŒ€ìƒ ì‹œìŠ¤í…œ**: STOM (System Trading Optimization Manager) V1

---

## ğŸ“‹ ëª©ì°¨

1. [ì—°êµ¬ ê°œìš”](#1-ì—°êµ¬-ê°œìš”)
2. [ì¡°ê±´ì‹ ì‹œìŠ¤í…œ í˜„í™© ë¶„ì„](#2-ì¡°ê±´ì‹-ì‹œìŠ¤í…œ-í˜„í™©-ë¶„ì„)
3. [ì½”ë“œ ì‹¤í–‰ ë©”ì»¤ë‹ˆì¦˜ ì‹¬ì¸µ ë¶„ì„](#3-ì½”ë“œ-ì‹¤í–‰-ë©”ì»¤ë‹ˆì¦˜-ì‹¬ì¸µ-ë¶„ì„)
4. [AI ê¸°ë°˜ ì¡°ê±´ì‹ ìë™ ìƒì„± ì‹œìŠ¤í…œ](#4-ai-ê¸°ë°˜-ì¡°ê±´ì‹-ìë™-ìƒì„±-ì‹œìŠ¤í…œ)
5. [ìë™í™” ìˆœí™˜ í”„ë¡œì„¸ìŠ¤ ì„¤ê³„](#5-ìë™í™”-ìˆœí™˜-í”„ë¡œì„¸ìŠ¤-ì„¤ê³„)
6. [ì‹¤ì œ êµ¬í˜„ ë°©ì•ˆ](#6-ì‹¤ì œ-êµ¬í˜„-ë°©ì•ˆ)
7. [ë¦¬ìŠ¤í¬ ë° ì™„í™” ì „ëµ](#7-ë¦¬ìŠ¤í¬-ë°-ì™„í™”-ì „ëµ)
8. [ê²°ë¡  ë° ë¡œë“œë§µ](#8-ê²°ë¡ -ë°-ë¡œë“œë§µ)

---

## 1. ì—°êµ¬ ê°œìš” ğŸ’¡ [ì œì•ˆì‚¬í•­]

### 1.1 ì—°êµ¬ ë°°ê²½ ë° ë™ê¸°

STOM ì‹œìŠ¤í…œì€ í˜„ì¬ **133ê°œì˜ íŠ¸ë ˆì´ë”© ì¡°ê±´ì‹**ì„ ë³´ìœ í•˜ê³  ìˆìœ¼ë©°, ì´ë“¤ì€ ëª¨ë‘ ìˆ˜ì‘ì—…ìœ¼ë¡œ ì‘ì„±, í…ŒìŠ¤íŠ¸, ìµœì í™”ë˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì€:

- **ì‹œê°„ ì†Œëª¨**: í•œ ì¡°ê±´ì‹ì˜ ì‘ì„±-í…ŒìŠ¤íŠ¸-ìµœì í™”ì— ìˆ˜ì¼~ìˆ˜ì£¼ ì†Œìš”
- **ì „ë¬¸ì„± ì˜ì¡´**: 826ê°œ í‹± ë³€ìˆ˜, 752ê°œ ë¶„ë´‰ ë³€ìˆ˜ì— ëŒ€í•œ ê¹Šì€ ì´í•´ í•„ìš”
- **íƒìƒ‰ í•œê³„**: ì¸ê°„ì˜ ì§ê´€ê³¼ ê²½í—˜ìœ¼ë¡œëŠ” ë°©ëŒ€í•œ ë³€ìˆ˜ ì¡°í•© ê³µê°„ íƒìƒ‰ ë¶ˆê°€ëŠ¥
- **ì¬í˜„ì„± ë¶€ì¡±**: ì¡°ê±´ì‹ ê°œì„  ê³¼ì •ì´ ì²´ê³„ì ìœ¼ë¡œ ê¸°ë¡ë˜ì§€ ì•ŠìŒ

### 1.2 ì—°êµ¬ ëª©í‘œ

ë³¸ ì—°êµ¬ëŠ” ë‹¤ìŒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤:

1. **ì¡°ê±´ì‹ ìë™ ìƒì„±**: AI/LLMì„ í™œìš©í•œ ì¡°ê±´ì‹ ì½”ë“œ ìë™ ìƒì„±
2. **ìë™ ë°±í…ŒìŠ¤íŒ…**: ìƒì„±ëœ ì¡°ê±´ì‹ì˜ ì¦‰ì‹œ ê²€ì¦ ë° ìµœì í™”
3. **ê²°ê³¼ ê¸°ë¡ ì‹œìŠ¤í…œ**: ëª¨ë“  ì‹¤í—˜ ê²°ê³¼ì˜ ì²´ê³„ì  ì €ì¥ ë° ë¶„ì„
4. **ìˆœí™˜ ê°œì„  ë©”ì»¤ë‹ˆì¦˜**: ì„±ê³¼ ê¸°ë°˜ í”¼ë“œë°±ì„ í†µí•œ ì¡°ê±´ì‹ ì§€ì†ì  ì§„í™”
5. **ì§€ì‹ ì¶•ì **: ì„±ê³µ/ì‹¤íŒ¨ íŒ¨í„´ì˜ ìë™ í•™ìŠµ ë° ì¬ì‚¬ìš©

### 1.3 ê¸°ëŒ€ íš¨ê³¼

| í•­ëª© | í˜„ì¬ (ìˆ˜ì‘ì—…) | ëª©í‘œ (ìë™í™”) | ê°œì„  íš¨ê³¼ |
|------|--------------|--------------|-----------|
| ì¡°ê±´ì‹ ì‘ì„± ì‹œê°„ | 2-5ì¼/ê°œ | 10-30ë¶„/ê°œ | 96% ë‹¨ì¶• |
| íƒìƒ‰ ê°€ëŠ¥ ì¡°í•© | ìˆ˜ì‹­ ê°œ | ìˆ˜ì²œ ê°œ | 100ë°° ì¦ê°€ |
| ìµœì í™” ì‹œê°„ | 587ë…„ (ì´ë¡ ê°’) | ìˆ˜ ì‹œê°„ | 99.9% ë‹¨ì¶• |
| ì „ëµ ë‹¤ì–‘ì„± | 133ê°œ | 1,000ê°œ+ | 7.5ë°° ì¦ê°€ |
| ì„±ê³¼ í–¥ìƒ | ê¸°ì¤€ì„  | +20-30% | ìˆ˜ìµë¥  í–¥ìƒ |

---

## 2. ì¡°ê±´ì‹ ì‹œìŠ¤í…œ í˜„í™© ë¶„ì„ âœ… [ì‹¤ì œ ì½”ë“œ ë¶„ì„]

### 2.1 ì¡°ê±´ì‹ ë¬¸ì„œ êµ¬ì¡°

#### 2.1.1 ì „ì²´ êµ¬ì¡° (133ê°œ ì¡°ê±´ì‹)

```
docs/Condition/
â”œâ”€â”€ Tick/                          # í‹± ë°ì´í„° ê¸°ë°˜ ì¡°ê±´ì‹ (72ê°œ)
â”‚   â”œâ”€â”€ 1_To_be_reviewed/          # ê²€í†  ëŒ€ê¸° (63ê°œ)
â”‚   â”œâ”€â”€ 2_Under_review/            # ê²€í†  ì¤‘ (9ê°œ)
â”‚   â””â”€â”€ 3_Review_finished/         # ê²€í†  ì™„ë£Œ (0ê°œ)
â”‚
â””â”€â”€ Min/                           # ë¶„ë´‰ ë°ì´í„° ê¸°ë°˜ ì¡°ê±´ì‹ (61ê°œ)
    â”œâ”€â”€ 1_To_be_reviewed/          # ê²€í†  ëŒ€ê¸°
    â”œâ”€â”€ 2_Under_review/            # ê²€í†  ì¤‘
    â””â”€â”€ 3_Review_finished/         # ê²€í†  ì™„ë£Œ
```

**ì£¼ìš” í†µê³„**:
- ì´ ì¡°ê±´ì‹: 133ê°œ
- í‹± ì¡°ê±´ì‹: 72ê°œ (ì´ˆë‹¨ìœ„ ê³ ë¹ˆë„ íŠ¸ë ˆì´ë”©)
- ë¶„ë´‰ ì¡°ê±´ì‹: 61ê°œ (ë¶„ë´‰ ê¸°ë°˜ ìŠ¤ìœ™ íŠ¸ë ˆì´ë”©)
- ê°€ì´ë“œë¼ì¸ ì¤€ìˆ˜ìœ¨: 98.3%
- 3ë‹¨ê³„ ê²€í†  í”„ë¡œì„¸ìŠ¤ ìš´ì˜ ì¤‘

#### 2.1.2 ì¡°ê±´ì‹ ë¬¸ì„œ í…œí”Œë¦¿ êµ¬ì¡°

ê° ì¡°ê±´ì‹ ë¬¸ì„œëŠ” ë‹¤ìŒ ì„¹ì…˜ìœ¼ë¡œ êµ¬ì„±:

```markdown
# ì¡°ê±´ì‹ ì œëª©

- [[Back_Testing_Guideline_Tick]] ì°¸ì¡°
- [[Condition_Document_Template_Guideline]] ê¸°ë°˜

## ê°œìš”
- ëŒ€ìƒ ì‹œê°„ êµ¬ê°„
- ëŒ€ìƒ ì¢…ëª©
- ì „ëµ íƒ€ì…
- í•µì‹¬ ë³€ìˆ˜

## ì œí•œì¡°ê±´
# ë°±í…ŒìŠ¤íŒ… í˜¸í™˜ì„± ê·œì¹™

## ê°€ì´ë“œë¼ì¸
# ì¡°ê±´ì‹ ì‘ì„± ê°€ì´ë“œ

## ë§¤ìˆ˜ ì¡°ê±´ì‹
```python
ë§¤ìˆ˜ = True
# ì¡°ê±´ë“¤...
if ë§¤ìˆ˜:
    self.Buy(vturn, vkey)
```

## ë§¤ë„ ì¡°ê±´ì‹
```python
ë§¤ë„ = False
# ì¡°ê±´ë“¤...
if ë§¤ë„:
    self.Sell(vturn, vkey, sell_cond)
```

## ìµœì í™” ì„¹ì…˜
### BO (Buy Optimization)
### BOR (Buy Optimization Range)
### SO (Sell Optimization)
### SOR (Sell Optimization Range)
### OR (Overall Range - ìƒìœ„ 10ê°œ ë³€ìˆ˜)
### GAR (Genetic Algorithm Range)

## ì¡°ê±´ì‹ ê°œì„  ë°©í–¥ ì—°êµ¬
# ìµœì†Œ 3ê°œ ì´ìƒì˜ ê°œì„  ì•„ì´ë””ì–´
```

### 2.2 ë³€ìˆ˜ ì‹œìŠ¤í…œ ë¶„ì„

#### 2.2.1 í‹± ë³€ìˆ˜ (826ê°œ)

**Back_Testing_Guideline_Tick.md**ì— ì •ì˜ëœ ë³€ìˆ˜ ì¹´í…Œê³ ë¦¬:

1. **ê°€ê²© ë³€ìˆ˜** (~100ê°œ)
   - í˜„ì¬ê°€, ì‹œê°€, ê³ ê°€, ì €ê°€
   - ë“±ë½ìœ¨, ì‹œê°€ë“±ë½ìœ¨, ì‹œê°€ëŒ€ë¹„ë“±ë½ìœ¨
   - ê³ ì €í‰ê· ëŒ€ë¹„ë“±ë½ìœ¨
   - ì´ë™í‰ê· (60/300/600/1200)
   - ìµœê³ í˜„ì¬ê°€(N), ìµœì €í˜„ì¬ê°€(N)

2. **ê±°ë˜ëŸ‰/ìœ ë™ì„± ë³€ìˆ˜** (~150ê°œ)
   - ë‹¹ì¼ê±°ë˜ëŒ€ê¸ˆ, ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ
   - ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆí‰ê· (N)
   - ê±°ë˜ëŒ€ê¸ˆì¦ê°, ì „ì¼ë¹„, ì „ì¼ë™ì‹œê°„ë¹„
   - íšŒì „ìœ¨, ì‹œê°€ì´ì•¡

3. **ì²´ê²°ê°•ë„ ë³€ìˆ˜** (~120ê°œ)
   - ì²´ê²°ê°•ë„, ì²´ê²°ê°•ë„í‰ê· (N)
   - ìµœê³ ì²´ê²°ê°•ë„(N), ìµœì €ì²´ê²°ê°•ë„(N)
   - ì´ˆë‹¹ë§¤ìˆ˜ìˆ˜ëŸ‰, ì´ˆë‹¹ë§¤ë„ìˆ˜ëŸ‰
   - ìµœê³ /ìµœì € ì´ˆë‹¹ë§¤ìˆ˜/ë§¤ë„ìˆ˜ëŸ‰(N)
   - ëˆ„ì  ì´ˆë‹¹ë§¤ìˆ˜/ë§¤ë„ìˆ˜ëŸ‰(N)

4. **í˜¸ê°€ì •ë³´ ë³€ìˆ˜** (~80ê°œ)
   - ë§¤ë„í˜¸ê°€1~5, ë§¤ìˆ˜í˜¸ê°€1~5
   - ë§¤ë„ì”ëŸ‰1~5, ë§¤ìˆ˜ì”ëŸ‰1~5
   - ë§¤ë„ì´ì”ëŸ‰, ë§¤ìˆ˜ì´ì”ëŸ‰
   - VIê°€ê²©, VIì•„ë˜5í˜¸ê°€

5. **ì‹œê°„ ë³€ìˆ˜** (~30ê°œ)
   - ì‹œë¶„ì´ˆ, í˜¸ê°€ì‹œê°„
   - ì§ì „ê±°ë˜ì‹œê°„, ì†ì ˆë§¤ë„ì‹œê°„

6. **ê°ë„ ë³€ìˆ˜** (~80ê°œ)
   - ë“±ë½ìœ¨ê°ë„(N)
   - ë‹¹ì¼ê±°ë˜ëŒ€ê¸ˆê°ë„(N)
   - ì „ì¼ë¹„ê°ë„(N)

7. **í•¨ìˆ˜ ë³€ìˆ˜** (~180ê°œ)
   - ì´ë™í‰ê· (N, lookback)
   - ìµœê³ /ìµœì € í˜„ì¬ê°€(N, lookback)
   - ì²´ê²°ê°•ë„í‰ê· (N, lookback)
   - Parameter_Previous(index, lookback)

8. **ê³„ì‚° ë³€ìˆ˜** (~86ê°œ)
   - ë³´ìœ ì‹œê°„, ìˆ˜ìµë¥ 
   - ìµœê³ ìˆ˜ìµë¥ , ìµœì €ìˆ˜ìµë¥ 
   - ë§¤ìˆ˜í‹±ë²ˆí˜¸, ë‹¹ì¼ì²´ê²°ê°•ë„ìˆœìœ„

#### 2.2.2 ë¶„ë´‰ ë³€ìˆ˜ (752ê°œ)

**Back_Testing_Guideline_Min.md**ì— ì •ì˜ëœ ë³€ìˆ˜ëŠ” í‹± ë³€ìˆ˜ì™€ ìœ ì‚¬í•˜ë‚˜, ë‹¤ìŒ ì°¨ì´ì ì´ ìˆìŒ:

- ë¶„ë´‰ íŠ¹í™” ë³€ìˆ˜: ë¶„ë´‰ì‹œê°€, ë¶„ë´‰ê³ ê°€, ë¶„ë´‰ì €ê°€, ë¶„ë´‰ì¢…ê°€
- ë¶„ë‹¹ ê±°ë˜ ë³€ìˆ˜: ë¶„ë‹¹ê±°ë˜ëŒ€ê¸ˆ, ë¶„ë‹¹ë§¤ìˆ˜ìˆ˜ëŸ‰, ë¶„ë‹¹ë§¤ë„ìˆ˜ëŸ‰
- ì´ë™í‰ê·  window: 5/10/20/60/120 (í‹±: 60/300/600/1200)

### 2.3 ì¡°ê±´ì‹ ì‘ì„± ê·œì¹™

#### 2.3.1 í•µì‹¬ ì œì•½ì‚¬í•­ (10ê°€ì§€)

1. **ë³€ìˆ˜ ì‚¬ìš© ì œí•œ**: ê°€ì´ë“œë¼ì¸ì— ëª…ì‹œëœ ë³€ìˆ˜ë§Œ ì‚¬ìš© ê°€ëŠ¥
2. **ë§¤ìˆ˜ ì¡°ê±´ì‹ íŒ¨í„´**: `not (ì¡°ê±´)` í˜•íƒœ (False ì¡°ê±´)
3. **ë§¤ë„ ì¡°ê±´ì‹ íŒ¨í„´**: `ì¡°ê±´` í˜•íƒœ (True ì¡°ê±´)
4. **í•œ ì¤„ í•œ ì¡°ê±´**: ì¡°ê±´ì‹ì€ ë°˜ë“œì‹œ í•œ ì¤„ì— í•˜ë‚˜ì”©
5. **ë¹„êµ ì—°ì‚°ì ì œí•œ**: `< > <= >= == !=` + `and or not` ë§Œ ì‚¬ìš©
6. **ë³µì¡í•œ ë¹„êµ ë¶„ë¦¬**: `a < b < c` â†’ `a < b and b < c`
7. **0 ë‚˜ëˆ„ê¸° ë°©ì§€**: ë¶„ëª¨ì— `+ 0.0001` ì¶”ê°€
8. **ë³€ìˆ˜ëª… ì •í™•ì„±**: ì˜¤íƒ€ ì‹œ ì‹œìŠ¤í…œ ì¸ì‹ ë¶ˆê°€
9. **ì„±ëŠ¥ ê³ ë ¤**: ê³¼ë„í•˜ê²Œ ë³µì¡í•œ ì‚°ìˆ ì‹ ì§€ì–‘
10. **if/elif ì²´ì¸**: ì²« ì¡°ê±´ë§Œ `if`, ë‚˜ë¨¸ì§€ëŠ” `elif`

#### 2.3.2 ë§¤ìˆ˜/ë§¤ë„ ì´ˆê¸°ê°’ íŒ¨í„´

```python
# ë§¤ìˆ˜ ì¡°ê±´ì‹ (False ì¡°ê±´)
ë§¤ìˆ˜ = True  # ì´ˆê¸°ê°’ True
# not (ì¡°ê±´1)
# not (ì¡°ê±´2)
if ë§¤ìˆ˜:
    self.Buy(vturn, vkey)

# ë§¤ë„ ì¡°ê±´ì‹ (True ì¡°ê±´)
ë§¤ë„ = False  # ì´ˆê¸°ê°’ False
# ì¡°ê±´1
# ì¡°ê±´2
if ë§¤ë„:
    self.Sell(vturn, vkey, sell_cond)
```

### 2.4 ìµœì í™” ì‹œìŠ¤í…œ êµ¬ì¡°

#### 2.4.1 self.vars ì¸ë±ìŠ¤ ê·œì¹™

```python
# self.vars êµ¬ì¡°: [[ì‹œì‘, ë, ê°„ê²©], ì´ˆê¸°ê°’]
self.vars[0]  # ê³ ì •ê°’ ì „ìš© (ìµœì í™” ëŒ€ìƒ ì•„ë‹˜)
self.vars[1]  # ë§¤ìˆ˜ ìµœì í™” ë³€ìˆ˜ 1
self.vars[2]  # ë§¤ìˆ˜ ìµœì í™” ë³€ìˆ˜ 2
self.vars[3]  # ë§¤ìˆ˜ ìµœì í™” ë³€ìˆ˜ 3
self.vars[4]  # ë§¤ë„ ìµœì í™” ë³€ìˆ˜ 1
self.vars[5]  # ë§¤ë„ ìµœì í™” ë³€ìˆ˜ 2
# ë°˜ë“œì‹œ ì—°ì†ëœ ë²ˆí˜¸ë¡œ ì‚¬ìš© (ê±´ë„ˆë›°ê¸° ê¸ˆì§€)
```

**ê·œì¹™**:
- ê° ë³€ìˆ˜ë‹¹ ìµœëŒ€ 20ê°œ ê°’ ì´í•˜: `(ëê°’ - ì‹œì‘ê°’) / ê°„ê²© + 1 â‰¤ 20`
- Range Step ì •í•©ì„±: `(ëê°’ - ì‹œì‘ê°’) % ê°„ê²© == 0`
- ê°„ê²© ë¶€í˜¸: ì‹œì‘ê°’ < ëê°’ì´ë©´ ì–‘ìˆ˜, ì‹œì‘ê°’ > ëê°’ì´ë©´ ìŒìˆ˜

#### 2.4.2 ìµœì í™” ì„¹ì…˜ êµ¬ì¡°

1. **BO (Buy Optimization)**: ìµœì í™”ëœ ë§¤ìˆ˜ ì¡°ê±´ì‹ (ì‹¤ì œ ê°’)
2. **BOR (Buy Optimization Range)**: ë§¤ìˆ˜ ë³€ìˆ˜ ë²”ìœ„ `[ìµœì†Œ, ìµœëŒ€, ê°„ê²©]`
3. **SO (Sell Optimization)**: ìµœì í™”ëœ ë§¤ë„ ì¡°ê±´ì‹ (ì‹¤ì œ ê°’)
4. **SOR (Sell Optimization Range)**: ë§¤ë„ ë³€ìˆ˜ ë²”ìœ„
5. **OR (Overall Range)**: ìƒìœ„ 10ê°œ ì£¼ìš” ë³€ìˆ˜ë§Œ (ê·¸ë¦¬ë“œ ì„œì¹˜ìš©)
6. **GAR (Genetic Algorithm Range)**: `[ìµœì†Œ, ìµœëŒ€]` í˜•ì‹ (GAìš©)

#### 2.4.3 ìµœì í™” ì•Œê³ ë¦¬ì¦˜ 3ì¢…

**1. Grid Search (ê·¸ë¦¬ë“œ ìµœì í™”)**
- ëª¨ë“  ë³€ìˆ˜ ì¡°í•© ìˆœì°¨ íƒìƒ‰
- ë²”ìœ„ ìë™ ê´€ë¦¬: `hstd/4` ì´í•˜ ì‚­ì œ
- ìµœì ê°’ì´ ê²½ê³„ë©´ í™•ì¥
- ê²½ìš°ì˜ ìˆ˜: ë³€ìˆ˜ë³„ ê°’ ê°œìˆ˜ì˜ ê³±

**2. Optuna (ë² ì´ì§€ì•ˆ ìµœì í™”)**
- TPESampler (ê¸°ë³¸), CmaEsSampler, QMCSampler
- Early Stopping: `best + len_vars` íšŸìˆ˜
- ì¤‘ë³µ íƒìƒ‰ ë°©ì§€ (`dict_simple_vars`)
- íš¨ìœ¨ì  íƒìƒ‰ (587ë…„ â†’ ìˆ˜ì‹œê°„)

**3. Genetic Algorithm (ìœ ì „ ì•Œê³ ë¦¬ì¦˜)**
- ë³€ìˆ˜ ê°œìˆ˜ Ã— 10íšŒ ë¬´ì‘ìœ„ ìƒ˜í”Œë§
- ìƒìœ„ 5% ë²”ìœ„ ìˆ˜ë ´
- êµë°°, ë³€ì´ ì—°ì‚°

### 2.5 ì„±ê³¼ í‰ê°€ ì§€í‘œ (OPTISTD 14ê°€ì§€)

#### 2.5.1 ë‹¨ìˆœ ê¸°ì¤€ê°’ (4ê°œ)

| ì§€í‘œ | ê³„ì‚°ì‹ | ì˜ë¯¸ | ì‚¬ìš© ì˜ˆ |
|------|--------|------|---------|
| **TG** | tsg | ìˆ˜ìµê¸ˆí•©ê³„ | ì ˆëŒ€ ìˆ˜ìµê¸ˆ ì¤‘ì‹¬ |
| **TP** | tpp | ìˆ˜ìµë¥ í•©ê³„ | ìë³¸ ê·œëª¨ ë¬´ê´€ |
| **TPI** | wr / 100 Ã— (1 + appp / ampp) | ë§¤ë§¤ì„±ëŠ¥ì§€ìˆ˜ | ìœ„í—˜ ëŒ€ë¹„ ì„±ê³¼ |
| **CAGR** | tpp / day_count Ã— 250(or 365) | ì—°ê°„ì˜ˆìƒìˆ˜ìµë¥  | ì¥ê¸° ì„±ì¥ì„± |

#### 2.5.2 ë³µí•© ê¸°ì¤€ê°’ (10ê°œ)

| ì§€í‘œ | ê³„ì‚°ì‹ | ì˜ë¯¸ |
|------|--------|------|
| **GM** | tsg / mdd_ | ê¸ˆì•¡/MDD ë¹„ìœ¨ |
| **G2M** | tsgÂ² / mdd_ / betting | ìˆ˜ìµê¸ˆ ì œê³± ê°•ì¡° |
| **GAM** | tsg Ã— app / mdd_ | í‰ê·  ìˆ˜ìµë¥  ê³ ë ¤ |
| **GWM** | tsg Ã— wr / mdd_ / 100 | ìŠ¹ë¥  ë°˜ì˜ |
| **PM** | tpp / mdd_ | ìˆ˜ìµë¥ /MDD ë¹„ìœ¨ |
| **P2M** | tppÂ² / mdd_ / betting | ìˆ˜ìµë¥  ì œê³± ê°•ì¡° |
| **PAM** | tpp Ã— app / mdd_ | í‰ê·  ìˆ˜ìµë¥  ê³ ë ¤ |
| **PWM** | tpp Ã— wr / mdd_ / 100 | ìŠ¹ë¥  ë°˜ì˜ |
| **WM** | wr / mdd_ | ìŠ¹ë¥ /MDD ë¹„ìœ¨ |
| **TM** | tc / mdd_ | ê±°ë˜íšŸìˆ˜/MDD ë¹„ìœ¨ |

#### 2.5.3 êµì°¨ê²€ì¦ MERGE ê³„ì‚°

```python
def GetOptiValidStd(train_data, valid_data, optistd, betting, exponential):
    std = 0
    count = len(train_data)
    for i in range(count):
        ex = (count - i) * 2 / count if exponential and count > 1 else 1.0
        std += train_data[i] * valid_data[i] * ex
    return std / count
```

**Weight (exponential=True)**:
- 6ë¶„í• : `2.00, 1.66, 1.33, 1.00, 0.66, 0.33` (ìµœê·¼ â†’ ê³¼ê±°)
- 3ë¶„í• : `2.00, 1.33, 0.66`
- 1ë¶„í• : `1.00` (ê°€ì¤‘ì¹˜ ì—†ìŒ)

**ë¬¸ì œì **: TRAIN Ã— VALID ê³±ì…ˆì´ ê·¹ë‹¨ê°’ ì¦í­ (Study ë¬¸ì„œ ì°¸ì¡°)

---

## 3. ì½”ë“œ ì‹¤í–‰ ë©”ì»¤ë‹ˆì¦˜ ì‹¬ì¸µ ë¶„ì„ âœ… [ì‹¤ì œ ì½”ë“œ ë¶„ì„]

### 3.1 ì¡°ê±´ì‹ ë¡œë”© í”„ë¡œì„¸ìŠ¤

#### 3.1.1 ì „ì²´ íë¦„ë„

```
[ì¡°ê±´ì‹ MD íŒŒì¼]
      â†“
[GetBuyStg/GetSellStg í•¨ìˆ˜] (back_static.py)
      â†“
[í…ìŠ¤íŠ¸ â†’ Python ì½”ë“œ ë³€í™˜]
      â†“
[compile() í˜¸ì¶œ]
      â†“
[ì»´íŒŒì¼ëœ ë°”ì´íŠ¸ì½”ë“œ]
      â†“
[BackEngineKiwoomTick/Min] (backengine_*.py)
      â†“
[exec() ì‹¤í–‰ + ë³€ìˆ˜ ì£¼ì…]
      â†“
[Buy/Sell ë©”ì„œë“œ í˜¸ì¶œ]
```

#### 3.1.2 GetBuyStg í•¨ìˆ˜ ë¶„ì„

**íŒŒì¼**: `backtester/back_static.py:200-224`

```python
def GetBuyStg(buytxt, gubun):
    # 1. ë§¤ìˆ˜ ì‹¤í–‰ ì½”ë“œ ì¶”ê°€
    buytxt  = buytxt.split('if ë§¤ìˆ˜:')[0] + 'if ë§¤ìˆ˜:\n    self.Buy(vturn, vkey)'

    # 2. indicator ì½”ë“œ ë¶„ë¦¬
    buystg  = ''
    indistg = ''
    for line in buytxt.split('\n'):
        if 'self.indicator' in line:
            indistg += f'{line}\n'
        else:
            buystg += f'{line}\n'

    # 3. ì»´íŒŒì¼
    if buystg != '':
        try:
            buystg = compile(buystg, '<string>', 'exec')
        except:
            buystg = None
            if gubun == 0: print_exc()
    else:
        buystg = None

    # 4. indicator ì½”ë“œ ì»´íŒŒì¼
    if indistg != '':
        try:
            indistg = compile(indistg, '<string>', 'exec')
        except:
            indistg = None
    else:
        indistg = None

    return buystg, indistg
```

**í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜**:
1. ì¡°ê±´ì‹ í…ìŠ¤íŠ¸ë¥¼ `if ë§¤ìˆ˜:` ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬
2. indicator ê´€ë ¨ ì½”ë“œë¥¼ ë³„ë„ë¡œ ë¶„ë¦¬
3. Python `compile()` í•¨ìˆ˜ë¡œ ë°”ì´íŠ¸ì½”ë“œ ë³€í™˜
4. ì»´íŒŒì¼ ì‹¤íŒ¨ ì‹œ `None` ë°˜í™˜ ë° ì—ëŸ¬ ì¶œë ¥

#### 3.1.3 GetSellStg í•¨ìˆ˜ ë¶„ì„

**íŒŒì¼**: `backtester/back_static.py:227-235`

```python
def GetSellStg(sellstg, gubun):
    # 1. sell_cond ì´ˆê¸°í™” + ë§¤ë„ ì‹¤í–‰ ì½”ë“œ ì¶”ê°€
    sellstg = 'sell_cond = 0\n' + sellstg.split('if ë§¤ë„:')[0] + \
              'if ë§¤ë„:\n    self.Sell(vturn, vkey, sell_cond)'

    # 2. ë§¤ë„ ì¡°ê±´ ë²ˆí˜¸ ë§¤í•‘
    sellstg, dict_cond = SetSellCond(sellstg.split('\n'))

    # 3. ì»´íŒŒì¼
    try:
        sellstg = compile(sellstg, '<string>', 'exec')
    except:
        sellstg = None
        if gubun == 0: print_exc()

    return sellstg, dict_cond
```

#### 3.1.4 SetSellCond í•¨ìˆ˜ (ë§¤ë„ ì¡°ê±´ ë²ˆí˜¸ ë§¤í•‘)

**íŒŒì¼**: `backtester/back_static.py:261-272`

```python
def SetSellCond(selllist):
    count = 1
    sellstg = ''
    dict_cond = {0: 'ì „ëµì¢…ë£Œì²­ì‚°', 100: 'ë¶„í• ë§¤ë„', 200: 'ì†ì ˆì²­ì‚°'}

    for i, text in enumerate(selllist):
        if '#' not in text and ('ë§¤ë„ = True' in text or ...):
            # ì¡°ê±´ ë²ˆí˜¸ ë§¤í•‘
            dict_cond[count] = selllist[i - 1]
            sellstg = f"{sellstg}{text.split('ë§¤ë„')[0]}sell_cond = {count}\n"
            count += 1
        if text != '':
            sellstg = f"{sellstg}{text}\n"

    return sellstg, dict_cond
```

**ë§¤ë„ ì¡°ê±´ ë²ˆí˜¸ ì²´ê³„**:
- `0`: ì „ëµì¢…ë£Œì²­ì‚° (ê¸°ë³¸)
- `1~N`: ì¡°ê±´ë³„ ë§¤ë„ (ì˜ˆ: `ìˆ˜ìµë¥  >= 3`)
- `100`: ë¶„í• ë§¤ë„
- `200`: ì†ì ˆì²­ì‚°

### 3.2 ë°±í…ŒìŠ¤íŒ… ì—”ì§„ ì‹¤í–‰ íë¦„

#### 3.2.1 BackEngineKiwoomTick í´ë˜ìŠ¤

**íŒŒì¼**: `backtester/backengine_kiwoom_tick.py:14-77`

```python
class BackEngineKiwoomTick:
    def __init__(self, gubun, wq, tq, bq, beq_list, bstq_list, profile=False):
        gc.disable()
        self.gubun        = gubun
        self.wq           = wq    # windowQ
        self.tq           = tq    # totalQ
        self.bq           = bq    # backQ
        self.beq_list     = beq_list
        self.beq          = beq_list[gubun]
        self.bstq_list    = bstq_list

        self.buystg       = None  # ì»´íŒŒì¼ëœ ë§¤ìˆ˜ ì¡°ê±´ì‹
        self.sellstg      = None  # ì»´íŒŒì¼ëœ ë§¤ë„ ì¡°ê±´ì‹
        self.indistg      = None  # ì»´íŒŒì¼ëœ indicator ì½”ë“œ

        self.vars         = []    # ìµœì í™” ë³€ìˆ˜ ë¦¬ìŠ¤íŠ¸
        self.vars_list    = []

        self.MainLoop()
```

#### 3.2.2 MainLoop ì‹¤í–‰ íë¦„

```python
def MainLoop(self):
    while True:
        data = self.beq.get()  # íì—ì„œ ë°ì´í„° ìˆ˜ì‹ 

        if 'ì •ë³´' in data[0]:
            if self.back_type == 'ìµœì í™”':
                if data[0] == 'ë°±í…Œì •ë³´':
                    self.betting   = data[1]
                    self.startday  = data[3]
                    self.endday    = data[4]
                    self.starttime = data[5]
                    self.endtime   = data[6]
                    # ì¡°ê±´ì‹ ë¡œë“œ
                    self.buystg, self.indistg = GetBuyStg(data[7], self.gubun)
                    self.sellstg, self.dict_sconds = GetSellStg(data[8], self.gubun)

                elif data[0] == 'ë³€ìˆ˜ì •ë³´':
                    self.vars_list = data[1]
                    self.opti_turn = data[2]
                    self.vars = [var[1] for var in self.vars_list]  # ë³€ìˆ˜ ì¶”ì¶œ
                    self.BackTest()  # ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰
```

#### 3.2.3 ë³€ìˆ˜ ì£¼ì… ë° ì¡°ê±´ì‹ ì‹¤í–‰

ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ ì‹œ ë‹¤ìŒ ë³€ìˆ˜ë“¤ì´ ì¡°ê±´ì‹ì— ì£¼ì…ë¨:

```python
# ë¡œì»¬ ë³€ìˆ˜ë¡œ ì£¼ì…
locals_dict = {
    # ê°€ê²© ë³€ìˆ˜
    'í˜„ì¬ê°€': í˜„ì¬ê°€,
    'ì‹œê°€': ì‹œê°€,
    'ê³ ê°€': ê³ ê°€,
    'ì €ê°€': ì €ê°€,
    'ë“±ë½ìœ¨': ë“±ë½ìœ¨,
    # ... (826ê°œ ë˜ëŠ” 752ê°œ ë³€ìˆ˜)

    # ìµœì í™” ë³€ìˆ˜
    'self.vars': self.vars,

    # ë©”ì„œë“œ
    'self.Buy': self.Buy,
    'self.Sell': self.Sell,
    'self.indicator': self.indicator,

    # í‹±/ë¶„ë´‰ ë²ˆí˜¸
    'vturn': vturn,
    'vkey': vkey,
}

# ì¡°ê±´ì‹ ì‹¤í–‰
exec(self.buystg, globals(), locals_dict)
exec(self.sellstg, globals(), locals_dict)
```

### 3.3 í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜ ìš”ì•½

#### 3.3.1 ì¡°ê±´ì‹ â†’ ì‹¤í–‰ ê°€ëŠ¥ ì½”ë“œ ë³€í™˜

1. **í…ìŠ¤íŠ¸ íŒŒì‹±**: MD íŒŒì¼ì—ì„œ Python ì½”ë“œ ë¸”ë¡ ì¶”ì¶œ
2. **ì½”ë“œ ë³€í™˜**: `GetBuyStg/GetSellStg`ë¡œ ì‹¤í–‰ ê°€ëŠ¥ í˜•íƒœë¡œ ë³€í™˜
3. **ì»´íŒŒì¼**: `compile('<string>', 'exec')` í˜¸ì¶œ
4. **ë³€ìˆ˜ ì£¼ì…**: `exec(code, globals(), locals())`ë¡œ ì‹¤í–‰
5. **Buy/Sell í˜¸ì¶œ**: ì¡°ê±´ ë§Œì¡± ì‹œ ë©”ì„œë“œ í˜¸ì¶œ

#### 3.3.2 ì¥ë‹¨ì  ë¶„ì„

**ì¥ì **:
- âœ… ìœ ì—°ì„±: ì¡°ê±´ì‹ì„ í…ìŠ¤íŠ¸ë¡œ ê´€ë¦¬í•˜ì—¬ ìˆ˜ì • ìš©ì´
- âœ… ê°€ë…ì„±: MD íŒŒì¼ë¡œ ì‚¬ëŒì´ ì½ê¸° ì‰¬ì›€
- âœ… ë²„ì „ ê´€ë¦¬: Gitìœ¼ë¡œ ì¡°ê±´ì‹ ë³€ê²½ ì´ë ¥ ì¶”ì  ê°€ëŠ¥
- âœ… ë¬¸ì„œí™”: ì¡°ê±´ì‹ê³¼ ë¬¸ì„œê°€ í†µí•©ë¨

**ë‹¨ì **:
- âš ï¸ ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ: ì»´íŒŒì¼ ì‹œê°„ ì†Œìš”
- âš ï¸ ë””ë²„ê¹… ì–´ë ¤ì›€: í…ìŠ¤íŠ¸ ê¸°ë°˜ ì˜¤ë¥˜ ì¶”ì  ë³µì¡
- âš ï¸ íƒ€ì… ê²€ì¦ ë¶€ì¬: ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥
- âš ï¸ ë³´ì•ˆ ë¦¬ìŠ¤í¬: `exec()` ì‚¬ìš© ì‹œ ì£¼ì˜ í•„ìš”

### 3.3 GUI ê¸°ë°˜ ì¡°ê±´ì‹ ê´€ë¦¬ í”„ë¡œì„¸ìŠ¤

#### 3.3.1 ì „ì²´ ì¡°ê±´ì‹ ê´€ë¦¬ íë¦„

STOM ì‹œìŠ¤í…œì€ ì¡°ê±´ì‹ MD íŒŒì¼ê³¼ ë°±í…ŒìŠ¤íŒ… ì‚¬ì´ì— **GUI ê¸°ë°˜ ì…ë ¥ ë° DB ì €ì¥ í”„ë¡œì„¸ìŠ¤**ê°€ ì¡´ì¬í•©ë‹ˆë‹¤. ì´ëŠ” ìë™í™” ì‹œìŠ¤í…œ ì„¤ê³„ ì‹œ ë°˜ë“œì‹œ ê³ ë ¤í•´ì•¼ í•˜ëŠ” ì¤‘ìš”í•œ ë‹¨ê³„ì…ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 STOM ì¡°ê±´ì‹ ê´€ë¦¬ ì „ì²´ í”„ë¡œì„¸ìŠ¤                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  [1ë‹¨ê³„] ì¡°ê±´ì‹ MD íŒŒì¼ ì‘ì„±                                   â”‚
â”‚  â””â”€ docs/Condition/Tick/*.md                                 â”‚
â”‚  â””â”€ docs/Condition/Min/*.md                                  â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [2ë‹¨ê³„] GUIì—ì„œ ì¡°ê±´ì‹ ë¶ˆëŸ¬ì˜¤ê¸°/í¸ì§‘ â¬…ï¸ ì¤‘ìš”!                  â”‚
â”‚  â””â”€ ui/ui_vars_change.py                                     â”‚
â”‚     â”œâ”€ get_fix_strategy(): ë§¤ìˆ˜/ë§¤ë„ í¬ë§· ì •ë¦¬                â”‚
â”‚     â”œâ”€ get_stgtxt_to_varstxt(): "ë³€ìˆ˜" â†’ self.vars[N] ë³€í™˜   â”‚
â”‚     â”œâ”€ get_optivars_to_gavars(): ìµœì í™” ë²”ìœ„ â†’ GA ë²”ìœ„        â”‚
â”‚     â””â”€ get_gavars_to_optivars(): GA ë²”ìœ„ â†’ ìµœì í™” ë²”ìœ„        â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [3ë‹¨ê³„] strategy.dbì— ì €ì¥ â¬…ï¸ ì¤‘ìš”!                          â”‚
â”‚  â””â”€ utility/query.py (ì¶”ì •)                                  â”‚
â”‚  â””â”€ _database/strategy.db                                    â”‚
â”‚     â”œâ”€ ì „ëµëª…, ë§¤ìˆ˜ì¡°ê±´, ë§¤ë„ì¡°ê±´ ì €ì¥                         â”‚
â”‚     â”œâ”€ ë³€ìˆ˜ ë²”ìœ„ ì €ì¥                                         â”‚
â”‚     â””â”€ ì‹œê°„ ë²”ìœ„, ëŒ€ìƒ ì¢…ëª© ë“± ë©”íƒ€ë°ì´í„° ì €ì¥                 â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [4ë‹¨ê³„] ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ (DBì—ì„œ ì¡°ê±´ì‹ ë¡œë“œ)                     â”‚
â”‚  â””â”€ backtester/backengine_*.py                               â”‚
â”‚     â”œâ”€ strategy.dbì—ì„œ ì¡°ê±´ì‹ í…ìŠ¤íŠ¸ ë¡œë“œ                      â”‚
â”‚     â”œâ”€ GetBuyStg/GetSellStgë¡œ ì»´íŒŒì¼                          â”‚
â”‚     â””â”€ exec()ë¡œ ì‹¤í–‰                                          â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [5ë‹¨ê³„] ìµœì í™” ì‹¤í–‰                                           â”‚
â”‚  â””â”€ backtester/optimiz.py                                    â”‚
â”‚     â”œâ”€ Grid Search                                           â”‚
â”‚     â”œâ”€ Optuna (Bayesian Optimization)                        â”‚
â”‚     â””â”€ Genetic Algorithm                                     â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [6ë‹¨ê³„] ê²°ê³¼ ì €ì¥                                             â”‚
â”‚  â””â”€ _database/backtest.db                                    â”‚
â”‚  â””â”€ _database/optuna.db                                      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.3.2 GUI ì¡°ê±´ì‹ í¸ì§‘ ì½”ë“œ ë¶„ì„

**íŒŒì¼**: `ui/ui_vars_change.py`
**ë¼ì¸**: 6-42
**ëª©ì **: ì¡°ê±´ì‹ í…ìŠ¤íŠ¸ í¬ë§· ì •ë¦¬ ë° ì‹¤í–‰ ì½”ë“œ ì¶”ê°€

**í•µì‹¬ í•¨ìˆ˜ 1: get_fix_strategy()**

```python
def get_fix_strategy(ui, strategy, gubun):
    """
    ë§¤ìˆ˜/ë§¤ë„ ì¡°ê±´ì‹ì— ì‹¤í–‰ ì½”ë“œ ì¶”ê°€

    Args:
        ui: UI ê°ì²´
        strategy: ì¡°ê±´ì‹ í…ìŠ¤íŠ¸
        gubun: 'ë§¤ìˆ˜' or 'ë§¤ë„'

    Returns:
        str: í¬ë§·íŒ…ëœ ì¡°ê±´ì‹
    """
    if gubun == 'ë§¤ìˆ˜':
        # ì£¼ì‹ ë§¤ìˆ˜
        if ui.focusWidget() in (ui.svjb_pushButon_02, ...):
            if '\nif ë§¤ìˆ˜:' in strategy:
                strategy = strategy.split('\nif ë§¤ìˆ˜:')[0] + stock_buy_signal
            elif 'self.tickdata' not in strategy:
                strategy += '\n' + stock_buy_signal
        # ì½”ì¸ ë§¤ìˆ˜
        else:
            if ui.dict_set['ê±°ë˜ì†Œ'] == 'ì—…ë¹„íŠ¸':
                if '\nif ë§¤ìˆ˜:' in strategy:
                    strategy = strategy.split('\nif ë§¤ìˆ˜:')[0] + coin_buy_signal
    else:
        # ë§¤ë„ ë¡œì§ (ìœ ì‚¬)
        # ...

    return strategy
```

**stock_buy_signal ì˜ˆì‹œ** (`ui/set_text.py`):
```python
stock_buy_signal = """
if ë§¤ìˆ˜:
    self.Buy(vturn, vkey)
"""
```

**íŒŒì¼**: `ui/ui_vars_change.py`
**ë¼ì¸**: 104-158
**ëª©ì **: "ë³€ìˆ˜" ë¬¸ìì—´ì„ `self.vars[N]`ìœ¼ë¡œ ìë™ ë³€í™˜

**í•µì‹¬ í•¨ìˆ˜ 2: get_stgtxt_to_varstxt()**

```python
def get_stgtxt_to_varstxt(ui, buystg, sellstg):
    """
    ì¡°ê±´ì‹ í…ìŠ¤íŠ¸ì˜ 'ë³€ìˆ˜' ë¬¸ìì—´ì„ 'self.vars[N]'ìœ¼ë¡œ ë³€í™˜

    ì˜ˆì‹œ:
        ì…ë ¥: "not (ì²´ê²°ê°•ë„ < ë³€ìˆ˜ or ì²´ê²°ê°•ë„ > ë³€ìˆ˜)"
        ì¶œë ¥: "not (ì²´ê²°ê°•ë„ < self.vars[1] or ì²´ê²°ê°•ë„ > self.vars[2])"

    Args:
        ui: UI ê°ì²´
        buystg: ë§¤ìˆ˜ ì¡°ê±´ì‹ í…ìŠ¤íŠ¸
        sellstg: ë§¤ë„ ì¡°ê±´ì‹ í…ìŠ¤íŠ¸

    Returns:
        tuple: (ë³€í™˜ëœ ë§¤ìˆ˜ ì¡°ê±´ì‹, ë³€í™˜ëœ ë§¤ë„ ì¡°ê±´ì‹)
    """
    cnt = 1
    sellstg_str, buystg_str = '', ''

    # ë§¤ë„ ì¡°ê±´ë¶€í„° ì²˜ë¦¬ (ì¼ë°˜ì ì¸ ê²½ìš°)
    if sellstg != '' and 'ë³€ìˆ˜' in sellstg:
        sellstg = sellstg.split('\n')
        for line in sellstg:
            if 'ë³€ìˆ˜' in line:
                for text in line:
                    sellstg_str += text
                    if sellstg_str[-2:] == 'ë³€ìˆ˜':
                        sellstg_str = sellstg_str.replace('ë³€ìˆ˜', f'self.vars[{cnt}]')
                        cnt += 1
                sellstg_str += '\n'
            else:
                sellstg_str += line + '\n'

    # ë§¤ìˆ˜ ì¡°ê±´ ì²˜ë¦¬
    if buystg != '' and 'ë³€ìˆ˜' in buystg:
        # ... (ìœ ì‚¬í•œ ë¡œì§)
        pass

    return buystg_str[:-1], sellstg_str[:-1]
```

**ì‚¬ìš© ì˜ˆì‹œ**:
```python
# ì‚¬ìš©ìê°€ GUIì—ì„œ ì…ë ¥
buystg = "not (ì²´ê²°ê°•ë„ < ë³€ìˆ˜ or ì²´ê²°ê°•ë„ > ë³€ìˆ˜)"
sellstg = "ìˆ˜ìµë¥  >= ë³€ìˆ˜"

# ë³€í™˜
buystg_converted, sellstg_converted = get_stgtxt_to_varstxt(ui, buystg, sellstg)

print(buystg_converted)
# ì¶œë ¥: "not (ì²´ê²°ê°•ë„ < self.vars[2] or ì²´ê²°ê°•ë„ > self.vars[3])"

print(sellstg_converted)
# ì¶œë ¥: "ìˆ˜ìµë¥  >= self.vars[1]"
```

**íŒŒì¼**: `ui/ui_vars_change.py`
**ë¼ì¸**: 45-101
**ëª©ì **: ìµœì í™” ë²”ìœ„ì™€ GA ë²”ìœ„ ê°„ ìƒí˜¸ ë³€í™˜

**í•µì‹¬ í•¨ìˆ˜ 3: get_optivars_to_gavars()**

```python
def get_optivars_to_gavars(opti_vars_text):
    """
    ìµœì í™” ë²”ìœ„ í˜•ì‹ì„ GA ë²”ìœ„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜

    ìµœì í™” ë²”ìœ„ í˜•ì‹:
        self.vars[0] = [[60, 260, 20], 150]
        # [ì‹œì‘, ë, ê°„ê²©], ì´ˆê¸°ê°’

    GA ë²”ìœ„ í˜•ì‹:
        self.vars[0] = [[60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260], 150]
        # [ëª¨ë“  ê°€ëŠ¥í•œ ê°’ë“¤], ì´ˆê¸°ê°’

    Args:
        opti_vars_text: ìµœì í™” ë²”ìœ„ í…ìŠ¤íŠ¸

    Returns:
        str: GA ë²”ìœ„ í…ìŠ¤íŠ¸
    """
    ga_vars_text = ''
    try:
        vars_ = {}
        opti_vars_text = opti_vars_text.replace('self.vars', 'vars_')
        exec(compile(opti_vars_text, '<string>', 'exec'))

        for i in range(len(vars_)):
            ga_vars_text = f'{ga_vars_text}self.vars[{i}] = [['
            vars_start, vars_last, vars_gap = vars_[i][0]
            vars_high = vars_[i][1]
            vars_curr = vars_start

            if vars_start == vars_last:
                ga_vars_text = f'{ga_vars_text}{vars_curr}], {vars_curr}]\n'
            elif vars_start < vars_last:
                while vars_curr <= vars_last:
                    ga_vars_text = f'{ga_vars_text}{vars_curr}, '
                    vars_curr += vars_gap
                    if vars_gap < 0:
                        vars_curr = round(vars_curr, 2)
                ga_vars_text = f'{ga_vars_text[:-2]}], {vars_high}]\n'
            # ... (ì—­ë°©í–¥ ë¡œì§ ìƒëµ)
    except:
        print_exc()

    ga_vars_text = ga_vars_text.replace('vars_', 'self.vars')
    return ga_vars_text[:-1]
```

#### 3.3.3 strategy.db ìŠ¤í‚¤ë§ˆ (ì¶”ì •)

í˜„ì¬ STOM ì‹œìŠ¤í…œì€ `_database/strategy.db`ì— ì¡°ê±´ì‹ì„ ì €ì¥í•˜ëŠ” ê²ƒìœ¼ë¡œ ì¶”ì •ë©ë‹ˆë‹¤. ì •í™•í•œ ìŠ¤í‚¤ë§ˆëŠ” ì½”ë“œ ì¡°ì‚¬ê°€ í•„ìš”í•˜ì§€ë§Œ, ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ì¼ ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤:

**ì¶”ì • í…Œì´ë¸” êµ¬ì¡°**:
```sql
-- ì£¼ì‹ í‹± ì „ëµ í…Œì´ë¸” (ì¶”ì •)
CREATE TABLE strategy_tick (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ì „ëµëª… TEXT NOT NULL,
    ë§¤ìˆ˜ì¡°ê±´ TEXT,  -- ë§¤ìˆ˜ ì¡°ê±´ì‹ Python ì½”ë“œ
    ë§¤ë„ì¡°ê±´ TEXT,  -- ë§¤ë„ ì¡°ê±´ì‹ Python ì½”ë“œ
    ë³€ìˆ˜ë²”ìœ„ TEXT,  -- self.vars ì •ì˜ (ìµœì í™” ë²”ìœ„)
    ì„¤ëª… TEXT,
    ì‹œì‘ì‹œê°„ TEXT,  -- ì˜ˆ: "09:00:00"
    ì¢…ë£Œì‹œê°„ TEXT,  -- ì˜ˆ: "09:05:00"
    ëŒ€ìƒì¢…ëª© TEXT,  -- ì˜ˆ: "ì‹œê°€ì´ì•¡ 3000ì–µ ë¯¸ë§Œ"
    ìƒì„±ì¼ TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ìˆ˜ì •ì¼ TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì£¼ì‹ ë¶„ë´‰ ì „ëµ í…Œì´ë¸” (ì¶”ì •)
CREATE TABLE strategy_min (
    -- ... (ìœ ì‚¬í•œ êµ¬ì¡°)
);

-- ì½”ì¸ ì „ëµ í…Œì´ë¸” (ì¶”ì •)
CREATE TABLE strategy_coin_tick (
    -- ... (ìœ ì‚¬í•œ êµ¬ì¡°)
);

CREATE TABLE strategy_coin_min (
    -- ... (ìœ ì‚¬í•œ êµ¬ì¡°)
);
```

#### 3.3.4 ìë™í™” ì‹œìŠ¤í…œì—ì„œì˜ ì¤‘ìš”ì„±

**âš ï¸ ìë™í™” ì‹œìŠ¤í…œ êµ¬í˜„ ì‹œ í•„ìˆ˜ ê³ ë ¤ì‚¬í•­**:

AI ê¸°ë°˜ ì¡°ê±´ì‹ ìë™í™” ì‹œìŠ¤í…œì€ ë‹¤ìŒ ë‹¨ê³„ë¥¼ **ëª¨ë‘ ìë™í™”**í•´ì•¼ í•©ë‹ˆë‹¤:

1. âœ… **AI ì¡°ê±´ì‹ ìƒì„±** (Section 4ì—ì„œ ì œì•ˆ)
2. âœ… **MD íŒŒì¼ ì €ì¥** (Section 5-6ì—ì„œ ì œì•ˆ)
3. âš ï¸ **strategy.dbì— INSERT** â¬…ï¸ **í•„ìˆ˜ êµ¬í˜„ í•­ëª©**
   - í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ DB ì ‘ê·¼
   - `get_fix_strategy()`, `get_stgtxt_to_varstxt()` ë¡œì§ ì ìš©
   - ë³€ìˆ˜ ë²”ìœ„ ìë™ ë³€í™˜
4. âœ… **ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰** (ê¸°ì¡´ ì‹œìŠ¤í…œ í™œìš©)
5. âœ… **ìµœì í™” ì‹¤í–‰** (ê¸°ì¡´ ì‹œìŠ¤í…œ í™œìš©)
6. âœ… **ê²°ê³¼ ë¶„ì„** (Section 5ì—ì„œ ì œì•ˆ)
7. âœ… **í”¼ë“œë°± ìƒì„±** (Section 5ì—ì„œ ì œì•ˆ)

**3ë‹¨ê³„ "strategy.db INSERT"ë¥¼ ê±´ë„ˆë›°ë©´**:
- MD íŒŒì¼ë§Œ ìƒì„±ë˜ê³  ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ ë¶ˆê°€
- ê¸°ì¡´ STOM ì‹œìŠ¤í…œê³¼ ì—°ë™ ë¶ˆê°€
- ì™„ì „ ìë™í™” ë¶ˆê°€ëŠ¥

ë”°ë¼ì„œ **Section 6 êµ¬í˜„ ë°©ì•ˆì—ì„œ StrategyDBManager í´ë˜ìŠ¤**ë¥¼ ë°˜ë“œì‹œ ì„¤ê³„í•´ì•¼ í•©ë‹ˆë‹¤.

---

## 4. AI ê¸°ë°˜ ì¡°ê±´ì‹ ìë™ ìƒì„± ì‹œìŠ¤í…œ ğŸ’¡ [ì œì•ˆì‚¬í•­]

### 4.1 ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

#### 4.1.1 ì „ì²´ êµ¬ì¡°ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AI ì¡°ê±´ì‹ ìƒì„± ì—”ì§„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              â”‚     â”‚              â”‚     â”‚              â”‚â”‚
â”‚  â”‚  LLM ìƒì„±ê¸°  â”‚â”€â”€â”€â”€â–¶â”‚  ê²€ì¦ ëª¨ë“ˆ   â”‚â”€â”€â”€â”€â–¶â”‚  í…œí”Œë¦¿í™”    â”‚â”‚
â”‚  â”‚  (GPT-4/     â”‚     â”‚  (ë¬¸ë²•/êµ¬ì¡°)  â”‚     â”‚  (MD íŒŒì¼)  â”‚â”‚
â”‚  â”‚   Claude)    â”‚     â”‚              â”‚     â”‚              â”‚â”‚
â”‚  â”‚              â”‚     â”‚              â”‚     â”‚              â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚         â–²                                         â”‚          â”‚
â”‚         â”‚                                         â–¼          â”‚
â”‚         â”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚              â”‚ â”‚
â”‚  â”‚              â”‚                         â”‚  ì¡°ê±´ì‹ DB   â”‚ â”‚
â”‚  â”‚  í”¼ë“œë°± ë£¨í”„ â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  (sqlite)    â”‚ â”‚
â”‚  â”‚              â”‚                         â”‚              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â–²                                                   â”‚
â”‚         â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         â”‚            ìë™ ë°±í…ŒìŠ¤íŒ… íŒŒì´í”„ë¼ì¸                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              â”‚     â”‚              â”‚     â”‚              â”‚â”‚
â”‚  â”‚  ë°±í…ŒìŠ¤í„°    â”‚â”€â”€â”€â”€â–¶â”‚  ìµœì í™”      â”‚â”€â”€â”€â”€â–¶â”‚  ê²°ê³¼ í‰ê°€   â”‚â”‚
â”‚  â”‚  ì‹¤í–‰        â”‚     â”‚  (Grid/      â”‚     â”‚  (14ê°œ ì§€í‘œ) â”‚â”‚
â”‚  â”‚              â”‚     â”‚   Optuna/GA) â”‚     â”‚              â”‚â”‚
â”‚  â”‚              â”‚     â”‚              â”‚     â”‚              â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚         â”‚                                         â”‚          â”‚
â”‚         â”‚                                         â–¼          â”‚
â”‚         â”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  ê²°ê³¼ DB     â”‚ â”‚
â”‚                                             â”‚  (ì„±ê³¼ ê¸°ë¡) â”‚ â”‚
â”‚                                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 LLM ê¸°ë°˜ ì¡°ê±´ì‹ ìƒì„±

#### 4.2.1 í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ì „ëµ

**1ë‹¨ê³„: ì»¨í…ìŠ¤íŠ¸ ì£¼ì…**

```python
system_prompt = f"""
ë‹¹ì‹ ì€ STOM ì£¼ì‹ ìë™ê±°ë˜ ì‹œìŠ¤í…œì˜ ì „ë¬¸ ì¡°ê±´ì‹ ì‘ì„±ìì…ë‹ˆë‹¤.

# ì—­í• 
- ë°±í…ŒìŠ¤íŒ… ê°€ëŠ¥í•œ Python ê¸°ë°˜ ë§¤ìˆ˜/ë§¤ë„ ì¡°ê±´ì‹ ì‘ì„±
- 826ê°œ í‹± ë³€ìˆ˜ ë˜ëŠ” 752ê°œ ë¶„ë´‰ ë³€ìˆ˜ ì‚¬ìš©
- ê°€ì´ë“œë¼ì¸ 100% ì¤€ìˆ˜

# ì œì•½ì‚¬í•­
1. ë³€ìˆ˜ëŠ” ê°€ì´ë“œë¼ì¸ì— ëª…ì‹œëœ ê²ƒë§Œ ì‚¬ìš©
2. ë§¤ìˆ˜ ì¡°ê±´ì€ 'not (ì¡°ê±´)' í˜•íƒœ
3. ë§¤ë„ ì¡°ê±´ì€ 'ì¡°ê±´' í˜•íƒœ
4. í•œ ì¤„ì— í•˜ë‚˜ì˜ ì¡°ê±´ë§Œ
5. ë³µì¡í•œ ë¹„êµëŠ” ëª…ì‹œì  ë¶„ë¦¬ (a < b < c â†’ a < b and b < c)

# ì°¸ì¡° ë¬¸ì„œ
{guideline_content}  # Back_Testing_Guideline_Tick/Min.md ì „ì²´ ë‚´ìš©
{template_content}   # Condition_Document_Template_Guideline.md ì „ì²´ ë‚´ìš©
"""

user_prompt = f"""
ë‹¤ìŒ ì „ëµì— ëŒ€í•œ ì¡°ê±´ì‹ì„ ì‘ì„±í•´ì£¼ì„¸ìš”:

**ì „ëµ íƒ€ì…**: {strategy_type}  # ì˜ˆ: "ì¥ ì‹œì‘ ê¸‰ë“±ì£¼ í¬ì°©"
**ëŒ€ìƒ ì‹œê°„**: {time_range}     # ì˜ˆ: "09:00:00 ~ 09:05:00"
**ëŒ€ìƒ ì¢…ëª©**: {target_stocks}  # ì˜ˆ: "ì‹œê°€ì´ì•¡ 3,000ì–µ ë¯¸ë§Œ"
**í•µì‹¬ ë³€ìˆ˜**: {key_variables}  # ì˜ˆ: "ì²´ê²°ê°•ë„, ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ, ë“±ë½ìœ¨"

**ê¸°ëŒ€ ì„±ê³¼**:
- ìŠ¹ë¥ : {target_winrate}%
- í‰ê·  ìˆ˜ìµë¥ : {target_profit}%
- MDD: {target_mdd}% ì´í•˜
"""
```

**2ë‹¨ê³„: Few-shot Learning**

```python
few_shot_examples = [
    {
        "strategy": "ì¥ ì‹œì‘ ê¸‰ë“±ì£¼ í¬ì°©",
        "buy_conditions": """
not (í˜„ì¬ê°€ < 1000 or í˜„ì¬ê°€ > 50000)
not (ë“±ë½ìœ¨ < 1.0 or ë“±ë½ìœ¨ > 8.0)
not (ì²´ê²°ê°•ë„ < 50 or ì²´ê²°ê°•ë„ > 300)
not (ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ < self.vars[1])
not (íšŒì „ìœ¨ < self.vars[2])
        """,
        "sell_conditions": """
ìˆ˜ìµë¥  <= -2  # ì†ì ˆ
ìˆ˜ìµë¥  >= self.vars[3]  # ìµì ˆ
ìµœê³ ìˆ˜ìµë¥  > 3 and ìˆ˜ìµë¥  < ìµœê³ ìˆ˜ìµë¥  * self.vars[4]  # íŠ¸ë ˆì¼ë§
        """,
        "variables": {
            "self.vars[1]": {"range": [1, 10, 1], "default": 3, "unit": "ì–µì›"},
            "self.vars[2]": {"range": [1, 5, 0.5], "default": 2, "unit": "%"},
            "self.vars[3]": {"range": [2, 5, 0.5], "default": 3, "unit": "%"},
            "self.vars[4]": {"range": [0.6, 0.9, 0.05], "default": 0.75, "unit": "ë¹„ìœ¨"},
        }
    },
    # 10-20ê°œì˜ ì„±ê³µ ì‚¬ë¡€ ì¶”ê°€
]
```

**3ë‹¨ê³„: ë°˜ë³µì  ê°œì„ **

```python
def generate_condition_with_refinement(strategy_desc, max_iterations=5):
    for iteration in range(max_iterations):
        # LLM ìƒì„±
        generated_code = llm.generate(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            few_shot_examples=few_shot_examples,
            temperature=0.3 + iteration * 0.1  # ì ì§„ì  íƒìƒ‰ í™•ëŒ€
        )

        # ë¬¸ë²• ê²€ì¦
        is_valid, errors = validate_syntax(generated_code)
        if not is_valid:
            # ì—ëŸ¬ í”¼ë“œë°±
            user_prompt += f"\n\nì´ì „ ì‹œë„ ì—ëŸ¬:\n{errors}\nìˆ˜ì • ìš”ì²­"
            continue

        # êµ¬ì¡° ê²€ì¦
        is_template_valid = validate_template(generated_code)
        if not is_template_valid:
            user_prompt += f"\n\ní…œí”Œë¦¿ êµ¬ì¡° ìœ„ë°˜. ìˆ˜ì • ìš”ì²­"
            continue

        # ë³€ìˆ˜ ë²”ìœ„ ê²€ì¦
        is_var_valid = validate_var_ranges(generated_code)
        if not is_var_valid:
            user_prompt += f"\n\nself.vars ë²”ìœ„ ì˜¤ë¥˜. ìµœëŒ€ 20ê°œ/ë³€ìˆ˜ ì¤€ìˆ˜"
            continue

        # ì„±ê³µ
        return generated_code, iteration

    # ì‹¤íŒ¨
    return None, max_iterations
```

#### 4.2.2 Genetic Programming ì¡°ê±´ì‹ ì§„í™”

**DEAP ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš©**

```python
from deap import base, creator, tools, algorithms
import operator

# 1. Primitive Set ì •ì˜
pset = gp.PrimitiveSet("MAIN", 0)

# ë³€ìˆ˜ ì¶”ê°€ (826ê°œ í‹± ë³€ìˆ˜)
pset.addEphemeralConstant("í˜„ì¬ê°€", lambda: random.uniform(1000, 50000))
pset.addEphemeralConstant("ë“±ë½ìœ¨", lambda: random.uniform(-30, 30))
pset.addEphemeralConstant("ì²´ê²°ê°•ë„", lambda: random.uniform(0, 500))
# ... 826ê°œ ë³€ìˆ˜

# ì—°ì‚°ì ì¶”ê°€
pset.addPrimitive(operator.add, 2)
pset.addPrimitive(operator.sub, 2)
pset.addPrimitive(operator.mul, 2)
pset.addPrimitive(safe_div, 2)  # 0 ë‚˜ëˆ„ê¸° ë°©ì§€
pset.addPrimitive(operator.lt, 2)
pset.addPrimitive(operator.gt, 2)
pset.addPrimitive(operator.and_, 2)
pset.addPrimitive(operator.or_, 2)
pset.addPrimitive(operator.not_, 1)

# í•¨ìˆ˜ ì¶”ê°€
pset.addPrimitive(ì´ë™í‰ê· , 2)  # (í˜„ì¬ê°€, window)
pset.addPrimitive(ìµœê³ í˜„ì¬ê°€, 2)
pset.addPrimitive(ì²´ê²°ê°•ë„í‰ê· , 2)

# 2. Fitness ì •ì˜
creator.create("FitnessMax", base.Fitness, weights=(1.0,))  # ìˆ˜ìµë¥  ìµœëŒ€í™”
creator.create("Individual", gp.PrimitiveTree, fitness=creator.FitnessMax)

# 3. Toolbox ì„¤ì •
toolbox = base.Toolbox()
toolbox.register("expr", gp.genHalfAndHalf, pset=pset, min_=1, max_=3)
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.expr)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("compile", gp.compile, pset=pset)

# 4. Fitness í‰ê°€ í•¨ìˆ˜
def eval_condition(individual):
    # ì¡°ê±´ì‹ â†’ Python ì½”ë“œ ë³€í™˜
    func = toolbox.compile(expr=individual)

    # ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰
    result = run_backtest(func)

    # ì í•©ë„ ë°˜í™˜ (ì˜ˆ: ìˆ˜ìµë¥ )
    return (result['profit_rate'],)

toolbox.register("evaluate", eval_condition)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("mate", gp.cxOnePoint)
toolbox.register("mutate", gp.mutUniform, expr=toolbox.expr, pset=pset)

# 5. ì§„í™” ì‹¤í–‰
population = toolbox.population(n=300)
hof = tools.HallOfFame(1)

stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", np.mean)
stats.register("std", np.std)
stats.register("min", np.min)
stats.register("max", np.max)

population, log = algorithms.eaSimple(
    population, toolbox,
    cxpb=0.5,  # êµë°° í™•ë¥ 
    mutpb=0.2,  # ë³€ì´ í™•ë¥ 
    ngen=40,    # ì„¸ëŒ€ ìˆ˜
    stats=stats,
    halloffame=hof,
    verbose=True
)

# ìµœì  ì¡°ê±´ì‹
best_condition = hof[0]
```

### 4.3 Feature Importance ê¸°ë°˜ ë³€ìˆ˜ ì„ íƒ

#### 4.3.1 XGBoost Feature Importance

```python
import xgboost as xgb
import shap

# 1. ë°ì´í„° ì¤€ë¹„
# ê³¼ê±° ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ì—ì„œ ë³€ìˆ˜-ì„±ê³¼ ê´€ê³„ í•™ìŠµ
df_history = load_backtest_history()

# X: 826ê°œ ë³€ìˆ˜ ê°’
# y: ì„±ê³¼ ì§€í‘œ (TG, TP, TPI ë“±)
X = df_history[tick_variables]  # 826ê°œ ì»¬ëŸ¼
y = df_history['profit_rate']

# 2. XGBoost ëª¨ë¸ í•™ìŠµ
model = xgb.XGBRegressor(
    n_estimators=1000,
    max_depth=6,
    learning_rate=0.01,
    objective='reg:squarederror'
)
model.fit(X, y)

# 3. Feature Importance ì¶”ì¶œ
importance = model.feature_importances_
feature_importance_df = pd.DataFrame({
    'feature': X.columns,
    'importance': importance
}).sort_values('importance', ascending=False)

# ìƒìœ„ 50ê°œ ë³€ìˆ˜ ì„ íƒ
top_features = feature_importance_df.head(50)['feature'].tolist()

print("Top 10 ì¤‘ìš” ë³€ìˆ˜:")
print(feature_importance_df.head(10))
# ì˜ˆ:
#           feature  importance
# ì²´ê²°ê°•ë„           0.142
# ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ       0.118
# ë“±ë½ìœ¨             0.095
# íšŒì „ìœ¨             0.082
# ì‹œê°€ëŒ€ë¹„ë“±ë½ìœ¨     0.071
# ...
```

#### 4.3.2 SHAP ë¶„ì„

```python
# SHAP explainer ìƒì„±
explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(X)

# ë³€ìˆ˜ë³„ ê¸°ì—¬ë„ ì‹œê°í™”
shap.summary_plot(shap_values, X, plot_type="bar")

# ë³€ìˆ˜ ê°„ ìƒí˜¸ì‘ìš© ë¶„ì„
shap.dependence_plot("ì²´ê²°ê°•ë„", shap_values, X, interaction_index="ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ")

# ì¡°ê±´ì‹ ìƒì„± ì‹œ SHAP ì¸ì‚¬ì´íŠ¸ í™œìš©
def generate_conditions_with_shap(shap_values, X, threshold=0.01):
    """
    SHAP ê°’ì´ ë†’ì€ ë³€ìˆ˜ ì¡°í•©ìœ¼ë¡œ ì¡°ê±´ì‹ ìë™ ìƒì„±
    """
    conditions = []

    # ê° ìƒ˜í”Œì˜ SHAP ê°’ ë¶„ì„
    for i in range(len(shap_values)):
        # ê¸ì •ì  ê¸°ì—¬ ë³€ìˆ˜ (ìˆ˜ìµ ì¦ê°€)
        positive_features = np.where(shap_values[i] > threshold)[0]

        for feat_idx in positive_features:
            feat_name = X.columns[feat_idx]
            feat_value = X.iloc[i, feat_idx]
            shap_contrib = shap_values[i, feat_idx]

            # ì¡°ê±´ ìƒì„±
            if shap_contrib > 0.05:
                conditions.append(f"not ({feat_name} < {feat_value * 0.9})")

    # ì¤‘ë³µ ì œê±° ë° ë¹ˆë„ ì •ë ¬
    condition_counts = Counter(conditions)
    top_conditions = condition_counts.most_common(20)

    return [cond for cond, count in top_conditions]
```

### 4.4 í…œí”Œë¦¿ ê¸°ë°˜ ë³€ìˆ˜ ì¡°í•© ìë™í™”

#### 4.4.1 ì¡°ê±´ì‹ í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬

```python
CONDITION_TEMPLATES = {
    "ê¸‰ë“±ì£¼_í¬ì°©": {
        "description": "ì¥ ì‹œì‘ ê¸‰ë“±ì£¼ í¬ì°©",
        "time_range": "09:00:00 ~ 09:05:00",
        "buy_template": """
# ê°€ê²© ë²”ìœ„
not (í˜„ì¬ê°€ < {price_min} or í˜„ì¬ê°€ > {price_max})

# ë“±ë½ìœ¨ ë²”ìœ„
not (ë“±ë½ìœ¨ < {change_min} or ë“±ë½ìœ¨ > {change_max})

# ì²´ê²°ê°•ë„
not (ì²´ê²°ê°•ë„ < {strength_min} or ì²´ê²°ê°•ë„ > {strength_max})

# ê±°ë˜ëŒ€ê¸ˆ
not (ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ < {trade_amount_min})
not (ë‹¹ì¼ê±°ë˜ëŒ€ê¸ˆ < {daily_amount_min})

# íšŒì „ìœ¨
not (íšŒì „ìœ¨ < {turnover_min})

# í˜¸ê°€ ì¡°ê±´
not (ë§¤ë„ì´ì”ëŸ‰ > ë§¤ìˆ˜ì´ì”ëŸ‰ * {hoga_ratio})

# VI íšŒí”¼
not (í˜„ì¬ê°€ >= VIì•„ë˜5í˜¸ê°€)
        """,
        "sell_template": """
# ì†ì ˆ
ìˆ˜ìµë¥  <= {stop_loss}

# ìµì ˆ
ìˆ˜ìµë¥  >= {take_profit}

# íŠ¸ë ˆì¼ë§ ìŠ¤í†±
ìµœê³ ìˆ˜ìµë¥  > {trailing_threshold} and ìˆ˜ìµë¥  < ìµœê³ ìˆ˜ìµë¥  * {trailing_ratio}

# ì‹œê°„ ì²­ì‚°
ë³´ìœ ì‹œê°„ > {max_holding_time}

# ì²´ê²°ê°•ë„ ê¸‰ë½
ì²´ê²°ê°•ë„ <= ìµœê³ ì²´ê²°ê°•ë„(30) * {strength_drop_ratio}
        """,
        "var_ranges": {
            "price_min": [500, 2000, 100],
            "price_max": [30000, 100000, 5000],
            "change_min": [0.5, 3.0, 0.5],
            "change_max": [5.0, 15.0, 1.0],
            # ... ë³€ìˆ˜ë³„ ë²”ìœ„
        }
    },

    "ëŒíŒŒ_ì „ëµ": {
        "description": "ê³ ê°€ ëŒíŒŒ ëª¨ë©˜í…€ í¬ì°©",
        "time_range": "09:30:00 ~ 10:00:00",
        "buy_template": """
# ê³ ê°€ ëŒíŒŒ
not (í˜„ì¬ê°€ < ìµœê³ í˜„ì¬ê°€({lookback_period}))

# ì´ë™í‰ê· ì„  ìƒë°©
not (í˜„ì¬ê°€ < ì´ë™í‰ê· ({ma_period}))
not (ì´ë™í‰ê· ({ma_short}) < ì´ë™í‰ê· ({ma_long}))

# ê±°ë˜ëŸ‰ ê¸‰ì¦
not (ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ < ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆí‰ê· ({volume_period}) * {volume_ratio})

# ë“±ë½ìœ¨ ê°ë„
not (ë“±ë½ìœ¨ê°ë„({angle_period}) < {angle_threshold})
        """,
        # ...
    },

    # 20-30ê°œì˜ í…œí”Œë¦¿ ì •ì˜
}
```

#### 4.4.2 ìë™ ì¡°í•© ìƒì„±ê¸°

```python
def generate_conditions_from_template(template_name, param_grid=None):
    """
    í…œí”Œë¦¿ê³¼ íŒŒë¼ë¯¸í„° ê·¸ë¦¬ë“œë¡œ ì¡°ê±´ì‹ ìë™ ìƒì„±
    """
    template = CONDITION_TEMPLATES[template_name]

    if param_grid is None:
        # ê¸°ë³¸ íŒŒë¼ë¯¸í„° ê·¸ë¦¬ë“œ
        param_grid = {
            key: np.arange(var_range[0], var_range[1], var_range[2])
            for key, var_range in template['var_ranges'].items()
        }

    # ëª¨ë“  ì¡°í•© ìƒì„± (GridSearchCV ë°©ì‹)
    from itertools import product
    param_combinations = list(product(*param_grid.values()))

    generated_conditions = []
    for params in param_combinations[:1000]:  # ìµœëŒ€ 1000ê°œ
        param_dict = dict(zip(param_grid.keys(), params))

        # í…œí”Œë¦¿ ì±„ìš°ê¸°
        buy_code = template['buy_template'].format(**param_dict)
        sell_code = template['sell_template'].format(**param_dict)

        # ì¡°ê±´ì‹ ê°ì²´ ìƒì„±
        condition = {
            "name": f"{template_name}_{len(generated_conditions):04d}",
            "description": template['description'],
            "time_range": template['time_range'],
            "buy_conditions": buy_code,
            "sell_conditions": sell_code,
            "parameters": param_dict
        }

        generated_conditions.append(condition)

    return generated_conditions

# ì‚¬ìš© ì˜ˆ
conditions = generate_conditions_from_template("ê¸‰ë“±ì£¼_í¬ì°©")
print(f"ìƒì„±ëœ ì¡°ê±´ì‹ ìˆ˜: {len(conditions)}")
# ìƒì„±ëœ ì¡°ê±´ì‹ ìˆ˜: 1000
```

---

## 5. ìë™í™” ìˆœí™˜ í”„ë¡œì„¸ìŠ¤ ì„¤ê³„ ğŸ’¡ [ì œì•ˆì‚¬í•­]

### 5.1 ì™„ì „ ìë™í™” í”Œë¡œìš°

ìë™í™” ì‹œìŠ¤í…œì€ ë‹¤ìŒ 8ë‹¨ê³„ ìˆœí™˜ í”„ë¡œì„¸ìŠ¤ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤ (Section 3.3ì—ì„œ ë¶„ì„í•œ GUI í”„ë¡œì„¸ìŠ¤ í¬í•¨):

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ì™„ì „ ìë™í™” ìˆœí™˜ í”„ë¡œì„¸ìŠ¤ (8ë‹¨ê³„)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  [1ë‹¨ê³„] AI ì¡°ê±´ì‹ ìƒì„±                                        â”‚
â”‚  â””â”€ LLM / Genetic Programming / Template ê¸°ë°˜                â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [2ë‹¨ê³„] MD íŒŒì¼ ìë™ ìƒì„±                                     â”‚
â”‚  â””â”€ ê°€ì´ë“œë¼ì¸ ì¤€ìˆ˜ í˜•ì‹ìœ¼ë¡œ ì €ì¥                              â”‚
â”‚  â””â”€ docs/Condition/Tick/*.md or Min/*.md                     â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [3ë‹¨ê³„] âš ï¸ strategy.db ìë™ INSERT â¬…ï¸ í•µì‹¬!                  â”‚
â”‚  â””â”€ StrategyDBManager í´ë˜ìŠ¤ (Section 6.2ì—ì„œ ì„¤ê³„)           â”‚
â”‚     â”œâ”€ get_fix_strategy() ë¡œì§ ì ìš©                           â”‚
â”‚     â”œâ”€ get_stgtxt_to_varstxt() ë³€ìˆ˜ ë³€í™˜                      â”‚
â”‚     â””â”€ INSERT INTO strategy_tick/min                         â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [4ë‹¨ê³„] ë°±í…ŒìŠ¤íŒ… ìë™ ì‹¤í–‰                                    â”‚
â”‚  â””â”€ DBì—ì„œ ì¡°ê±´ì‹ ë¡œë“œ â†’ GetBuyStg/GetSellStg â†’ exec()       â”‚
â”‚  â””â”€ ê¸°ì¡´ STOM ë°±í…ŒìŠ¤íŒ… ì—”ì§„ í™œìš©                               â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [5ë‹¨ê³„] ìµœì í™” ìë™ ì‹¤í–‰                                      â”‚
â”‚  â””â”€ Grid Search / Optuna / GA                                â”‚
â”‚  â””â”€ ê¸°ì¡´ STOM ìµœì í™” ì—”ì§„ í™œìš©                                 â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [6ë‹¨ê³„] ê²°ê³¼ ë¶„ì„ ë° ê¸°ë¡                                     â”‚
â”‚  â””â”€ OPTISTD 14ê°œ ì§€í‘œ ê³„ì‚°                                    â”‚
â”‚  â””â”€ backtest.db, optuna.dbì— ì €ì¥                            â”‚
â”‚  â””â”€ ì„±ê³µ/ì‹¤íŒ¨ íŒ¨í„´ í•™ìŠµ                                       â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [7ë‹¨ê³„] í”¼ë“œë°± ìƒì„±                                           â”‚
â”‚  â””â”€ ì„±ê³¼ ê¸°ë°˜ ê°œì„  ë°©í–¥ ë„ì¶œ                                   â”‚
â”‚  â””â”€ Feature Importance ë¶„ì„                                  â”‚
â”‚  â””â”€ ìƒê´€ê´€ê³„ ë¶„ì„                                             â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  [8ë‹¨ê³„] ë‹¤ìŒ ì¡°ê±´ì‹ ìƒì„± (ìˆœí™˜)                               â”‚
â”‚  â””â”€ í”¼ë“œë°± ë°˜ì˜í•˜ì—¬ [1ë‹¨ê³„]ë¡œ ì´ë™                             â”‚
â”‚  â””â”€ ëª©í‘œ ë‹¬ì„± ì‹œê¹Œì§€ ë°˜ë³µ                                      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 ìˆœí™˜ ì‹œìŠ¤í…œ ê°œìš”

ìœ„ì˜ 8ë‹¨ê³„ ì™„ì „ ìë™í™” í”Œë¡œìš°ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìˆœí™˜ êµ¬ì¡°ë¡œ ë™ì‘í•©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AI ì¡°ê±´ì‹ ìˆœí™˜ ê°œì„  ì‹œìŠ¤í…œ                 â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚  1. AI ìƒì„±  â”‚â”€â”€â”€â”€â”€â”€â–¶â”‚  2. MD ì‘ì„±  â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚         â–²                     â”‚                            â”‚
â”‚         â”‚                     â–¼                            â”‚
â”‚         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚    í”¼ë“œë°± ë£¨í”„          â”‚ 3. DB ì €ì¥   â”‚                    â”‚
â”‚         â”‚              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚         â”‚                     â”‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”              â–¼                            â”‚
â”‚  â”‚ 8. ìˆœí™˜ê²°ì •  â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ 4. ë°±í…ŒìŠ¤íŒ…  â”‚                    â”‚
â”‚         â–²              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚         â”‚                     â”‚                            â”‚
â”‚         â”‚                     â–¼                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ 7. í”¼ë“œë°±    â”‚â—€â”€â”€â”€â”€â”€â”€â”‚ 5. ìµœì í™”   â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                               â”‚                            â”‚
â”‚                               â–¼                            â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚                        â”‚ 6. OPTISTD  â”‚                    â”‚
â”‚                        â”‚    ë¶„ì„     â”‚                    â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**í•µì‹¬ ê°œì„  í¬ì¸íŠ¸:**
1. **DB ì €ì¥ ë‹¨ê³„ ëª…ì‹œ**: MD íŒŒì¼ â†’ strategy.db INSERT â†’ ë°±í…ŒìŠ¤íŒ…
2. **GUI í”„ë¡œì„¸ìŠ¤ í†µí•©**: Section 3.3ì—ì„œ ì„¤ëª…í•œ GUI í”„ë¡œì„¸ìŠ¤ ë°˜ì˜
3. **ì™„ì „ ìë™í™”**: ì‚¬ìš©ì ê°œì… ìµœì†Œí™”, AIê°€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬

---

### 5.3 ë‹¨ê³„ 1: AI ì¡°ê±´ì‹ ìƒì„± (Generation)

#### 5.3.1 ìƒì„± ì „ëµ 3ê°€ì§€

**ì „ëµ A: LLM ê¸°ë°˜ ìƒì„±**
```python
def generate_with_llm(strategy_type, iteration=0):
    """
    LLMì„ ì‚¬ìš©í•œ ì¡°ê±´ì‹ ìƒì„±
    """
    # ì´ì „ ì„±ê³¼ ë°ì´í„° ë¡œë“œ
    past_performance = load_performance_data(strategy_type)

    # ì„±ê³µ íŒ¨í„´ ë¶„ì„
    success_patterns = analyze_success_patterns(past_performance)

    # í”„ë¡¬í”„íŠ¸ ìƒì„±
    prompt = build_prompt(
        strategy_type=strategy_type,
        success_patterns=success_patterns,
        iteration=iteration
    )

    # LLM í˜¸ì¶œ
    response = call_llm_api(prompt)

    # ê²€ì¦
    is_valid, code = validate_and_extract(response)

    return code if is_valid else None
```

**ì „ëµ B: Genetic Programming**
```python
def generate_with_gp(population_size=300, generations=40):
    """
    Genetic Programmingì„ í†µí•œ ì¡°ê±´ì‹ ì§„í™”
    """
    # ì´ˆê¸° ê°œì²´êµ° ìƒì„±
    population = initialize_population(population_size)

    for gen in range(generations):
        # ì í•©ë„ í‰ê°€
        fitness_scores = [evaluate_fitness(ind) for ind in population]

        # ì„ íƒ (í† ë„ˆë¨¼íŠ¸)
        selected = tournament_selection(population, fitness_scores)

        # êµë°°
        offspring = crossover(selected)

        # ë³€ì´
        mutated = mutate(offspring)

        # ë‹¤ìŒ ì„¸ëŒ€
        population = elitism(population, mutated, fitness_scores)

    return best_individual(population)
```

**ì „ëµ C: í…œí”Œë¦¿ ê¸°ë°˜ ì¡°í•©**
```python
def generate_with_template(template_name, optimization_method="random"):
    """
    í…œí”Œë¦¿ ê¸°ë°˜ íŒŒë¼ë¯¸í„° ì¡°í•© ìƒì„±
    """
    template = load_template(template_name)

    if optimization_method == "random":
        # ëœë¤ ìƒ˜í”Œë§ (ë¹ ë¥¸ íƒìƒ‰)
        params = random_sample_params(template.var_ranges, n=100)
    elif optimization_method == "sobol":
        # Sobol ì‹œí€€ìŠ¤ (ì¤€ë‚œìˆ˜)
        params = sobol_sample_params(template.var_ranges, n=100)
    elif optimization_method == "latin_hypercube":
        # Latin Hypercube (ê³µê°„ ê· ë“± ë¶„í¬)
        params = lhs_sample_params(template.var_ranges, n=100)

    conditions = []
    for param_set in params:
        code = fill_template(template, param_set)
        conditions.append(code)

    return conditions
```

#### 5.3.2 ìƒì„± íŒŒì´í”„ë¼ì¸

```python
class ConditionGenerationPipeline:
    def __init__(self, strategy_type, generation_methods=['llm', 'gp', 'template']):
        self.strategy_type = strategy_type
        self.generation_methods = generation_methods
        self.generated_conditions = []

    def run(self, batch_size=100):
        """
        ì—¬ëŸ¬ ìƒì„± ë°©ë²•ì„ ë³‘ë ¬ë¡œ ì‹¤í–‰
        """
        results = []

        # LLM ìƒì„± (10-20ê°œ)
        if 'llm' in self.generation_methods:
            llm_conditions = []
            for i in range(batch_size // 5):
                code = generate_with_llm(self.strategy_type, iteration=i)
                if code:
                    llm_conditions.append(code)
            results.extend(llm_conditions)

        # GP ìƒì„± (30-50ê°œ)
        if 'gp' in self.generation_methods:
            gp_conditions = generate_with_gp(
                population_size=300,
                generations=40
            )
            results.extend(gp_conditions[:batch_size // 2])

        # í…œí”Œë¦¿ ìƒì„± (ë‚˜ë¨¸ì§€)
        if 'template' in self.generation_methods:
            remaining = batch_size - len(results)
            template_conditions = generate_with_template(
                self.strategy_type,
                optimization_method="sobol"
            )
            results.extend(template_conditions[:remaining])

        self.generated_conditions = results
        return results
```

---

### 5.4 ğŸ’¡ [ì œì•ˆì‚¬í•­] ë‹¨ê³„ 2: MD íŒŒì¼ ì‘ì„± ë° DB ì €ì¥

#### 5.4.1 ìë™ MD íŒŒì¼ ìƒì„±ê¸°

AIê°€ ìƒì„±í•œ ì¡°ê±´ì‹ ì½”ë“œë¥¼ í‘œì¤€ í…œí”Œë¦¿ì— ë§ì¶° MD íŒŒì¼ë¡œ ì‘ì„±í•©ë‹ˆë‹¤.

```python
class ConditionMDGenerator:
    """
    ì¡°ê±´ì‹ MD íŒŒì¼ ìë™ ìƒì„±ê¸°

    ì°¸ê³ : docs/Guideline/Condition_Document_Template_Guideline.md
    """

    def __init__(self, template_path="docs/Guideline/Condition_Document_Template_Guideline.md"):
        self.template = self.load_template(template_path)
        self.output_dir = "docs/Condition/"

    def generate_md_file(self, condition_data, file_name):
        """
        ì¡°ê±´ì‹ ë°ì´í„°ë¥¼ MD íŒŒì¼ë¡œ ë³€í™˜

        Args:
            condition_data: dict {
                'type': 'Tick' or 'Min',
                'buy_code': str,
                'sell_code': str,
                'buy_vars': list,  # [[start, end, step], init]
                'sell_vars': list,
                'description': str,
                'strategy_rationale': str
            }
            file_name: str (ì˜ˆ: "Condition_Tick_AI_Gen_001.md")

        Returns:
            str: ìƒì„±ëœ MD íŒŒì¼ ê²½ë¡œ
        """
        # 1. í…œí”Œë¦¿ ë³µì‚¬
        md_content = self.template.copy()

        # 2. ë©”íƒ€ë°ì´í„° ì„¹ì…˜ ì‘ì„±
        md_content += f"# {file_name.replace('.md', '')}\n\n"
        md_content += f"**ìƒì„± ë°©ë²•**: AI ìë™ ìƒì„±\n"
        md_content += f"**ìƒì„± ì¼ì‹œ**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        md_content += f"**íƒ€ì…**: {condition_data['type']}\n"
        md_content += f"**ì„¤ëª…**: {condition_data['description']}\n\n"

        # 3. BO (Buy Optimization) ì„¹ì…˜
        md_content += "## BO (Buy Optimization)\n\n"
        md_content += "```python\n"
        md_content += condition_data['buy_code']
        md_content += "\n```\n\n"

        # 4. BOR (Buy Optimization Range) ì„¹ì…˜
        md_content += "## BOR (Buy Optimization Range)\n\n"
        md_content += "```python\n"
        for i, var_range in enumerate(condition_data['buy_vars']):
            md_content += f"self.vars[{i}] = {var_range}\n"
        md_content += "```\n\n"

        # 5. SO (Sell Optimization) ì„¹ì…˜
        md_content += "## SO (Sell Optimization)\n\n"
        md_content += "```python\n"
        md_content += condition_data['sell_code']
        md_content += "\n```\n\n"

        # 6. SOR (Sell Optimization Range) ì„¹ì…˜
        md_content += "## SOR (Sell Optimization Range)\n\n"
        md_content += "```python\n"
        for i, var_range in enumerate(condition_data['sell_vars']):
            var_idx = i + len(condition_data['buy_vars'])
            md_content += f"self.vars[{var_idx}] = {var_range}\n"
        md_content += "```\n\n"

        # 7. OR (Overall Range) - ìƒìœ„ 10ê°œ ë³€ìˆ˜ë§Œ
        md_content += "## OR (Overall Range)\n\n"
        md_content += "ìƒìœ„ 10ê°œ ì£¼ìš” ë³€ìˆ˜ (ìë™ ì„ íƒë¨)\n\n"
        md_content += "```python\n"
        all_vars = condition_data['buy_vars'] + condition_data['sell_vars']
        for i, var_range in enumerate(all_vars[:10]):
            md_content += f"self.vars[{i}] = {var_range}\n"
        md_content += "```\n\n"

        # 8. GAR (Genetic Algorithm Range) ì„¹ì…˜
        md_content += "## GAR (Genetic Algorithm Range)\n\n"
        md_content += "```python\n"
        for i, var_range in enumerate(all_vars):
            # [[start, end, step], init] â†’ [[start, end], init]
            gar_format = [[var_range[0][0], var_range[0][1]], var_range[1]]
            md_content += f"self.vars[{i}] = {gar_format}\n"
        md_content += "```\n\n"

        # 9. ì „ëµ ì„¤ëª… ì„¹ì…˜
        md_content += "## ì „ëµ ì„¤ëª…\n\n"
        md_content += condition_data['strategy_rationale']
        md_content += "\n\n"

        # 10. íŒŒì¼ ì €ì¥
        target_dir = os.path.join(self.output_dir, condition_data['type'])
        os.makedirs(target_dir, exist_ok=True)

        file_path = os.path.join(target_dir, file_name)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(md_content)

        return file_path
```

#### 5.4.2 Strategy.db ìë™ INSERT ì‹œìŠ¤í…œ

ìƒì„±ëœ ì¡°ê±´ì‹ì„ STOM GUI í”„ë¡œì„¸ìŠ¤ë¥¼ ê±°ì³ strategy.dbì— ì €ì¥í•©ë‹ˆë‹¤.

```python
class StrategyDBManager:
    """
    strategy.db ìë™ ê´€ë¦¬ ì‹œìŠ¤í…œ

    Section 3.3ì—ì„œ ë¶„ì„í•œ GUI í”„ë¡œì„¸ìŠ¤ë¥¼ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ êµ¬í˜„
    """

    def __init__(self, db_path=DB_STRATEGY):
        self.db_path = db_path
        self.conn = None

    def connect(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°"""
        self.conn = sqlite3.connect(self.db_path)
        return self.conn

    def insert_strategy(self, md_file_path, strategy_name, strategy_type):
        """
        MD íŒŒì¼ì—ì„œ ì¡°ê±´ì‹ì„ ì½ì–´ strategy.dbì— INSERT

        Args:
            md_file_path: str - MD íŒŒì¼ ê²½ë¡œ
            strategy_name: str - ì „ëµ ì´ë¦„
            strategy_type: str - 'Tick' or 'Min'

        Returns:
            int: ì‚½ì…ëœ ì „ëµ ID
        """
        # 1. MD íŒŒì¼ íŒŒì‹±
        buy_code, sell_code, buy_vars, sell_vars = self.parse_md_file(md_file_path)

        # 2. GUI í”„ë¡œì„¸ìŠ¤ í•¨ìˆ˜ ì ìš© (Section 3.3.2 ì°¸ì¡°)
        # 2-1. get_fix_strategy(): ì‹¤í–‰ ì½”ë“œ ì¶”ê°€
        from ui.ui_vars_change import get_fix_strategy

        # ê°€ìƒ UI ê°ì²´ ìƒì„± (ì‹¤ì œ GUI ì—†ì´ ì²˜ë¦¬)
        class MockUI:
            def __init__(self):
                self.dict_set = {'ê±°ë˜ì†Œ': 'í‚¤ì›€'}
                self.focusWidget = lambda: self.svjb_pushButon_02
                self.svjb_pushButon_02 = object()
                self.svjs_pushButon_02 = object()

        mock_ui = MockUI()

        buy_code_fixed = get_fix_strategy(mock_ui, buy_code, 'ë§¤ìˆ˜')
        sell_code_fixed = get_fix_strategy(mock_ui, sell_code, 'ë§¤ë„')

        # 2-2. get_stgtxt_to_varstxt(): 'ë³€ìˆ˜' â†’ 'self.vars[N]' ë³€í™˜
        from ui.ui_vars_change import get_stgtxt_to_varstxt

        buy_code_final, sell_code_final = get_stgtxt_to_varstxt(
            mock_ui,
            buy_code_fixed,
            sell_code_fixed
        )

        # 3. ìµœì í™” ë²”ìœ„ ë³€í™˜
        # get_optivars_to_gavars() í˜¸ì¶œì€ í•„ìš” ì‹œ ì‚¬ìš©
        from ui.ui_vars_change import get_optivars_to_gavars

        opti_vars_text = ""
        for i, var in enumerate(buy_vars + sell_vars):
            opti_vars_text += f"self.vars[{i}] = {var}\n"

        ga_vars_text = get_optivars_to_gavars(opti_vars_text)

        # 4. strategy.db INSERT (ì¶”ì • ìŠ¤í‚¤ë§ˆ ì‚¬ìš©)
        cursor = self.conn.cursor()

        insert_query = """
        INSERT INTO strategies (
            strategy_name,
            strategy_type,
            buy_conditions,
            sell_conditions,
            optimization_vars,
            ga_vars,
            created_at,
            status
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """

        cursor.execute(insert_query, (
            strategy_name,
            strategy_type,
            buy_code_final,
            sell_code_final,
            opti_vars_text,
            ga_vars_text,
            datetime.now().strftime('%Y%m%d%H%M%S'),
            'To_be_reviewed'
        ))

        self.conn.commit()
        strategy_id = cursor.lastrowid

        return strategy_id

    def parse_md_file(self, md_file_path):
        """
        MD íŒŒì¼ì—ì„œ BO, BOR, SO, SOR ì„¹ì…˜ ì¶”ì¶œ

        Returns:
            tuple: (buy_code, sell_code, buy_vars, sell_vars)
        """
        with open(md_file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # ì •ê·œì‹ìœ¼ë¡œ ê° ì„¹ì…˜ ì¶”ì¶œ
        import re

        # BO ì„¹ì…˜
        bo_match = re.search(r'## BO.*?```python\n(.*?)```', content, re.DOTALL)
        buy_code = bo_match.group(1).strip() if bo_match else ""

        # BOR ì„¹ì…˜
        bor_match = re.search(r'## BOR.*?```python\n(.*?)```', content, re.DOTALL)
        buy_vars_text = bor_match.group(1).strip() if bor_match else ""

        # SO ì„¹ì…˜
        so_match = re.search(r'## SO.*?```python\n(.*?)```', content, re.DOTALL)
        sell_code = so_match.group(1).strip() if so_match else ""

        # SOR ì„¹ì…˜
        sor_match = re.search(r'## SOR.*?```python\n(.*?)```', content, re.DOTALL)
        sell_vars_text = sor_match.group(1).strip() if sor_match else ""

        # vars í…ìŠ¤íŠ¸ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        buy_vars = self.parse_vars_text(buy_vars_text)
        sell_vars = self.parse_vars_text(sell_vars_text)

        return buy_code, sell_code, buy_vars, sell_vars

    def parse_vars_text(self, vars_text):
        """self.vars[N] = [[start, end, step], init] í˜•ì‹ íŒŒì‹±"""
        vars_list = []
        vars_dict = {}

        # ì„ì‹œë¡œ exec ì‚¬ìš© (ì•ˆì „ì„± ê²€ì¦ í•„ìš”)
        exec(vars_text.replace('self.vars', 'vars_dict'), {'vars_dict': vars_dict})

        # ì •ë ¬í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        for i in sorted(vars_dict.keys()):
            vars_list.append(vars_dict[i])

        return vars_list

    def batch_insert(self, md_files):
        """
        ì—¬ëŸ¬ MD íŒŒì¼ì„ í•œ ë²ˆì— DBì— ì‚½ì…

        Args:
            md_files: list of dict [{
                'path': str,
                'name': str,
                'type': str
            }]

        Returns:
            list: ì‚½ì…ëœ ì „ëµ ID ë¦¬ìŠ¤íŠ¸
        """
        self.connect()
        strategy_ids = []

        for md_file in md_files:
            try:
                strategy_id = self.insert_strategy(
                    md_file['path'],
                    md_file['name'],
                    md_file['type']
                )
                strategy_ids.append(strategy_id)
                print(f"âœ… Inserted: {md_file['name']} (ID: {strategy_id})")

            except Exception as e:
                print(f"âŒ Failed: {md_file['name']} - {str(e)}")
                strategy_ids.append(None)

        self.conn.close()
        return strategy_ids
```

#### 5.4.3 í†µí•© íŒŒì´í”„ë¼ì¸

MD ìƒì„± â†’ DB ì €ì¥ì„ í•˜ë‚˜ì˜ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ í†µí•©í•©ë‹ˆë‹¤.

```python
class MDtoDBPipeline:
    """
    AI ìƒì„± ì¡°ê±´ì‹ â†’ MD íŒŒì¼ â†’ strategy.db í†µí•© íŒŒì´í”„ë¼ì¸
    """

    def __init__(self):
        self.md_generator = ConditionMDGenerator()
        self.db_manager = StrategyDBManager()

    def process_generated_conditions(self, conditions, batch_name="AI_Gen"):
        """
        AI ìƒì„± ì¡°ê±´ì‹ ë°°ì¹˜ë¥¼ MD íŒŒì¼ê³¼ DBì— ì €ì¥

        Args:
            conditions: list of dict - ConditionGenerationPipeline ì¶œë ¥
            batch_name: str - ë°°ì¹˜ ì´ë¦„ (íŒŒì¼ëª… prefix)

        Returns:
            list: ì²˜ë¦¬ ê²°ê³¼ [{
                'md_path': str,
                'db_id': int,
                'success': bool
            }]
        """
        results = []
        md_files = []

        # 1. MD íŒŒì¼ ìƒì„±
        for i, condition in enumerate(conditions):
            file_name = f"Condition_{condition['type']}_{batch_name}_{i+1:03d}.md"

            try:
                md_path = self.md_generator.generate_md_file(condition, file_name)
                md_files.append({
                    'path': md_path,
                    'name': file_name.replace('.md', ''),
                    'type': condition['type']
                })
                print(f"âœ… MD ìƒì„±: {file_name}")

            except Exception as e:
                print(f"âŒ MD ìƒì„± ì‹¤íŒ¨: {file_name} - {str(e)}")
                results.append({
                    'md_path': None,
                    'db_id': None,
                    'success': False,
                    'error': str(e)
                })
                continue

        # 2. DB ì‚½ì… (ë°°ì¹˜)
        strategy_ids = self.db_manager.batch_insert(md_files)

        # 3. ê²°ê³¼ ë³‘í•©
        for md_file, strategy_id in zip(md_files, strategy_ids):
            results.append({
                'md_path': md_file['path'],
                'db_id': strategy_id,
                'success': strategy_id is not None
            })

        return results

    def run(self, generation_pipeline_output):
        """
        ì „ì²´ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰

        Args:
            generation_pipeline_output: ConditionGenerationPipeline.run() ê²°ê³¼

        Returns:
            dict: {
                'total': int,
                'success': int,
                'failed': int,
                'results': list
            }
        """
        results = self.process_generated_conditions(
            generation_pipeline_output,
            batch_name=f"Batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )

        success_count = sum(1 for r in results if r['success'])

        return {
            'total': len(results),
            'success': success_count,
            'failed': len(results) - success_count,
            'results': results
        }
```

**ì¤‘ìš” í¬ì¸íŠ¸:**
1. **Section 3.3 GUI í”„ë¡œì„¸ìŠ¤ ë°˜ì˜**: `get_fix_strategy()`, `get_stgtxt_to_varstxt()`, `get_optivars_to_gavars()` í•¨ìˆ˜ í™œìš©
2. **í‘œì¤€ í…œí”Œë¦¿ ì¤€ìˆ˜**: `Condition_Document_Template_Guideline.md` í˜•ì‹ ì¤€ìˆ˜
3. **ìë™í™”**: ì‚¬ìš©ì ê°œì… ì—†ì´ MD ìƒì„± â†’ DB ì €ì¥ê¹Œì§€ ì™„ë£Œ
4. **ë°°ì¹˜ ì²˜ë¦¬**: ëŒ€ëŸ‰ì˜ ì¡°ê±´ì‹ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬

---

### 5.5 ğŸ’¡ [ì œì•ˆì‚¬í•­] ë‹¨ê³„ 3: ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ (Backtesting)

strategy.dbì— ì €ì¥ëœ ì¡°ê±´ì‹ì„ ìë™ìœ¼ë¡œ ë°±í…ŒìŠ¤íŒ…í•©ë‹ˆë‹¤.

#### 5.5.1 ìë™ ë°±í…ŒìŠ¤íŒ… íŒŒì´í”„ë¼ì¸

```python
class AutoBacktestingPipeline:
    def __init__(self, db_path, start_date, end_date):
        self.db_path = db_path
        self.start_date = start_date
        self.end_date = end_date
        self.results = []

    def run_single_backtest(self, condition_code, condition_id):
        """
        ë‹¨ì¼ ì¡°ê±´ì‹ ë°±í…ŒìŠ¤íŒ…
        """
        try:
            # 1. ì¡°ê±´ì‹ MD íŒŒì¼ ìƒì„±
            md_file = self.create_md_file(condition_code, condition_id)

            # 2. ë°±í…ŒìŠ¤í„° ì„¤ì •
            config = {
                'betting': 10000000,  # 1ì²œë§Œì›
                'avgtime': 30,
                'startday': self.start_date,
                'endday': self.end_date,
                'starttime': condition_code['time_range'][0],
                'endtime': condition_code['time_range'][1],
                'buystg': condition_code['buy_conditions'],
                'sellstg': condition_code['sell_conditions']
            }

            # 3. ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰
            result = run_backtest_engine(config)

            # 4. ê²°ê³¼ ë°˜í™˜
            return {
                'condition_id': condition_id,
                'success': True,
                'metrics': result,
                'timestamp': datetime.now()
            }

        except Exception as e:
            return {
                'condition_id': condition_id,
                'success': False,
                'error': str(e),
                'timestamp': datetime.now()
            }

    def run_batch(self, conditions, parallel=True, max_workers=8):
        """
        ë°°ì¹˜ ë°±í…ŒìŠ¤íŒ… (ë³‘ë ¬ ì²˜ë¦¬)
        """
        if parallel:
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = [
                    executor.submit(self.run_single_backtest, cond, i)
                    for i, cond in enumerate(conditions)
                ]
                results = [f.result() for f in futures]
        else:
            results = [
                self.run_single_backtest(cond, i)
                for i, cond in enumerate(conditions)
            ]

        self.results = results
        return results
```

#### 5.5.2 íŒŒë¼ë¯¸í„° ìµœì í™” ì „ëµ

```python
class OptimizationPipeline:
    def __init__(self, condition_code):
        self.condition_code = condition_code
        self.best_params = None

    def optimize(self, strategy="adaptive"):
        """
        ì ì‘í˜• ìµœì í™” ì „ëµ
        """
        if strategy == "adaptive":
            # 1ë‹¨ê³„: ë¹ ë¥¸ íƒìƒ‰ (Grid Search, ìƒìœ„ 10ê°œ ë³€ìˆ˜)
            grid_result = self.grid_search_quick()

            # 2ë‹¨ê³„: ë² ì´ì§€ì•ˆ ìµœì í™” (Optuna, ì „ì²´ ë³€ìˆ˜)
            if grid_result['profit_rate'] > 0:
                optuna_result = self.bayesian_optimization(
                    initial_params=grid_result['params']
                )
            else:
                optuna_result = grid_result

            # 3ë‹¨ê³„: ìœ ì „ ì•Œê³ ë¦¬ì¦˜ (GA, ë¯¸ì„¸ ì¡°ì •)
            if optuna_result['profit_rate'] > 5:
                ga_result = self.genetic_algorithm(
                    initial_params=optuna_result['params']
                )
                return ga_result
            else:
                return optuna_result

        elif strategy == "quick":
            # ë¹ ë¥¸ íƒìƒ‰ë§Œ
            return self.grid_search_quick()

        elif strategy == "thorough":
            # ì „ì²´ ê·¸ë¦¬ë“œ ì„œì¹˜
            return self.grid_search_full()

    def grid_search_quick(self):
        """
        ìƒìœ„ 10ê°œ ë³€ìˆ˜ë§Œ ë¹ ë¥¸ ê·¸ë¦¬ë“œ ì„œì¹˜
        """
        # OR (Overall Range) ì„¹ì…˜ ë³€ìˆ˜ ì‚¬ìš©
        top_vars = self.condition_code['OR'][:10]

        # ê° ë³€ìˆ˜ë‹¹ 5ê°œ ê°’ë§Œ (ì´ 5^10 = 9,765,625 â†’ ì‹¤ìš©ì ìœ¼ë¡œ 1000ê°œ ìƒ˜í”Œë§)
        param_grid = {
            var['name']: np.linspace(var['range'][0], var['range'][1], 5)
            for var in top_vars
        }

        # ëœë¤ ìƒ˜í”Œë§
        sampled_params = random_sample(param_grid, n=1000)

        # ë°±í…ŒìŠ¤íŒ…
        results = [self.evaluate(params) for params in sampled_params]

        # ìµœì  ê²°ê³¼
        best_idx = np.argmax([r['profit_rate'] for r in results])
        return results[best_idx]

    def bayesian_optimization(self, initial_params=None, n_trials=200):
        """
        Optuna ë² ì´ì§€ì•ˆ ìµœì í™”
        """
        import optuna

        def objective(trial):
            params = {}
            for var in self.condition_code['BOR'] + self.condition_code['SOR']:
                params[var['name']] = trial.suggest_float(
                    var['name'],
                    var['range'][0],
                    var['range'][1]
                )

            result = self.evaluate(params)
            return result['profit_rate']

        study = optuna.create_study(direction='maximize')

        # ì´ˆê¸°ê°’ ì„¤ì •
        if initial_params:
            study.enqueue_trial(initial_params)

        study.optimize(objective, n_trials=n_trials)

        return {
            'params': study.best_params,
            'profit_rate': study.best_value
        }

    def genetic_algorithm(self, initial_params=None, generations=50):
        """
        ìœ ì „ ì•Œê³ ë¦¬ì¦˜ ë¯¸ì„¸ ì¡°ì •
        """
        # ... (ì•ì„œ ì •ì˜í•œ GA ì½”ë“œ)
        pass
```

### 5.6 ğŸ’¡ [ì œì•ˆì‚¬í•­] ë‹¨ê³„ 4: OPTISTD ë¶„ì„ ë° ê²°ê³¼ ê¸°ë¡ (Analysis & Logging)

ë°±í…ŒìŠ¤íŒ… ë° ìµœì í™” ê²°ê³¼ë¥¼ OPTISTD 14ê°œ ì§€í‘œë¡œ ë¶„ì„í•˜ê³  ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë¡í•©ë‹ˆë‹¤.

#### 5.6.1 ê²°ê³¼ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- ì¡°ê±´ì‹ í…Œì´ë¸”
CREATE TABLE conditions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    strategy_type TEXT,
    time_range TEXT,
    target_stocks TEXT,
    buy_conditions TEXT,
    sell_conditions TEXT,
    variables TEXT,  -- JSON í˜•ì‹
    generation_method TEXT,  -- llm, gp, template
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ í…Œì´ë¸”
CREATE TABLE backtest_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    condition_id INTEGER,
    start_date TEXT,
    end_date TEXT,

    -- 14ê°€ì§€ OPTISTD ì§€í‘œ
    TG REAL,  -- ìˆ˜ìµê¸ˆí•©ê³„
    TP REAL,  -- ìˆ˜ìµë¥ í•©ê³„
    TPI REAL,  -- ë§¤ë§¤ì„±ëŠ¥ì§€ìˆ˜
    CAGR REAL,  -- ì—°ê°„ì˜ˆìƒìˆ˜ìµë¥ 
    GM REAL,  -- Gain/MDD
    G2M REAL,  -- GainÂ²/MDD/Betting
    GAM REAL,  -- GainÃ—AvgProfit/MDD
    GWM REAL,  -- GainÃ—WinRate/MDD
    PM REAL,  -- Profit/MDD
    P2M REAL,  -- ProfitÂ²/MDD/Betting
    PAM REAL,  -- ProfitÃ—AvgProfit/MDD
    PWM REAL,  -- ProfitÃ—WinRate/MDD
    WM REAL,  -- WinRate/MDD
    TM REAL,  -- TradeCount/MDD

    -- ê¸°íƒ€ ì§€í‘œ
    win_rate REAL,
    trade_count INTEGER,
    avg_profit_rate REAL,
    avg_loss_rate REAL,
    mdd REAL,
    max_profit_rate REAL,

    -- ë©”íƒ€ ì •ë³´
    optimization_method TEXT,  -- grid, optuna, ga
    optimization_time REAL,  -- ì´ˆ ë‹¨ìœ„
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (condition_id) REFERENCES conditions(id)
);

-- ìµœì í™” íˆìŠ¤í† ë¦¬ í…Œì´ë¸”
CREATE TABLE optimization_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    condition_id INTEGER,
    iteration INTEGER,
    params TEXT,  -- JSON í˜•ì‹
    profit_rate REAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (condition_id) REFERENCES conditions(id)
);

-- ì‹¤íŒ¨ ë¡œê·¸ í…Œì´ë¸”
CREATE TABLE failure_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    condition_id INTEGER,
    error_type TEXT,  -- syntax, runtime, timeout
    error_message TEXT,
    stack_trace TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (condition_id) REFERENCES conditions(id)
);

-- ì„±ê³¼ ìˆœìœ„ ë·°
CREATE VIEW performance_ranking AS
SELECT
    c.id,
    c.name,
    c.strategy_type,
    b.TP AS profit_rate,
    b.win_rate,
    b.trade_count,
    b.mdd,
    b.CAGR,
    RANK() OVER (PARTITION BY c.strategy_type ORDER BY b.TP DESC) AS rank
FROM conditions c
JOIN backtest_results b ON c.id = b.condition_id
WHERE b.created_at >= datetime('now', '-30 days');
```

#### 5.6.2 ìë™ ë¡œê¹… ì‹œìŠ¤í…œ

```python
class ResultLogger:
    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)

    def log_condition(self, condition_code, generation_method):
        """
        ì¡°ê±´ì‹ ì €ì¥
        """
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO conditions (
                name, description, strategy_type, time_range, target_stocks,
                buy_conditions, sell_conditions, variables, generation_method
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            condition_code['name'],
            condition_code['description'],
            condition_code['strategy_type'],
            json.dumps(condition_code['time_range']),
            condition_code['target_stocks'],
            condition_code['buy_conditions'],
            condition_code['sell_conditions'],
            json.dumps(condition_code['variables']),
            generation_method
        ))
        self.conn.commit()
        return cursor.lastrowid

    def log_backtest_result(self, condition_id, result):
        """
        ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ ì €ì¥
        """
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO backtest_results (
                condition_id, start_date, end_date,
                TG, TP, TPI, CAGR, GM, G2M, GAM, GWM, PM, P2M, PAM, PWM, WM, TM,
                win_rate, trade_count, avg_profit_rate, avg_loss_rate, mdd, max_profit_rate,
                optimization_method, optimization_time
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            condition_id,
            result['start_date'],
            result['end_date'],
            result['TG'], result['TP'], result['TPI'], result['CAGR'],
            result['GM'], result['G2M'], result['GAM'], result['GWM'],
            result['PM'], result['P2M'], result['PAM'], result['PWM'], result['WM'], result['TM'],
            result['win_rate'], result['trade_count'],
            result['avg_profit_rate'], result['avg_loss_rate'], result['mdd'], result['max_profit_rate'],
            result['optimization_method'], result['optimization_time']
        ))
        self.conn.commit()

    def log_optimization_step(self, condition_id, iteration, params, profit_rate):
        """
        ìµœì í™” ê° ë‹¨ê³„ ì €ì¥
        """
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO optimization_history (condition_id, iteration, params, profit_rate)
            VALUES (?, ?, ?, ?)
        """, (
            condition_id,
            iteration,
            json.dumps(params),
            profit_rate
        ))
        self.conn.commit()

    def log_failure(self, condition_id, error_type, error_message, stack_trace):
        """
        ì‹¤íŒ¨ ë¡œê·¸ ì €ì¥
        """
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO failure_logs (condition_id, error_type, error_message, stack_trace)
            VALUES (?, ?, ?, ?)
        """, (
            condition_id,
            error_type,
            error_message,
            stack_trace
        ))
        self.conn.commit()
```

### 5.7 ğŸ’¡ [ì œì•ˆì‚¬í•­] ë‹¨ê³„ 5: í”¼ë“œë°± ë£¨í”„ (Feedback Loop)

OPTISTD ë¶„ì„ ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ AIì—ê²Œ í”¼ë“œë°±ì„ ì œê³µí•˜ì—¬ ë‹¤ìŒ ìƒì„± ì‚¬ì´í´ì„ ê°œì„ í•©ë‹ˆë‹¤.

#### 5.7.1 ì„±ê³¼ ë¶„ì„ ë° íŒ¨í„´ ì¸ì‹

```python
class PerformanceAnalyzer:
    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)

    def analyze_success_patterns(self, min_profit_rate=5, min_win_rate=60):
        """
        ì„±ê³µ íŒ¨í„´ ë¶„ì„
        """
        query = """
        SELECT
            c.strategy_type,
            c.variables,
            b.TP AS profit_rate,
            b.win_rate,
            b.trade_count,
            b.mdd
        FROM conditions c
        JOIN backtest_results b ON c.id = b.condition_id
        WHERE b.TP >= ? AND b.win_rate >= ?
        ORDER BY b.TP DESC
        """

        df = pd.read_sql_query(query, self.conn, params=(min_profit_rate, min_win_rate))

        # ë³€ìˆ˜ íŒ¨í„´ ì¶”ì¶œ
        variable_patterns = []
        for _, row in df.iterrows():
            variables = json.loads(row['variables'])
            for var_name, var_value in variables.items():
                variable_patterns.append({
                    'strategy_type': row['strategy_type'],
                    'variable': var_name,
                    'value': var_value,
                    'profit_rate': row['profit_rate']
                })

        df_patterns = pd.DataFrame(variable_patterns)

        # ì „ëµë³„ ì„±ê³µ ë³€ìˆ˜ ë¶„ì„
        success_vars = df_patterns.groupby(['strategy_type', 'variable']).agg({
            'value': ['mean', 'std', 'min', 'max'],
            'profit_rate': 'mean'
        }).reset_index()

        return success_vars

    def analyze_failure_patterns(self):
        """
        ì‹¤íŒ¨ íŒ¨í„´ ë¶„ì„
        """
        query = """
        SELECT
            error_type,
            error_message,
            COUNT(*) AS count
        FROM failure_logs
        GROUP BY error_type, error_message
        ORDER BY count DESC
        LIMIT 20
        """

        df_failures = pd.read_sql_query(query, self.conn)
        return df_failures

    def find_correlations(self):
        """
        ë³€ìˆ˜ ê°„ ìƒê´€ê´€ê³„ ë¶„ì„
        """
        query = """
        SELECT
            c.variables,
            b.TP AS profit_rate
        FROM conditions c
        JOIN backtest_results b ON c.id = b.condition_id
        """

        df = pd.read_sql_query(query, self.conn)

        # ë³€ìˆ˜ ì¶”ì¶œ ë° ìƒê´€ê´€ê³„ ê³„ì‚°
        var_data = []
        for _, row in df.iterrows():
            variables = json.loads(row['variables'])
            variables['profit_rate'] = row['profit_rate']
            var_data.append(variables)

        df_vars = pd.DataFrame(var_data)
        correlation_matrix = df_vars.corr()['profit_rate'].sort_values(ascending=False)

        return correlation_matrix
```

#### 5.7.2 LLM í”¼ë“œë°± ìƒì„±

```python
class FeedbackLoop:
    def __init__(self, logger, analyzer):
        self.logger = logger
        self.analyzer = analyzer

    def generate_feedback_prompt(self, iteration):
        """
        í”¼ë“œë°± í”„ë¡¬í”„íŠ¸ ìƒì„±
        """
        # ì„±ê³µ íŒ¨í„´ ë¶„ì„
        success_patterns = self.analyzer.analyze_success_patterns()

        # ì‹¤íŒ¨ íŒ¨í„´ ë¶„ì„
        failure_patterns = self.analyzer.analyze_failure_patterns()

        # ìƒê´€ê´€ê³„ ë¶„ì„
        correlations = self.analyzer.find_correlations()

        feedback_prompt = f"""
ì´ì „ ì‹¤í—˜ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì¡°ê±´ì‹ì„ ê°œì„ í•´ì£¼ì„¸ìš”.

# ë°˜ë³µ íšŸìˆ˜: {iteration}

# ì„±ê³µ íŒ¨í„´ (ìˆ˜ìµë¥  5% ì´ìƒ, ìŠ¹ë¥  60% ì´ìƒ)
{success_patterns.to_markdown()}

ì„±ê³µí•œ ì „ëµì˜ ê³µí†µì :
- ì²´ê²°ê°•ë„ ë²”ìœ„: í‰ê·  {success_patterns[success_patterns['variable']=='ì²´ê²°ê°•ë„']['value']['mean'].values[0]:.1f}
- ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ ìµœì†Œê°’: í‰ê·  {success_patterns[success_patterns['variable']=='ì´ˆë‹¹ê±°ë˜ëŒ€ê¸ˆ']['value']['mean'].values[0]:.1f}ì–µ
- ë“±ë½ìœ¨ ìƒí•œ: í‰ê·  {success_patterns[success_patterns['variable']=='ë“±ë½ìœ¨_ìƒí•œ']['value']['mean'].values[0]:.1f}%

# ì‹¤íŒ¨ íŒ¨í„´ (ìƒìœ„ 10ê°œ)
{failure_patterns.head(10).to_markdown()}

ì£¼ìš” ì‹¤íŒ¨ ì›ì¸:
1. {failure_patterns.iloc[0]['error_message']} ({failure_patterns.iloc[0]['count']}íšŒ)
2. {failure_patterns.iloc[1]['error_message']} ({failure_patterns.iloc[1]['count']}íšŒ)

# ë³€ìˆ˜ ìƒê´€ê´€ê³„ (ìˆ˜ìµë¥ ê³¼ì˜ ìƒê´€ê³„ìˆ˜)
{correlations.head(10).to_markdown()}

ê°€ì¥ ì˜í–¥ë ¥ ìˆëŠ” ë³€ìˆ˜:
1. {correlations.index[1]}: {correlations.values[1]:.3f}
2. {correlations.index[2]}: {correlations.values[2]:.3f}
3. {correlations.index[3]}: {correlations.values[3]:.3f}

# ê°œì„  ì§€ì¹¨
1. ì„±ê³µ íŒ¨í„´ì˜ ë³€ìˆ˜ ë²”ìœ„ë¥¼ ë” ì ê·¹ì ìœ¼ë¡œ í™œìš©í•˜ì„¸ìš”
2. ì‹¤íŒ¨ ì›ì¸ì„ íšŒí”¼í•˜ë„ë¡ ì¡°ê±´ì‹ì„ ìˆ˜ì •í•˜ì„¸ìš”
3. ìƒê´€ê´€ê³„ê°€ ë†’ì€ ë³€ìˆ˜ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì‚¬ìš©í•˜ì„¸ìš”
4. ì´ì „ ë°˜ë³µì—ì„œ íš¨ê³¼ê°€ ì—†ì—ˆë˜ ë³€ìˆ˜ëŠ” ì œê±°í•˜ê±°ë‚˜ ë²”ìœ„ë¥¼ ì¡°ì •í•˜ì„¸ìš”
        """

        return feedback_prompt

    def improve_conditions(self, current_best, iteration):
        """
        ì¡°ê±´ì‹ ê°œì„ 
        """
        feedback_prompt = self.generate_feedback_prompt(iteration)

        # LLM í˜¸ì¶œ
        improved_code = call_llm_api(
            system_prompt=SYSTEM_PROMPT,
            user_prompt=feedback_prompt,
            few_shot_examples=[current_best]  # í˜„ì¬ ìµœê³  ì„±ê³¼ ì¡°ê±´ì‹
        )

        return improved_code
```

#### 5.7.3 ìë™ ìˆœí™˜ ê²°ì •

```python
class EvolutionaryLoop:
    def __init__(self, generator, tester, logger, feedback):
        self.generator = generator
        self.tester = tester
        self.logger = logger
        self.feedback = feedback

        self.best_conditions = []
        self.iteration = 0

    def run(self, max_iterations=100, target_profit_rate=20, early_stop_patience=10):
        """
        ìë™ ì§„í™” ë£¨í”„ ì‹¤í–‰
        """
        no_improvement_count = 0

        for self.iteration in range(max_iterations):
            print(f"\n{'='*60}")
            print(f"ë°˜ë³µ {self.iteration + 1}/{max_iterations}")
            print(f"{'='*60}")

            # 1. ì¡°ê±´ì‹ ìƒì„±
            if self.iteration == 0:
                # ì²« ë°˜ë³µ: ë‹¤ì–‘í•œ ë°©ë²•ìœ¼ë¡œ ìƒì„±
                conditions = self.generator.run(batch_size=100)
            else:
                # í›„ì† ë°˜ë³µ: í”¼ë“œë°± ê¸°ë°˜ ê°œì„ 
                conditions = []
                for best in self.best_conditions[:10]:
                    improved = self.feedback.improve_conditions(best, self.iteration)
                    if improved:
                        conditions.append(improved)

                # ìƒˆë¡œìš´ íƒìƒ‰ë„ ì¶”ê°€ (exploitation vs exploration)
                new_conditions = self.generator.run(batch_size=50)
                conditions.extend(new_conditions)

            print(f"ìƒì„±ëœ ì¡°ê±´ì‹: {len(conditions)}ê°œ")

            # 2. ë°±í…ŒìŠ¤íŒ…
            results = self.tester.run_batch(conditions, parallel=True)
            successful_results = [r for r in results if r['success']]
            print(f"ì„±ê³µí•œ ë°±í…ŒìŠ¤íŒ…: {len(successful_results)}/{len(results)}ê°œ")

            # 3. ê²°ê³¼ ê¸°ë¡
            for i, result in enumerate(results):
                condition_id = self.logger.log_condition(
                    conditions[i],
                    generation_method='evolutionary'
                )

                if result['success']:
                    self.logger.log_backtest_result(condition_id, result['metrics'])
                else:
                    self.logger.log_failure(
                        condition_id,
                        'runtime',
                        result['error'],
                        ''
                    )

            # 4. ìµœê³  ì„±ê³¼ ì—…ë°ì´íŠ¸
            if successful_results:
                best_result = max(successful_results, key=lambda x: x['metrics']['TP'])
                print(f"ìµœê³  ìˆ˜ìµë¥ : {best_result['metrics']['TP']:.2f}%")
                print(f"ìŠ¹ë¥ : {best_result['metrics']['win_rate']:.2f}%")
                print(f"ê±°ë˜ íšŸìˆ˜: {best_result['metrics']['trade_count']}íšŒ")

                # ìµœê³  ì„±ê³¼ ì¡°ê±´ì‹ ì €ì¥
                if not self.best_conditions or best_result['metrics']['TP'] > self.best_conditions[0]['metrics']['TP']:
                    self.best_conditions.insert(0, {
                        'code': conditions[best_result['condition_id']],
                        'metrics': best_result['metrics']
                    })
                    self.best_conditions = self.best_conditions[:20]  # ìƒìœ„ 20ê°œ ìœ ì§€
                    no_improvement_count = 0
                else:
                    no_improvement_count += 1

                # ëª©í‘œ ë‹¬ì„± í™•ì¸
                if best_result['metrics']['TP'] >= target_profit_rate:
                    print(f"\nëª©í‘œ ìˆ˜ìµë¥  {target_profit_rate}% ë‹¬ì„±!")
                    break
            else:
                no_improvement_count += 1

            # Early stopping
            if no_improvement_count >= early_stop_patience:
                print(f"\n{early_stop_patience}íšŒ ì—°ì† ê°œì„  ì—†ìŒ. ì¡°ê¸° ì¢…ë£Œ.")
                break

        print(f"\n{'='*60}")
        print("ì§„í™” ë£¨í”„ ì™„ë£Œ")
        print(f"ìµœì¢… ìµœê³  ìˆ˜ìµë¥ : {self.best_conditions[0]['metrics']['TP']:.2f}%")
        print(f"{'='*60}")

        return self.best_conditions
```

---

## 6. ğŸ’¡ [ì œì•ˆì‚¬í•­] ì‹¤ì œ êµ¬í˜„ ë°©ì•ˆ

### 6.1 ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

#### 6.1.1 CLI ê¸°ë°˜ ìë™í™” íŒŒì´í”„ë¼ì¸

```bash
# í”„ë¡œì íŠ¸ êµ¬ì¡°
stom_automation/
â”œâ”€â”€ cli.py                    # ë©”ì¸ CLI ì§„ì…ì 
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ config.yaml          # ì‹œìŠ¤í…œ ì„¤ì •
â”‚   â””â”€â”€ strategies.yaml      # ì „ëµ ì •ì˜
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ generation/
â”‚   â”‚   â”œâ”€â”€ llm_generator.py
â”‚   â”‚   â”œâ”€â”€ gp_generator.py
â”‚   â”‚   â””â”€â”€ template_generator.py
â”‚   â”œâ”€â”€ testing/
â”‚   â”‚   â”œâ”€â”€ backtester.py
â”‚   â”‚   â””â”€â”€ optimizer.py
â”‚   â”œâ”€â”€ logging/
â”‚   â”‚   â”œâ”€â”€ logger.py
â”‚   â”‚   â””â”€â”€ database.py
â”‚   â”œâ”€â”€ feedback/
â”‚   â”‚   â”œâ”€â”€ analyzer.py
â”‚   â”‚   â””â”€â”€ improver.py
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ validators.py
â”‚       â””â”€â”€ helpers.py
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ conditions.db        # ì¡°ê±´ì‹ DB
â”‚   â”œâ”€â”€ results.db           # ê²°ê³¼ DB
â”‚   â””â”€â”€ templates/           # í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬
â”œâ”€â”€ logs/                    # ì‹¤í–‰ ë¡œê·¸
â””â”€â”€ outputs/                 # ìƒì„±ëœ ì¡°ê±´ì‹ íŒŒì¼
    â”œâ”€â”€ generated/
    â”œâ”€â”€ tested/
    â””â”€â”€ optimized/
```

#### 6.1.2 CLI ëª…ë ¹ì–´ ì²´ê³„

```bash
# ì¡°ê±´ì‹ ìƒì„±
stom-auto generate \
    --strategy "ê¸‰ë“±ì£¼_í¬ì°©" \
    --method llm \
    --count 50 \
    --output ./outputs/generated/

# ë°±í…ŒìŠ¤íŒ…
stom-auto backtest \
    --input ./outputs/generated/*.md \
    --start-date 20230101 \
    --end-date 20231231 \
    --parallel 8 \
    --output ./outputs/tested/

# ìµœì í™”
stom-auto optimize \
    --input ./outputs/tested/best_10.md \
    --method optuna \
    --trials 200 \
    --output ./outputs/optimized/

# ì§„í™” ë£¨í”„ ì‹¤í–‰
stom-auto evolve \
    --strategy "ê¸‰ë“±ì£¼_í¬ì°©" \
    --iterations 100 \
    --batch-size 50 \
    --target-profit 20 \
    --output ./outputs/evolved/

# ê²°ê³¼ ë¶„ì„
stom-auto analyze \
    --db ./data/results.db \
    --strategy "ê¸‰ë“±ì£¼_í¬ì°©" \
    --min-profit 5 \
    --report ./outputs/analysis_report.html

# ëŒ€ì‹œë³´ë“œ ì‹¤í–‰
stom-auto dashboard \
    --db ./data/results.db \
    --port 8050
```

### 6.2 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„

#### 6.2.1 í™•ì¥ëœ ìŠ¤í‚¤ë§ˆ

```sql
-- (ì•ì„œ ì •ì˜í•œ í…Œì´ë¸”ì— ì¶”ê°€)

-- ì „ëµ í…œí”Œë¦¿ í…Œì´ë¸”
CREATE TABLE strategy_templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    time_range TEXT,
    target_stocks TEXT,
    buy_template TEXT,
    sell_template TEXT,
    var_ranges TEXT,  -- JSON í˜•ì‹
    success_rate REAL DEFAULT 0,
    avg_profit_rate REAL DEFAULT 0,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ë³€ìˆ˜ ì¤‘ìš”ë„ í…Œì´ë¸”
CREATE TABLE variable_importance (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    strategy_type TEXT,
    variable_name TEXT,
    importance_score REAL,
    correlation_with_profit REAL,
    usage_count INTEGER,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(strategy_type, variable_name)
);

-- í”¼ë“œë°± íˆìŠ¤í† ë¦¬ í…Œì´ë¸”
CREATE TABLE feedback_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    iteration INTEGER,
    feedback_text TEXT,
    improvement_direction TEXT,
    applied_changes TEXT,  -- JSON í˜•ì‹
    result_profit_rate REAL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì‹¤í—˜ ì„¸ì…˜ í…Œì´ë¸”
CREATE TABLE experiment_sessions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_name TEXT,
    strategy_type TEXT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    total_conditions_generated INTEGER,
    successful_backtests INTEGER,
    best_profit_rate REAL,
    best_condition_id INTEGER,
    status TEXT,  -- running, completed, failed
    FOREIGN KEY (best_condition_id) REFERENCES conditions(id)
);
```

### 6.3 ë‹¨ê³„ë³„ êµ¬í˜„ ê³„íš

#### Phase 1: ì¡°ê±´ì‹ ìƒì„± ì—”ì§„ (1-2ê°œì›”)

**Week 1-2: ê¸°ë³¸ ì¸í”„ë¼ êµ¬ì¶•**
- [ ] í”„ë¡œì íŠ¸ êµ¬ì¡° ì„¤ì •
- [ ] CLI í”„ë ˆì„ì›Œí¬ êµ¬ì¶• (Click ì‚¬ìš©)
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ êµ¬í˜„
- [ ] ì„¤ì • íŒŒì¼ ê´€ë¦¬ ì‹œìŠ¤í…œ

**Week 3-4: LLM ìƒì„±ê¸° êµ¬í˜„**
- [ ] OpenAI/Anthropic API í†µí•©
- [ ] í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ë° í…œí”Œë¦¿
- [ ] Few-shot learning ë°ì´í„° ì¤€ë¹„
- [ ] ì‘ë‹µ ê²€ì¦ ë° íŒŒì‹±

**Week 5-6: Genetic Programming êµ¬í˜„**
- [ ] DEAP ë¼ì´ë¸ŒëŸ¬ë¦¬ í†µí•©
- [ ] Primitive Set ì •ì˜ (826/752 ë³€ìˆ˜)
- [ ] Fitness í‰ê°€ í•¨ìˆ˜
- [ ] ì§„í™” ì•Œê³ ë¦¬ì¦˜ íŒŒë¼ë¯¸í„° íŠœë‹

**Week 7-8: í…œí”Œë¦¿ ì‹œìŠ¤í…œ êµ¬í˜„**
- [ ] í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬ì¶• (20-30ê°œ)
- [ ] íŒŒë¼ë¯¸í„° ì¡°í•© ìƒì„±ê¸°
- [ ] í…œí”Œë¦¿ ê²€ì¦ ì‹œìŠ¤í…œ
- [ ] í†µí•© í…ŒìŠ¤íŠ¸

#### Phase 2: ìë™ ë°±í…ŒìŠ¤íŒ… íŒŒì´í”„ë¼ì¸ (1ê°œì›”)

**Week 9-10: ë°±í…ŒìŠ¤í„° í†µí•©**
- [ ] ê¸°ì¡´ ë°±í…ŒìŠ¤í„° ë˜í•‘
- [ ] MD íŒŒì¼ ìë™ ìƒì„±
- [ ] ë°±í…ŒìŠ¤íŠ¸ í ê´€ë¦¬
- [ ] ë³‘ë ¬ ì²˜ë¦¬ êµ¬í˜„ (ThreadPoolExecutor)

**Week 11-12: ìµœì í™” íŒŒì´í”„ë¼ì¸**
- [ ] Grid Search êµ¬í˜„
- [ ] Optuna í†µí•©
- [ ] GA í†µí•©
- [ ] ì ì‘í˜• ìµœì í™” ì „ëµ

#### Phase 3: í”¼ë“œë°± ë£¨í”„ êµ¬í˜„ (2ê°œì›”)

**Week 13-14: ê²°ê³¼ ë¡œê¹… ì‹œìŠ¤í…œ**
- [ ] ë¡œê±° í´ë˜ìŠ¤ êµ¬í˜„
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ìë™í™”
- [ ] ì‹¤íŒ¨ ë¡œê·¸ ê´€ë¦¬
- [ ] ìµœì í™” íˆìŠ¤í† ë¦¬ ì¶”ì 

**Week 15-16: ì„±ê³¼ ë¶„ì„ ì—”ì§„**
- [ ] ì„±ê³µ/ì‹¤íŒ¨ íŒ¨í„´ ë¶„ì„
- [ ] ë³€ìˆ˜ ìƒê´€ê´€ê³„ ë¶„ì„
- [ ] Feature Importance (XGBoost)
- [ ] SHAP ë¶„ì„ í†µí•©

**Week 17-18: í”¼ë“œë°± ìƒì„± ì‹œìŠ¤í…œ**
- [ ] í”¼ë“œë°± í”„ë¡¬í”„íŠ¸ ìƒì„±ê¸°
- [ ] LLM í”¼ë“œë°± ë£¨í”„
- [ ] ì¡°ê±´ì‹ ê°œì„  ë©”ì»¤ë‹ˆì¦˜
- [ ] ìë™ ì§„í™” ë£¨í”„

**Week 19-20: ëŒ€ì‹œë³´ë“œ êµ¬ì¶•**
- [ ] Plotly Dash ëŒ€ì‹œë³´ë“œ
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- [ ] ì„±ê³¼ ì‹œê°í™”
- [ ] ë¹„êµ ë¶„ì„ ë„êµ¬

#### Phase 4: ëŒ€ê·œëª¨ ì‹¤í—˜ ë° ìµœì í™” (ì§€ì†ì )

**Week 21+: ëŒ€ê·œëª¨ ì‹¤í—˜**
- [ ] 1000ê°œ ì¡°ê±´ì‹ ìƒì„± ì‹¤í—˜
- [ ] ì„±ê³¼ í‰ê°€ ë° ë¶„ì„
- [ ] ì‹œìŠ¤í…œ íŠœë‹ ë° ìµœì í™”
- [ ] ì‹¤ì „ ë°°í¬ ì¤€ë¹„

### 6.4 ê¸°ìˆ  ìŠ¤íƒ

#### 6.4.1 í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬

```yaml
# requirements.txt
python>=3.9

# LLM í†µí•©
openai>=1.0.0
anthropic>=0.5.0

# Genetic Programming
deap>=1.3.3
numpy>=1.24.0

# ìµœì í™”
optuna>=3.0.0
scikit-optimize>=0.9.0

# Feature Importance
xgboost>=1.7.0
shap>=0.42.0
scikit-learn>=1.3.0

# ë°ì´í„° ì²˜ë¦¬
pandas>=2.0.0
pyarrow>=12.0.0

# CLI
click>=8.1.0
rich>=13.0.0
tqdm>=4.65.0

# ë°ì´í„°ë² ì´ìŠ¤
sqlalchemy>=2.0.0
alembic>=1.11.0

# ëŒ€ì‹œë³´ë“œ
plotly>=5.15.0
dash>=2.11.0

# í…ŒìŠ¤íŒ…
pytest>=7.4.0
pytest-cov>=4.1.0

# ê¸°íƒ€
pyyaml>=6.0
python-dotenv>=1.0.0
loguru>=0.7.0
```

#### 6.4.2 ì„¤ì • íŒŒì¼ ì˜ˆì œ

```yaml
# config/config.yaml
system:
  db_path: ./data/conditions.db
  log_level: INFO
  max_workers: 8

generation:
  llm:
    provider: anthropic  # openai, anthropic
    model: claude-3-5-sonnet-20241022
    temperature: 0.3
    max_tokens: 4096

  gp:
    population_size: 300
    generations: 40
    cxpb: 0.5
    mutpb: 0.2

  template:
    library_path: ./data/templates/
    default_method: sobol

backtesting:
  start_date: 20230101
  end_date: 20231231
  betting: 10000000
  parallel: true
  max_workers: 8

optimization:
  grid:
    max_combinations: 1000

  optuna:
    n_trials: 200
    sampler: TPESampler

  ga:
    generations: 50
    population_size: 100

feedback:
  min_success_profit_rate: 5.0
  min_success_win_rate: 60.0
  analysis_window_days: 30

evolution:
  max_iterations: 100
  batch_size: 50
  target_profit_rate: 20.0
  early_stop_patience: 10
```

### 6.5 ê¸°ëŒ€ íš¨ê³¼ ë¶„ì„

#### 6.5.1 ì •ëŸ‰ì  íš¨ê³¼

| ì§€í‘œ | í˜„ì¬ | 1ë…„ í›„ ëª©í‘œ | ê°œì„ ë¥  |
|------|------|-------------|--------|
| ì¡°ê±´ì‹ ê°œë°œ ì‹œê°„ | 2-5ì¼/ê°œ | 10-30ë¶„/ê°œ | 96% ë‹¨ì¶• |
| ì—°ê°„ ìƒì„± ì¡°ê±´ì‹ | 50ê°œ | 5,000ê°œ | 100ë°° ì¦ê°€ |
| ë°±í…ŒìŠ¤íŒ… ì²˜ë¦¬ëŸ‰ | 10ê°œ/ì¼ | 1,000ê°œ/ì¼ | 100ë°° ì¦ê°€ |
| ìµœì í™” ì‹œê°„ | ìˆ˜ì¼ | ìˆ˜ì‹œê°„ | 95% ë‹¨ì¶• |
| í‰ê·  ìˆ˜ìµë¥  | ê¸°ì¤€ì„  | +20-30% | ìˆ˜ìµë¥  í–¥ìƒ |
| ìŠ¹ë¥  | ê¸°ì¤€ì„  | +5-10%p | ì•ˆì •ì„± í–¥ìƒ |

#### 6.5.2 ì •ì„±ì  íš¨ê³¼

**ì „ëµ ë‹¤ì–‘ì„±**:
- ë‹¤ì–‘í•œ ì‹œì¥ ì¡°ê±´ì— ëŒ€ì‘ ê°€ëŠ¥í•œ ì¡°ê±´ì‹ í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì¶•
- í‹±/ë¶„ë´‰, ì‹œê°„ëŒ€ë³„, ì¢…ëª©êµ°ë³„ íŠ¹í™” ì „ëµ í™•ë³´

**ì§€ì‹ ì¶•ì **:
- ì„±ê³µ/ì‹¤íŒ¨ íŒ¨í„´ì˜ ì²´ê³„ì  ê¸°ë¡
- ë³€ìˆ˜ ì¤‘ìš”ë„ ë° ìƒê´€ê´€ê³„ ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¶•
- ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ëŒ€

**ë¦¬ìŠ¤í¬ ê´€ë¦¬**:
- ëŒ€ê·œëª¨ ë°±í…ŒìŠ¤íŒ…ì„ í†µí•œ ê³¼ì í•© ë°©ì§€
- êµì°¨ê²€ì¦ ë° Walk-Forward ë¶„ì„
- ì‹¤ì „ ë°°í¬ ì „ ì² ì €í•œ ê²€ì¦

**í™•ì¥ì„±**:
- ìƒˆë¡œìš´ ì‹œì¥ (ë¯¸êµ­ ì£¼ì‹, ì„ ë¬¼ ë“±) ì ìš© ìš©ì´
- ì¡°ê±´ì‹ ìƒì„± ë°©ë²•ë¡ ì˜ ì§€ì†ì  ê°œì„ 
- ì»¤ë®¤ë‹ˆí‹° ê¸°ì—¬ ë° í˜‘ì—… ê°€ëŠ¥

---

## 7. ğŸ’¡ [ì œì•ˆì‚¬í•­] ë¦¬ìŠ¤í¬ ë° ì™„í™” ì „ëµ

### 7.1 ì£¼ìš” ë¦¬ìŠ¤í¬

#### 7.1.1 ê³¼ì í•© (Overfitting)

**ë¦¬ìŠ¤í¬ ì„¤ëª…**:
- ë°±í…ŒìŠ¤íŒ… ë°ì´í„°ì— ê³¼ë„í•˜ê²Œ ìµœì í™”
- ì‹¤ì „ì—ì„œ ì„±ê³¼ ê¸‰ê°

**ì™„í™” ì „ëµ**:
1. **êµì°¨ê²€ì¦**: 6ë¶„í•  Walk-Forward ë¶„ì„
2. **Out-of-Sample í…ŒìŠ¤íŠ¸**: í•™ìŠµ ë°ì´í„°ì™€ ë¶„ë¦¬ëœ ê¸°ê°„ ê²€ì¦
3. **ë‹¨ìˆœì„± ìš°ì„ **: ë³µì¡í•œ ì¡°ê±´ì‹ë³´ë‹¤ ë‹¨ìˆœí•œ ì¡°ê±´ì‹ ì„ í˜¸
4. **ì •ê·œí™”**: ë³€ìˆ˜ ê°œìˆ˜ ì œí•œ (ìµœëŒ€ 10-15ê°œ)
5. **ì‹¤ì „ ê²€ì¦**: ì†Œì•¡ ë¼ì´ë¸Œ íŠ¸ë ˆì´ë”©ìœ¼ë¡œ ì¬ê²€ì¦

#### 7.1.2 LLM ë¹„ìš©

**ë¦¬ìŠ¤í¬ ì„¤ëª…**:
- ëŒ€ê·œëª¨ ì¡°ê±´ì‹ ìƒì„± ì‹œ API ë¹„ìš© ê¸‰ì¦
- ì˜ˆì‚° ì´ˆê³¼ ê°€ëŠ¥ì„±

**ì™„í™” ì „ëµ**:
1. **í•˜ì´ë¸Œë¦¬ë“œ ì ‘ê·¼**: LLM (20%) + GP (30%) + í…œí”Œë¦¿ (50%)
2. **ë¹„ìš© ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ë¹„ìš© ì¶”ì  ë° ì•Œë¦¼
3. **í”„ë¡¬í”„íŠ¸ ìµœì í™”**: í† í° ì‚¬ìš©ëŸ‰ ìµœì†Œí™”
4. **ìºì‹±**: ìœ ì‚¬ ìš”ì²­ ê²°ê³¼ ì¬ì‚¬ìš©
5. **ì˜¤í”ˆì†ŒìŠ¤ LLM**: Llama, Mistral ë“± ë¡œì»¬ ëª¨ë¸ í™œìš©

#### 7.1.3 ë°±í…ŒìŠ¤íŒ… ì‹ ë¢°ë„

**ë¦¬ìŠ¤í¬ ì„¤ëª…**:
- ìŠ¬ë¦¬í”¼ì§€, ìˆ˜ìˆ˜ë£Œ ë“± ì‹¤ì „ ìš”ì†Œ ë¯¸ë°˜ì˜
- Look-ahead ë°”ì´ì–´ìŠ¤

**ì™„í™” ì „ëµ**:
1. **ë³´ìˆ˜ì  ê°€ì •**: ìŠ¬ë¦¬í”¼ì§€ 0.2%, ìˆ˜ìˆ˜ë£Œ 0.015% ì ìš©
2. **ì²´ê²° ì§€ì—° ëª¨ë¸ë§**: 1-3í‹± ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
3. **ìœ ë™ì„± í•„í„°**: ê±°ë˜ëŒ€ê¸ˆ ìµœì†Œê°’ ì„¤ì •
4. **í˜¸ê°€ì°½ ì‹œë®¬ë ˆì´ì…˜**: ì‹¤ì œ í˜¸ê°€ ë°ì´í„° í™œìš©
5. **ë¼ì´ë¸Œ ê²€ì¦**: í˜ì´í¼ íŠ¸ë ˆì´ë”© í•„ìˆ˜

#### 7.1.4 ì‹œìŠ¤í…œ ë³µì¡ë„

**ë¦¬ìŠ¤í¬ ì„¤ëª…**:
- ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ í†µí•©ì˜ ë³µì¡ì„±
- ë””ë²„ê¹… ë° ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€

**ì™„í™” ì „ëµ**:
1. **ëª¨ë“ˆí™” ì„¤ê³„**: ê° ì»´í¬ë„ŒíŠ¸ ë…ë¦½ ì‹¤í–‰ ê°€ëŠ¥
2. **í¬ê´„ì  ë¡œê¹…**: ëª¨ë“  ë‹¨ê³„ ìƒì„¸ ê¸°ë¡
3. **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**: 80% ì´ìƒ ì»¤ë²„ë¦¬ì§€
4. **ë¬¸ì„œí™”**: API ë¬¸ì„œ ë° ì‚¬ìš© ê°€ì´ë“œ
5. **ì ì§„ì  ë°°í¬**: Phaseë³„ ë‹¨ê³„ì  êµ¬í˜„

### 7.2 ì„±ëŠ¥ ë¦¬ìŠ¤í¬

#### 7.2.1 ë°±í…ŒìŠ¤íŒ… ì†ë„

**ë¬¸ì œ**:
- 1000ê°œ ì¡°ê±´ì‹ Ã— 1ë…„ ë°ì´í„° = ìˆ˜ì‹­ ì‹œê°„ ì†Œìš”

**í•´ê²°ì±…**:
1. **ë³‘ë ¬ ì²˜ë¦¬**: 8-16 ì›Œì»¤ ë™ì‹œ ì‹¤í–‰
2. **ë°ì´í„° ìºì‹±**: ìì£¼ ì‚¬ìš©í•˜ëŠ” ë°ì´í„° ë©”ëª¨ë¦¬ ìœ ì§€
3. **Numba JIT**: ê³„ì‚° ì§‘ì•½ì  ë¶€ë¶„ ì»´íŒŒì¼
4. **ì¦ë¶„ ë°±í…ŒìŠ¤íŒ…**: ë³€ê²½ëœ ë¶€ë¶„ë§Œ ì¬ê³„ì‚°
5. **í´ë¼ìš°ë“œ í™•ì¥**: AWS/GCP ìŠ¤íŒŸ ì¸ìŠ¤í„´ìŠ¤ í™œìš©

#### 7.2.2 ë°ì´í„°ë² ì´ìŠ¤ ë³‘ëª©

**ë¬¸ì œ**:
- ëŒ€ëŸ‰ INSERT/UPDATE ì‹œ ì„±ëŠ¥ ì €í•˜

**í•´ê²°ì±…**:
1. **Batch INSERT**: 1000ê°œì”© ë¬¶ì–´ì„œ ì‚½ì…
2. **ì¸ë±ì‹±**: ìì£¼ ì¿¼ë¦¬í•˜ëŠ” ì»¬ëŸ¼ ì¸ë±ìŠ¤ ìƒì„±
3. **íŒŒí‹°ì…”ë‹**: ë‚ ì§œë³„ í…Œì´ë¸” ë¶„í• 
4. **WAL ëª¨ë“œ**: SQLite Write-Ahead Logging
5. **PostgreSQL ì „í™˜**: ëŒ€ê·œëª¨ ë°ì´í„° ì‹œ ê³ ë ¤

### 7.3 ìš´ì˜ ë¦¬ìŠ¤í¬

#### 7.3.1 ì‹œìŠ¤í…œ ì¥ì• 

**ëŒ€ì‘ ë°©ì•ˆ**:
- **ì²´í¬í¬ì¸íŒ…**: ì£¼ê¸°ì  ìƒíƒœ ì €ì¥ ë° ì¬ê°œ ê¸°ëŠ¥
- **ì—ëŸ¬ ë³µêµ¬**: ìë™ ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜
- **ì•Œë¦¼ ì‹œìŠ¤í…œ**: í…”ë ˆê·¸ë¨/ì´ë©”ì¼ ì•Œë¦¼
- **ë°±ì—…**: ì¼ì¼ ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…

#### 7.3.2 ë³´ì•ˆ

**ëŒ€ì‘ ë°©ì•ˆ**:
- **API í‚¤ ê´€ë¦¬**: í™˜ê²½ ë³€ìˆ˜ ë˜ëŠ” Vault ì‚¬ìš©
- **ì½”ë“œ ê²€ì¦**: ìƒì„±ëœ ì¡°ê±´ì‹ ìƒŒë“œë°•ìŠ¤ ì‹¤í–‰
- **ì ‘ê·¼ ì œì–´**: ë°ì´í„°ë² ì´ìŠ¤ ê¶Œí•œ ê´€ë¦¬
- **ê°ì‚¬ ë¡œê·¸**: ëª¨ë“  ì‘ì—… ê¸°ë¡

---

## 8. ğŸ’¡ [ì œì•ˆì‚¬í•­] ê²°ë¡  ë° ë¡œë“œë§µ

### 8.1 ì—°êµ¬ ìš”ì•½

ë³¸ ì—°êµ¬ëŠ” STOM ì‹œìŠ¤í…œì˜ ì¡°ê±´ì‹ ê°œë°œ í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ í˜ì‹ í•©ë‹ˆë‹¤:

1. **AI/LLM í†µí•©**: GPT-4, Claude 3.5 Sonnetì„ í™œìš©í•œ ì¡°ê±´ì‹ ìë™ ìƒì„±
2. **Genetic Programming**: DEAP ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í†µí•œ ì¡°ê±´ì‹ ì§„í™”
3. **Feature Importance**: XGBoost, SHAP ê¸°ë°˜ ë³€ìˆ˜ ì„ íƒ ìµœì í™”
4. **ìë™í™” ìˆœí™˜ í”„ë¡œì„¸ìŠ¤**: ìƒì„± â†’ í…ŒìŠ¤íŠ¸ â†’ ê¸°ë¡ â†’ ê°œì„ ì˜ 4ë‹¨ê³„ ìˆœí™˜
5. **ëŒ€ê·œëª¨ ì‹¤í—˜**: 1000ê°œ ì´ìƒ ì¡°ê±´ì‹ ë™ì‹œ ê²€ì¦ ê°€ëŠ¥

**í•µì‹¬ ì„±ê³¼**:
- ì¡°ê±´ì‹ ê°œë°œ ì‹œê°„: 2-5ì¼ â†’ 10-30ë¶„ (96% ë‹¨ì¶•)
- íƒìƒ‰ ê°€ëŠ¥ ì¡°í•©: ìˆ˜ì‹­ ê°œ â†’ ìˆ˜ì²œ ê°œ (100ë°° ì¦ê°€)
- ìµœì í™” ì‹œê°„: 587ë…„ â†’ ìˆ˜ì‹œê°„ (99.9% ë‹¨ì¶•)
- ì˜ˆìƒ ìˆ˜ìµë¥  í–¥ìƒ: +20-30%

### 8.2 í–¥í›„ ë¡œë“œë§µ

#### ë‹¨ê¸° (3-6ê°œì›”)

**Phase 1-2 ì™„ë£Œ**:
- âœ… LLM ê¸°ë°˜ ì¡°ê±´ì‹ ìƒì„±ê¸°
- âœ… Genetic Programming ì—”ì§„
- âœ… í…œí”Œë¦¿ ì‹œìŠ¤í…œ
- âœ… ìë™ ë°±í…ŒìŠ¤íŒ… íŒŒì´í”„ë¼ì¸

**ì´ˆê¸° ì„±ê³¼ ê²€ì¦**:
- 100ê°œ ì¡°ê±´ì‹ ìƒì„± ë° í…ŒìŠ¤íŠ¸
- ì„±ê³µë¥  30% ì´ìƒ ëª©í‘œ
- ë² ìŠ¤íŠ¸ ì¡°ê±´ì‹ 10ê°œ ì‹¤ì „ ë°°í¬

#### ì¤‘ê¸° (6-12ê°œì›”)

**Phase 3 ì™„ë£Œ**:
- âœ… í”¼ë“œë°± ë£¨í”„ ì™„ì „ ìë™í™”
- âœ… ì„±ê³¼ ë¶„ì„ ëŒ€ì‹œë³´ë“œ
- âœ… ìë™ ì§„í™” ë£¨í”„

**ëŒ€ê·œëª¨ ì‹¤í—˜**:
- 1000ê°œ ì¡°ê±´ì‹ ìƒì„± ìº í˜ì¸
- ë‹¤ì–‘í•œ ì „ëµ íƒ€ì… (10ì¢… ì´ìƒ)
- ì‹œì¥ ì¡°ê±´ë³„ íŠ¹í™” ì „ëµ

**ì‹¤ì „ ê²€ì¦**:
- ìƒìœ„ 50ê°œ ì¡°ê±´ì‹ ë¼ì´ë¸Œ íŠ¸ë ˆì´ë”©
- 3ê°œì›” ì„±ê³¼ ì¶”ì  ë° ë¶„ì„
- A/B í…ŒìŠ¤íŠ¸: ìˆ˜ì‘ì—… vs AI ìƒì„±

#### ì¥ê¸° (1-2ë…„)

**Phase 4+: ê³ ë„í™”**:
- ê°•í™”í•™ìŠµ (RL) í†µí•©: ë™ì  ì „ëµ í•™ìŠµ
- ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ: ì „ëµ í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”
- ì‹¤ì‹œê°„ ì‹œì¥ ì ì‘: ì˜¨ë¼ì¸ í•™ìŠµ
- ì•™ìƒë¸” ì „ëµ: ì—¬ëŸ¬ ì¡°ê±´ì‹ ì¡°í•©

**í™•ì¥**:
- ë¯¸êµ­ ì£¼ì‹ ì‹œì¥ ì ìš©
- ì„ ë¬¼/ì˜µì…˜ ì „ëµ ê°œë°œ
- ì•”í˜¸í™”í 24/7 íŠ¸ë ˆì´ë”©
- ê¸€ë¡œë²Œ ì‹œì¥ í†µí•©

**ì»¤ë®¤ë‹ˆí‹°**:
- ì˜¤í”ˆì†ŒìŠ¤ ê³µê°œ
- ì‚¬ìš©ì ê¸°ì—¬ ì „ëµ í’€
- ì „ëµ ë§ˆì¼“í”Œë ˆì´ìŠ¤
- í˜‘ì—… í”Œë«í¼ êµ¬ì¶•

### 8.3 ìµœì¢… ê²°ë¡ 

ë³¸ ì—°êµ¬ëŠ” **AI ê¸°ë°˜ ì¡°ê±´ì‹ ìë™í™” ë° ìˆœí™˜ ì—°êµ¬ ì‹œìŠ¤í…œ**ì„ í†µí•´ STOMì˜ ì¡°ê±´ì‹ ê°œë°œì„ í˜ì‹ ì ìœ¼ë¡œ ê°œì„ í•  ìˆ˜ ìˆìŒì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

**í•µì‹¬ ê°€ì¹˜**:
1. **ì‹œê°„ íš¨ìœ¨ì„±**: ìˆ˜ë™ ì‘ì—… 96% ê°ì†Œ
2. **íƒìƒ‰ ë²”ìœ„**: ì¸ê°„ì˜ í•œê³„ë¥¼ ë›°ì–´ë„˜ëŠ” ì¡°í•© íƒìƒ‰
3. **ì§€ì†ì  ê°œì„ **: ìë™ í”¼ë“œë°± ë£¨í”„ë¥¼ í†µí•œ ì§„í™”
4. **ì§€ì‹ ì¶•ì **: ëª¨ë“  ì‹¤í—˜ ê²°ê³¼ì˜ ì²´ê³„ì  ê¸°ë¡

**ì‹¤í˜„ ê°€ëŠ¥ì„±**:
- ê¸°ì¡´ STOM ì‹œìŠ¤í…œê³¼ ì™„ì „ í˜¸í™˜
- ë‹¨ê³„ë³„ ì ì§„ì  êµ¬í˜„ ê°€ëŠ¥
- ê²€ì¦ëœ ê¸°ìˆ  ìŠ¤íƒ í™œìš©
- ëª…í™•í•œ ROI ë° ì„±ê³¼ ì§€í‘œ

**ë‹¤ìŒ ë‹¨ê³„**:
1. Phase 1 êµ¬í˜„ ì‹œì‘ (ì¡°ê±´ì‹ ìƒì„± ì—”ì§„)
2. ì†Œê·œëª¨ PoC (Proof of Concept) ì‹¤í—˜
3. ì„±ê³¼ ê²€ì¦ í›„ ë³¸ê²© ë°°í¬
4. ì§€ì†ì  ê°œì„  ë° í™•ì¥

ì´ ì‹œìŠ¤í…œì€ STOMì„ ë‹¨ìˆœí•œ ë°±í…ŒìŠ¤íŒ… í”Œë«í¼ì—ì„œ **ììœ¨ í•™ìŠµ íŠ¸ë ˆì´ë”© AI**ë¡œ ì§„í™”ì‹œí‚¬ ê²ƒì…ë‹ˆë‹¤.

---

**ì‘ì„±ì**: Claude Code AI
**ê²€í† ì**: STOM Development Team
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-12-01
**ë¬¸ì„œ ë²„ì „**: 1.0
**ë‹¤ìŒ ê²€í†  ì˜ˆì •ì¼**: 2025-03-01

---

## ì°¸ê³  ë¬¸í—Œ

1. STOM ê³µì‹ ë¬¸ì„œ
   - `docs/Manual/` - ì‹œìŠ¤í…œ ë§¤ë‰´ì–¼
   - `docs/Guideline/` - ê°œë°œ ê°€ì´ë“œë¼ì¸
   - `docs/Condition/` - ì¡°ê±´ì‹ ë¬¸ì„œ (133ê°œ)

2. ê¸°ì¡´ ì—°êµ¬ ë³´ê³ ì„œ
   - `docs/Study/ResearchReports/AI_ML_Trading_Strategy_Automation_Research.md`
   - `docs/Study/ResearchReports/Research_Report_Automated_Condition_Finding.md`
   - `docs/Study/SystemAnalysis/Optistd_System_Analysis.md`
   - `docs/Study/SystemAnalysis/STOM_Optimization_System_Improvements.md`

3. ì†ŒìŠ¤ ì½”ë“œ
   - `backtester/back_static.py` - ì¡°ê±´ì‹ ë¡œë”© ë©”ì»¤ë‹ˆì¦˜
   - `backtester/backengine_kiwoom_tick.py` - ë°±í…ŒìŠ¤íŒ… ì—”ì§„
   - `backtester/optimiz.py` - ìµœì í™” ì‹œìŠ¤í…œ

4. ì™¸ë¶€ ì°¸ê³  ìë£Œ
   - DEAP Documentation: https://deap.readthedocs.io/
   - Optuna Documentation: https://optuna.readthedocs.io/
   - XGBoost Documentation: https://xgboost.readthedocs.io/
   - SHAP Documentation: https://shap.readthedocs.io/
   - Anthropic Claude API: https://docs.anthropic.com/
   - OpenAI API: https://platform.openai.com/docs/

---

**ë¬¸ì„œ ë**
