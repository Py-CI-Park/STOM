# 세그먼트 필터 예측-실제 괴리 분석 연구

**작성일**: 2026-01-07  
**상태**: 연구 진행 중  
**우선순위**: 긴급 (Critical)

---

## 1. 문제 요약

### 1.1 현상

| 항목 | 예상 (세그먼트 분석) | 실제 (백테스팅) | 차이 |
|------|---------------------|-----------------|------|
| **거래 수** | 1,497건 | 2,867건 | +1,370건 (91.5% 더 많음) |
| **수익금** | +92,329,481원 | -286,796,234원 | -379,125,715원 |
| **승률** | N/A | 30.73% | - |
| **MDD** | N/A | 82.60% | - |

### 1.2 예상 결과 출처

```
세그먼트 필터 적용 미리보기:
- 구간/필터: 20구간, 필터 42개
- 적용 방식: 시가총액/시간 구간 분리 → 구간별 필터 AND 적용
- 구간 상태: 필터적용 14구간, 무필터 0구간, 전체제외 6구간
- 거래수: 5,087 → 1,497 (제외 70.6%)
- 수익금: -997,550,667원 → +92,329,481원 (+1,089,880,148원)
```

### 1.3 관련 파일

- **세그먼트 분석 원본**: `stock_bt_Min_B_Study_251227_20260107210544`
- **자동 생성 조건**: `segment_code_final.txt` (3-8 파일)
- **실제 백테스팅**: `stock_bt_Min_B_Study_251227_Filtered_20260107215836`
- **조건 저장 위치**: `strategy.db` → `stockbuy` 테이블

---

## 2. 근본 원인 분석

### 2.1 핵심 발견: 조건식 구조적 충돌

**기존 매수조건 (`Min_B_Study_251227`)의 시간 제한:**
```python
elif 시분초 < 120000:  # 12시 이전만 매수 가능
    if 시가총액 < 100000:  # 시가총액 10조 미만
        # ... 매수 조건들 ...
    else:
        매수 = False
else:
    매수 = False  # 12시 이후는 무조건 매수 불가
```

**세그먼트 필터의 시간 범위:**
```python
# T1: 09:29 ~ 09:59
# T2: 09:59 ~ 10:29
# T3: 10:29 ~ 10:59
# T4: 10:59 ~ 11:29
# T5: 11:29 ~ 11:59 (< 12:00)
else:
    매수 = False  # 정의되지 않은 시간대 제외
```

**문제점:**
1. 기존 조건이 이미 12시 이후를 제외함
2. 세그먼트 필터의 `else: 매수 = False`가 **이미 True인 거래에만** 적용됨
3. 세그먼트 분석은 **모든 5,087건**에 필터를 적용한 시뮬레이션
4. 실제 적용은 **기존 조건을 통과한 거래**에만 추가 필터링

### 2.2 변수 계산 불일치

**세그먼트 분석 시 (DataFrame 기반):**
- 백테스팅 결과 `detail.csv`의 컬럼 값 직접 사용
- `매수당일거래대금`, `매수체결강도` 등 이미 계산된 값

**실제 적용 시 (런타임 계산):**
```python
# segment_code_final.txt 내부
매수초당거래대금 = 초당거래대금  # 런타임에 접근
매수스프레드 = ((매도호가1 - 매수호가1) / 매수호가1) * 100
매수호가잔량비 = (매수총잔량 / (매도총잔량 + 1e-6)) * 100
매수변동폭 = 고가 - 저가
```

**불일치 가능성:**
| 변수 | 분석 시 | 적용 시 | 차이 원인 |
|------|---------|---------|----------|
| `당일거래대금_5틱분봉평균_비율` | DataFrame 계산 | `당일거래대금N()` 함수 | 함수 접근 방식 차이 |
| `현재가_고저범위_위치` | DataFrame 계산 | `(현재가 - 저가) / (고가 - 저가)` | 시점 차이 |
| `거래품질점수` | 백테스팅 후 계산 | 런타임 간이 계산 | 계산 로직 차이 |

### 2.3 세그먼트 경계값 불일치 (이전 수정 사항)

**README.md 2026-01-01 수정 내역:**
```
근본 원인:
- Dynamic 세그먼트 분할은 분위수(quantile) 기반으로 경계를 계산
- 세그먼트 분석 시: 원본 데이터 → 분위수 계산 → 경계 A (대형주 ≥ 6,432억)
- 필터 적용 시: 강화 데이터 → 분위수 재계산 → 경계 B (다름!)

해결 방법:
1. ranges.csv 저장
2. 필터 적용 시 fixed 모드로 동일 경계 사용
```

**현재 상황:**
- `ranges.csv`에 경계값 저장됨: 초소형주 0-1350.5, 소형주 1350.5-2622, 중형주 2622-6432, 대형주 6432+
- `segment_code_final.txt`에 이 값들이 하드코딩됨
- **그러나** 이 수정으로도 문제가 해결되지 않음 → 다른 원인 존재

---

## 3. 가설 목록

### 가설 1: 세그먼트 필터 적용 위치 문제 (높은 확률)

**현재 구조:**
```
매수 = True
↓
[기존 조건 체크] → 많은 거래가 매수=False
↓
[세그먼트 필터] → 이미 False인 건 영향 없음
```

**예상 구조:**
```
매수 = True
↓
[공통 선결 조건만] → 기본 검증
↓
[세그먼트 필터] → 시간대/시가총액별 정밀 필터
↓
[필요시 추가 조건]
```

**검증 방법:**
- 기존 조건을 세그먼트 필터로 **대체**하는 버전 테스트
- 또는 세그먼트 필터를 기존 조건 **앞에** 배치

### 가설 2: 기존 조건과 세그먼트 필터의 중복 제외 (중간 확률)

**현상:**
- 기존 조건: `시분초 < 120000 and 시가총액 < 100000` 내에서만 매수 허용
- 세그먼트 필터: T1~T5 시간대에서 시가총액별 추가 필터

**중복:**
- 기존: 시가총액 10조 이상 제외
- 세그먼트: 대형주(6432억+) 세그먼트에서 별도 필터 적용
- → 시가총액 6432~100000억 구간에서 이중 필터링 가능

### 가설 3: 런타임 변수 접근 오류 (중간 확률)

**문제 코드:**
```python
try:
    _prev_trade = 당일거래대금N(1)
    당일거래대금_전틱분봉_비율 = 당일거래대금 / (_prev_trade + 1e-6)
except (NameError, TypeError):
    당일거래대금_전틱분봉_비율 = 0.0  # 기본값으로 폴백
```

**위험:**
- `당일거래대금N()` 함수가 분봉 전략에서 제대로 작동하는지?
- 함수가 없으면 0.0으로 폴백 → 필터 조건 의도와 다른 결과

### 가설 4: 세그먼트 분석 시 필터 적용 방식 차이 (높은 확률)

**분석 시 (DataFrame 마스킹):**
```python
# 세그먼트 분석
mask = (df['시가총액'] >= 6432) & (df['시분초'] >= 92900) & (df['시분초'] < 95900)
segment_df = df[mask]
filter_mask = (segment_df['매수매도총잔량'] >= 9436.4) & ...
remaining = segment_df[filter_mask]
```

**적용 시 (순차 조건 평가):**
```python
# 실제 조건식
if 시분초 >= 92900 and 시분초 < 95900:
    if 시가총액 >= 6432:
        if not ((매수매도총잔량 >= 9436.4) and ...):
            매수 = False  # 이미 False면 변화 없음!
```

**핵심 차이:**
- 분석: 전체 데이터셋에서 조건 만족하는 행 선택
- 적용: 순차적 조건 평가, **이미 False인 경우 조기 종료**

### 가설 5: 전체제외 세그먼트 처리 문제 (낮은 확률)

**전체제외 세그먼트:**
- 초소형주_T1, 초소형주_T2, 초소형주_T4, 초소형주_T5
- 소형주_T1, 중형주_T1

**코드:**
```python
매수 = False  # 세그먼트 전체 제외
```

**문제 가능성:**
- 이 거래들이 기존 조건에서 이미 제외되었을 수 있음
- → 세그먼트 필터의 제외 효과가 중복 계산됨

---

## 4. 해결 방안 연구

### 4.1 방안 A: 세그먼트 필터 전용 조건식 (권장)

**개념:**
- 기존 조건을 완전히 **대체**하는 세그먼트 기반 조건식
- 세그먼트 분석 결과가 곧 실제 성과

**구현:**
```python
매수 = True

# 공통 선결 조건 (최소한의 필터)
if not (관심종목 == 1):
    매수 = False
elif not (0 < 현재가 <= 50000):
    매수 = False
elif not (1.0 < 등락율 <= 20.0):
    매수 = False

# 세그먼트 필터 (기존 시간/시가총액 조건 대체)
elif 시분초 >= 92900 and 시분초 < 95900:
    # T1 시간대 처리 (세그먼트 필터 로직)
    ...
# T2~T5 처리
...
else:
    매수 = False  # 정의되지 않은 구간 제외

if 매수:
    self.Buy(...)
```

**장점:**
- 세그먼트 분석 결과 = 실제 백테스팅 결과
- 명확한 1:1 대응

**단점:**
- 기존 조건의 일부 로직 손실 가능
- 조건식 완전 재작성 필요

### 4.2 방안 B: 세그먼트 필터 우선 적용

**개념:**
- 세그먼트 필터를 기존 조건 **앞에** 배치
- 세그먼트 필터가 먼저 제외 → 기존 조건 추가 검증

**구현:**
```python
매수 = True

# 1단계: 세그먼트 필터 (먼저 적용)
if 시분초 >= 92900 and 시분초 < 95900:
    if 시가총액 >= 6432:
        if not ((매수매도총잔량 >= 9436.4) and ...):
            매수 = False
    # ... 다른 시가총액 구간 ...
elif 시분초 >= 95900 and 시분초 < 102900:
    # T2 처리
    ...
else:
    매수 = False  # 정의되지 않은 시간대

# 2단계: 기존 공통 조건 (세그먼트 필터 통과한 거래만)
if 매수:
    if not (관심종목 == 1):
        매수 = False
    elif not (0 < 현재가 <= 50000):
        매수 = False
    # ... 추가 조건 ...

if 매수:
    self.Buy(...)
```

**장점:**
- 기존 조건 로직 유지
- 점진적 적용 가능

**단점:**
- 여전히 조건 순서 의존성
- 분석-실제 괴리 가능성 남음

### 4.3 방안 C: 독립 게이트 방식

**개념:**
- 세그먼트 필터와 기존 조건을 **별도 변수**로 평가
- 최종 매수 = 세그먼트게이트 AND 기존게이트

**구현:**
```python
세그먼트통과 = True
기존조건통과 = True

# 세그먼트 필터 평가
if 시분초 >= 92900 and 시분초 < 95900:
    if 시가총액 >= 6432:
        if not ((매수매도총잔량 >= 9436.4) and ...):
            세그먼트통과 = False
    # ...
else:
    세그먼트통과 = False

# 기존 조건 평가 (독립)
if not (관심종목 == 1):
    기존조건통과 = False
elif not (0 < 현재가 <= 50000):
    기존조건통과 = False
# ...

# 최종 결합
매수 = 세그먼트통과 and 기존조건통과

if 매수:
    self.Buy(...)
```

**장점:**
- 두 필터의 독립적 평가
- 디버깅 용이 (어느 게이트에서 제외되었는지 명확)

**단점:**
- 코드 복잡도 증가
- 분석 결과와 여전히 차이 가능 (기존조건 추가 제외)

### 4.4 방안 D: 세그먼트 분석 시 기존 조건 반영

**개념:**
- 세그먼트 분석 단계에서 기존 조건을 **먼저 적용**
- 기존 조건 통과 거래만 대상으로 세그먼트 최적화

**구현 (분석 로직 수정):**
```python
# segment_analysis/phase2_runner.py
def run_segment_analysis(df, buystg, ...):
    # 1. 기존 조건 시뮬레이션 (새로운 단계)
    df_filtered = apply_existing_conditions(df, buystg)
    
    # 2. 세그먼트 분석 (기존 조건 통과 거래 대상)
    segment_results = analyze_segments(df_filtered)
    
    # 3. 필터 최적화 (기존 조건 통과 거래 대상)
    optimal_filters = optimize_filters(segment_results)
    
    return optimal_filters
```

**장점:**
- 가장 정확한 분석-실제 일치
- 기존 조건의 효과가 분석에 반영됨

**단점:**
- 분석 로직 대폭 수정 필요
- 기존 조건 파싱/시뮬레이션 구현 필요

---

## 5. 권장 해결 순서

### Phase 1: 검증 및 진단 (1-2일)

1. **거래 수 차이 원인 분석**
   - 원본 5,087건 vs 기존조건 통과 건수 vs Filtered 2,867건
   - 각 단계에서 제외되는 거래 수 파악

2. **변수 값 비교**
   - 분석 시 사용된 값 vs 런타임 계산 값
   - 차이 큰 변수 식별

3. **세그먼트별 거래 매칭**
   - 분석 시 예상 잔여 거래 vs 실제 잔여 거래
   - 세그먼트별로 불일치 패턴 확인

### Phase 2: 최소 수정 테스트 (2-3일)

1. **방안 B 테스트**: 세그먼트 필터 우선 적용
   - `segment_code_final.txt` 구조 변경
   - 백테스팅으로 결과 비교

2. **변수 계산 로직 통일**
   - 런타임 변수 계산을 분석 로직과 동일하게 수정
   - 특히 `당일거래대금_*` 관련 변수

### Phase 3: 근본 해결 구현 (1주)

1. **방안 A 구현**: 세그먼트 전용 조건식
   - 기존 조건을 세그먼트 필터로 완전 대체
   - 분석 결과 = 실제 결과 보장

2. **조건식 생성기 개선**
   - `code_generator.py` 수정
   - 기존 조건 통합/대체 옵션 추가

### Phase 4: 분석 시스템 개선 (장기)

1. **방안 D 구현**: 기존 조건 반영 분석
   - 더 정확한 예측을 위한 분석 파이프라인 개선
   - 조건식 파싱 및 시뮬레이션 모듈 개발

---

## 6. 즉시 수행 가능한 검증

### 6.1 거래 수 단계별 분석

```sql
-- 원본 거래 수 확인
SELECT COUNT(*) FROM detail WHERE save_file_name LIKE '%Min_B_Study_251227_20260107210544%';
-- 예상: 5,087

-- Filtered 거래 수 확인
SELECT COUNT(*) FROM detail WHERE save_file_name LIKE '%Min_B_Study_251227_Filtered%';
-- 예상: 2,867
```

### 6.2 세그먼트별 거래 분포 비교

```python
# 원본 detail.csv 로드
df_original = pd.read_csv('...Min_B_Study_251227_20260107210544/.../detail.csv')

# 세그먼트별 거래 수 (분석 시 사용된 범위)
for t_range in [(92900, 95900), (95900, 102900), ...]:
    for cap_range in [(0, 1350.5), (1350.5, 2622), ...]:
        count = len(df_original[(df_original['시분초'] >= t_range[0]) & 
                                 (df_original['시분초'] < t_range[1]) &
                                 (df_original['시가총액'] >= cap_range[0]) &
                                 (df_original['시가총액'] < cap_range[1])])
        print(f"T{t_idx}_C{c_idx}: {count}건")
```

### 6.3 기존 조건 적용 후 잔여 거래 확인

```python
# Min_B_Study_251227 조건을 수동으로 적용
def apply_existing_conditions(row):
    if row['관심종목'] != 1:
        return False
    if not (0 < row['현재가'] <= 50000):
        return False
    if not (1.0 < row['등락율'] <= 20.0):
        return False
    if not (row['시분초'] < 120000):
        return False
    if not (row['시가총액'] < 100000):
        return False
    # ... 추가 조건 ...
    return True

df_after_existing = df_original[df_original.apply(apply_existing_conditions, axis=1)]
print(f"기존 조건 통과: {len(df_after_existing)}건")
```

---

## 7. 관련 파일 참조

### 코드 파일

| 파일 | 역할 | 수정 대상 |
|------|------|----------|
| `backtester/analysis_enhanced/runner.py` | 분석 실행 및 조건식 저장 | Phase 2-3 |
| `backtester/segment_analysis/code_generator.py` | 세그먼트 코드 생성 | Phase 2-3 |
| `backtester/segment_analysis/phase2_runner.py` | 세그먼트 분석 실행 | Phase 4 |
| `backtester/back_static.py` | 필터 적용 헬퍼 | Phase 1-2 |

### 데이터 파일

| 파일 | 내용 |
|------|------|
| `3-55_*_segment_code.txt` | 세그먼트 필터 코드 (템플릿별) |
| `3-8_*_segment_code_final.txt` | 최종 조건식 (기존+세그먼트 통합) |
| `3-53_*_segment_combos.csv` | 세그먼트별 필터 조합 |
| `3-54_*_segment_ranges.csv` | 동적 경계값 |

### 이전 수정 이력

- `README.md` 2026-01-01: 세그먼트 경계값 불일치 수정
- `back_static.py`: `_load_segment_config_from_ranges()` 추가

---

## 8. 결론 및 다음 단계

### 핵심 발견

1. **구조적 문제**: 세그먼트 필터가 기존 조건 **뒤에** 배치되어 효과 감소
2. **분석-적용 불일치**: 분석은 전체 데이터 대상, 적용은 기존 조건 통과 데이터 대상
3. **변수 계산 차이**: DataFrame 컬럼 값 vs 런타임 계산 값

### 권장 조치

| 우선순위 | 조치 | 예상 효과 |
|---------|------|----------|
| **1순위** | 거래 수 단계별 분석 (Phase 1) | 정확한 원인 파악 |
| **2순위** | 세그먼트 필터 우선 적용 테스트 (방안 B) | 중간 개선 기대 |
| **3순위** | 세그먼트 전용 조건식 구현 (방안 A) | 완전 일치 기대 |

### 다음 작업

1. [ ] Phase 1 검증 스크립트 작성 및 실행
2. [ ] 기존 조건 통과 후 잔여 거래 수 확인
3. [ ] 방안 B 프로토타입 구현
4. [ ] 비교 백테스팅 실행

---

**문서 작성**: Claude (AI Assistant)  
**검토 필요**: 사용자 확인 후 Phase 1 진행
