# 세그먼트 필터 당일 재매수 차단 기능 구현 가이드

> 작성일: 2026-01-09
> 브랜치: `feature/segment-filter-daily-block-implementation`
> 관련 분석 문서: `docs/Study/SystemAnalysis/20260108_Segment_Filter_Prediction_vs_Actual_Discrepancy_Analysis.md`

---

## 1. 개요

### 1.1 문제 상황

세그먼트 필터 적용 시 예측과 실제 거래 수 사이에 심각한 괴리가 발생했습니다:

| 구분 | 값 |
|------|-----|
| 예측 거래 수 | 1,497건 |
| 실제 거래 수 | 2,955건 |
| 괴리율 | **+97.4%** |

### 1.2 근본 원인: "대체 매수" 현상

```
시나리오 예시:
1. 종목 A, 09:30 - 세그먼트 필터에 의해 차단됨
2. 종목 A, 10:15 - 다시 매수 조건에 걸림
3. 10:15의 세그먼트 필터 → 통과!
4. 결과: 09:30에 차단된 거래가 10:15에 "대체 매수"됨
```

이러한 "대체 매수" 현상으로 인해 세그먼트 필터의 예측과 실제 사이에 괴리가 발생합니다.

### 1.3 해결 방안

**옵션 1: 조건식 + 인프라 통합 방식 (본 구현)**

세그먼트 필터에서 한 번 차단된 종목은 해당 날짜 동안 전체 매수를 금지합니다.

---

## 2. 아키텍처

### 2.1 인프라 구조

```
┌─────────────────────────────────────────────────────────────┐
│                        전략 엔진                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    인프라 변수                           │ │
│  │  self.세그먼트차단종목 = {}                              │ │
│  │    키: (종목코드, 날짜)                                  │ │
│  │    값: 최초 차단 시분초                                  │ │
│  │                                                         │ │
│  │  self._세그먼트차단_마지막날짜 = 0                       │ │
│  │    (날짜 변경 감지용)                                   │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 수정된 파일 목록

| 파일 | 역할 | 수정 내용 |
|------|------|----------|
| `stock/kiwoom_strategy_tick.py` | 실전 거래 엔진 | 인프라 변수 추가 |
| `backtester/backengine_kiwoom_tick.py` | 주식 백테스팅 | 인프라 변수 추가 |
| `backtester/backengine_upbit_tick.py` | 업비트 백테스팅 | 인프라 변수 추가 |
| `backtester/backengine_binance_tick.py` | 바이낸스 백테스팅 | 인프라 변수 추가 |
| `backtester/segment_analysis/code_generator.py` | 코드 생성기 | 당일 차단 로직 생성 |

### 2.3 상속 구조

```
BackEngineKiwoomTick (부모 - 인프라 정의)
        │
        └── BackEngineKiwoomMin (자식 - 상속받아 사용)

BackEngineUpbitTick (부모 - 인프라 정의)
        │
        └── BackEngineUpbitMin (자식 - 상속받아 사용)

BackEngineBinanceTick (부모 - 인프라 정의)
        │
        └── BackEngineBinanceMin (자식 - 상속받아 사용)
```

---

## 3. 구현 상세

### 3.1 인프라 코드 (4개 파일 공통)

```python
# === 세그먼트 필터 당일 재매수 차단 인프라 (2026-01-09 추가) ===
# 세그먼트 필터에서 차단된 종목을 당일 전체 매수 금지하기 위한 저장소
# 키: (종목코드, 날짜), 값: 최초 차단 시분초
# 조건식 코드에서 self.세그먼트차단종목[(종목코드, 날짜)] 형태로 접근
self.세그먼트차단종목 = {}
self._세그먼트차단_마지막날짜 = 0
```

### 3.2 코드 생성기 수정

#### 3.2.1 새로운 함수: `_build_daily_block_preamble()`

날짜 변경 감지 및 이미 차단된 종목 확인 코드를 생성합니다:

```python
def _build_daily_block_preamble() -> List[str]:
    """
    생성되는 코드:

    # === 세그먼트 필터 당일 재매수 차단 (2026-01-09) ===
    # 날짜 추출 (index에서 YYYYMMDD 부분)
    try:
        _오늘날짜 = int(str(self.index)[:8]) if len(str(self.index)) >= 8 else 0
    except (AttributeError, ValueError):
        _오늘날짜 = 0

    # 날짜 변경 감지 시 차단 목록 초기화
    if _오늘날짜 != self._세그먼트차단_마지막날짜:
        self.세그먼트차단종목 = {}
        self._세그먼트차단_마지막날짜 = _오늘날짜

    # 이미 오늘 차단된 종목인지 확인 (당일 재매수 차단)
    _이미차단됨 = (종목코드, _오늘날짜) in self.세그먼트차단종목
    if _이미차단됨:
        매수 = False  # 당일 재매수 차단: 이미 차단된 종목
    """
```

#### 3.2.2 새로운 함수: `_build_daily_block_record()`

세그먼트 필터에서 차단된 종목을 기록하는 코드를 생성합니다:

```python
def _build_daily_block_record() -> List[str]:
    """
    생성되는 코드:

    # 세그먼트 필터에서 차단된 경우, 차단 목록에 기록
    if not 매수 and (종목코드, _오늘날짜) not in self.세그먼트차단종목:
        try:
            self.세그먼트차단종목[(종목코드, _오늘날짜)] = 시분초
        except NameError:
            self.세그먼트차단종목[(종목코드, _오늘날짜)] = 0
    """
```

#### 3.2.3 수정된 함수: `_inject_segment_filter_first()`

```python
def _inject_segment_filter_first(
    working_lines: List[str],
    segment_code_lines: List[str],
    enable_daily_block: bool = True,  # 새 파라미터
) -> Tuple[List[str], bool]:
```

---

## 4. 동작 흐름

### 4.1 전체 흐름도

```
┌──────────────────────────────────────────────────────────────┐
│                    매수 조건 평가 시작                         │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  1. 날짜 추출 (_오늘날짜 = index에서 YYYYMMDD)                │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  2. 날짜 변경 확인                                            │
│     if _오늘날짜 != self._세그먼트차단_마지막날짜:             │
│         self.세그먼트차단종목 = {}  # 초기화                   │
│         self._세그먼트차단_마지막날짜 = _오늘날짜              │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  3. 이미 차단된 종목 확인                                     │
│     if (종목코드, _오늘날짜) in self.세그먼트차단종목:         │
│         매수 = False  ──────────────────────────────────────┼─┐
└──────────────────────────────────────────────────────────────┘ │
                              │                                   │
                              ▼                                   │
┌──────────────────────────────────────────────────────────────┐ │
│  4. 세그먼트 필터 평가                                        │ │
│     (기존 세그먼트 필터 로직 실행)                            │ │
│     → 조건 불충족 시 매수 = False                             │ │
└──────────────────────────────────────────────────────────────┘ │
                              │                                   │
                              ▼                                   │
┌──────────────────────────────────────────────────────────────┐ │
│  5. 차단 기록                                                 │ │
│     if not 매수 and 아직 기록 안 됨:                          │ │
│         self.세그먼트차단종목[(종목코드, _오늘날짜)] = 시분초  │ │
└──────────────────────────────────────────────────────────────┘ │
                              │                                   │
                              ▼                                   │
┌──────────────────────────────────────────────────────────────┐ │
│  6. 기존 매수 조건 평가                                       │◄┘
│     (세그먼트 필터 통과 시에만 의미 있음)                     │
└──────────────────────────────────────────────────────────────┘
```

### 4.2 시나리오 예시

#### 시나리오: 동일 종목 다중 매수 시도

```
시간    종목    세그먼트 필터 결과    당일 차단 동작
────────────────────────────────────────────────────────
09:30   A      차단 (매수=False)    차단 목록에 추가 (A, 20260109)
10:15   A      -                    이미 차단됨 → 즉시 매수=False
10:45   A      -                    이미 차단됨 → 즉시 매수=False
11:00   B      통과                 통과 (차단 목록에 없음)
14:30   A      -                    이미 차단됨 → 즉시 매수=False

다음날 (2026-01-10):
09:00   -      -                    날짜 변경 → 차단 목록 초기화
09:15   A      통과                 새 날짜이므로 정상 평가
```

---

## 5. 테스트 방법

### 5.1 단위 테스트

```python
# 테스트 시나리오
def test_daily_block():
    # 1. 첫 번째 거래 차단 확인
    # 2. 같은 종목 두 번째 거래 즉시 차단 확인
    # 3. 다른 종목은 정상 평가 확인
    # 4. 날짜 변경 시 초기화 확인
    pass
```

### 5.2 통합 테스트

1. 백테스팅 실행 전/후 거래 수 비교
2. 예측 거래 수와 실제 거래 수 일치 확인
3. 동일 종목 다중 매수 시도 시 첫 번째만 기록 확인

### 5.3 검증 체크리스트

- [ ] 인프라 변수가 올바르게 초기화되는가?
- [ ] 날짜 변경 시 차단 목록이 초기화되는가?
- [ ] 이미 차단된 종목이 즉시 차단되는가?
- [ ] 새로 차단된 종목이 목록에 기록되는가?
- [ ] 예측 거래 수와 실제 거래 수가 일치하는가?

---

## 6. 성능 고려사항

### 6.1 메모리 사용량

- 차단 목록은 `dict` 자료구조 사용
- 키: `(종목코드, 날짜)` 튜플
- 하루 최대 종목 수: 약 2,500개 (코스피+코스닥)
- 예상 메모리: 약 200KB/일 (무시 가능)

### 6.2 조회 성능

- `dict` 조회: O(1) 평균
- 추가적인 성능 오버헤드: 무시 가능

---

## 7. 주의사항

### 7.1 분봉 엔진 호환성

분봉 엔진(`BackEngine*Min`)은 틱 엔진을 상속받으므로 자동으로 인프라를 사용합니다.
별도의 수정 없이 동작합니다.

### 7.2 날짜 형식

`self.index`에서 날짜를 추출합니다:
- 형식: `YYYYMMDDHHMMSS...`
- 예: `20260109093045123` → `20260109`

### 7.3 실전 거래 vs 백테스팅

실전 거래와 백테스팅 모두 동일한 인프라를 사용하여 일관성을 보장합니다.

---

## 8. 실전 거래 동작 원리 (상세)

> **핵심 질문**: "실전 거래 시 조건식으로만 매수/매도가 되는데, 어떻게 세그먼트 필터 차단 변수가 활성화되는가?"
>
> **결론**: Python의 `exec()` 함수 동작 원리와 클래스 상속 구조에 의해 **정상적으로 동작합니다**.

---

### 8.1 조건식이 로드되는 전체 흐름

조건식이 DB에서 로드되어 실행되기까지의 전체 과정입니다:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  [1단계] 사용자가 UI에서 조건식 입력/수정                                      │
│       ↓                                                                      │
│       조건식 텍스트 (문자열)                                                  │
│       예: "if 등락율 > 5:\n    매수 = True\n..."                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  [2단계] strategy.db에 저장                                                   │
│       ↓                                                                      │
│       DB에 문자열로 저장됨                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  [3단계] 전략 엔진 시작 시 로드 (kiwoom_strategy_tick.py:91)                   │
│       ↓                                                                      │
│       self.SetBuyStg(buytxt)  ← buytxt는 DB에서 읽은 조건식 문자열            │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  [4단계] SetBuyStg에서 compile() (kiwoom_strategy_tick.py:108-109)             │
│                                                                              │
│       def SetBuyStg(self, buytxt):                                           │
│           self.buystrategy, indistg = get_buy_indi_stg(buytxt)              │
│                                                                              │
│  [4-1] get_buy_indi_stg() 내부 (utility/static.py:208-230):                   │
│       buystg = compile(buytxt, '<string>', 'exec')                          │
│                                                                              │
│       → 문자열을 Python 코드 객체로 컴파일                                    │
│       → self.buystrategy에 컴파일된 코드 객체 저장                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────────────┐
│  [5단계] 실시간 데이터 수신 시 조건식 실행 (kiwoom_strategy_min.py:545)         │
│                                                                              │
│       exec(self.buystrategy)  ← 컴파일된 코드 객체 실행                       │
└─────────────────────────────────────────────────────────────────────────────┘
```

**관련 코드 참조:**

```python
# utility/static.py:208-230
def get_buy_indi_stg(buytxt):
    buystg  = ''
    indistg = ''
    for line in buytxt.split('\n'):
        if 'self.indicator' in line:
            indistg += f'{line}\n'
        else:
            buystg += f'{line}\n'
    if buystg != '':
        try:
            buystg = compile(buystg, '<string>', 'exec')  # ← 문자열을 코드 객체로 컴파일
        except:
            buystg = None
    else:
        buystg = None
    # ...
    return buystg, indistg
```

---

### 8.2 Python `exec()` 함수의 동작 원리

#### 8.2.1 `exec()` 함수 시그니처

```python
exec(object, globals=None, locals=None)
```

- `object`: 실행할 코드 (문자열 또는 컴파일된 코드 객체)
- `globals`: 전역 네임스페이스 (생략 시 현재 globals() 사용)
- `locals`: 지역 네임스페이스 (생략 시 현재 locals() 사용)

#### 8.2.2 핵심: `globals`와 `locals`가 생략되면?

**현재 스코프의 `globals()`와 `locals()`가 자동으로 사용됩니다.**

클래스 메서드 내부에서 호출되면:
- `globals()` = 모듈 레벨 네임스페이스 (import된 모듈, 전역 함수 등)
- `locals()` = **현재 메서드의 로컬 변수** (`self`, `data`, `종목코드` 등 포함)

#### 8.2.3 실제 코드 컨텍스트

```python
# kiwoom_strategy_min.py:15-548 (핵심 부분만 발췌)
class KiwoomStrategyMin(KiwoomStrategyTick):
    def Strategy(self, data):  # ← self가 파라미터로 전달됨
        체결시간, 현재가, 시가, 고가, 저가, 등락율, ... 종목코드, 종목명, ... = data
        # ↑ 종목코드 등이 로컬 변수로 정의됨

        시분초 = int(str(체결시간)[8:] + '00')  # ← 시분초가 로컬 변수로 정의됨
        ...

        매수 = True  # ← 매수가 로컬 변수로 정의됨
        if self.buystrategy is not None:
            try:
                exec(self.buystrategy)  # ← 여기서 실행
                # 이 시점에서 locals()에 포함된 것들:
                # - self (메서드 파라미터)
                # - 종목코드, 현재가, 시가, 고가, 저가, 등락율, ... (data에서 언패킹)
                # - 매수, 시분초, ... (로컬 변수)
            except:
                ...
```

**따라서:**
- `exec(self.buystrategy)` 호출 시 **자동으로 현재 메서드의 locals()가 사용됨**
- `locals()`에 `self`가 포함되어 있음
- exec된 조건식 코드에서 `self.세그먼트차단종목`에 **읽기/쓰기 모두 가능**

---

### 8.3 상속 구조와 메모리 구조

#### 8.3.1 클래스 상속 구조

```
KiwoomReceiver (기반 클래스)
        │
        ↓
KiwoomStrategyTick (부모 클래스)
│   def __init__(self, ...):
│       ...
│       # === 세그먼트 필터 당일 재매수 차단 인프라 (2026-01-09 추가) ===
│       self.세그먼트차단종목 = {}           # ← 인프라 변수 1
│       self._세그먼트차단_마지막날짜 = 0    # ← 인프라 변수 2
│       ...
│
└── KiwoomStrategyMin (자식 클래스)
        def Strategy(self, data):
            ...
            exec(self.buystrategy)
            # 이 시점에서 self는 KiwoomStrategyMin의 인스턴스
            # 부모 클래스에서 초기화된 self.세그먼트차단종목도 접근 가능
```

#### 8.3.2 메모리 구조 시각화

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  KiwoomStrategyMin 인스턴스 (self)                                           │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │  부모 클래스(KiwoomStrategyTick)에서 초기화된 속성:                        │ │
│  │  ├── self.buystrategy = <compiled code object>                          │ │
│  │  ├── self.sellstrategy = <compiled code object>                         │ │
│  │  ├── self.세그먼트차단종목 = {}           ← ✅ 인프라 변수                 │ │
│  │  ├── self._세그먼트차단_마지막날짜 = 0    ← ✅ 인프라 변수                 │ │
│  │  ├── self.dict_arry = {...}                                             │ │
│  │  ├── self.index = 20260109093000000                                     │ │
│  │  └── ...                                                                │ │
│  │                                                                         │ │
│  │  자식 클래스(KiwoomStrategyMin)에서 정의된 메서드:                         │ │
│  │  └── Strategy(self, data) → exec(self.buystrategy) 호출                 │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

**핵심**: Python의 객체 모델에서 자식 클래스의 인스턴스는 부모 클래스에서 정의된 모든 속성에 접근할 수 있습니다.

---

### 8.4 조건식 코드 예시와 변수 해석

#### 8.4.1 code_generator.py가 생성하는 당일 차단 코드

```python
# === 세그먼트 필터 당일 재매수 차단 (2026-01-09) ===
# 한 번 차단된 종목은 해당 날짜 동안 재매수 시도 자체를 차단
# 목적: '대체 매수' 현상 방지 (예측 vs 실제 괴리 해소)

# 날짜 추출 (index에서 YYYYMMDD 부분)
try:
    _오늘날짜 = int(str(self.index)[:8]) if len(str(self.index)) >= 8 else 0
except (AttributeError, ValueError):
    _오늘날짜 = 0

# 날짜 변경 감지 시 차단 목록 초기화
if _오늘날짜 != self._세그먼트차단_마지막날짜:
    self.세그먼트차단종목 = {}
    self._세그먼트차단_마지막날짜 = _오늘날짜

# 이미 오늘 차단된 종목인지 확인 (당일 재매수 차단)
_이미차단됨 = (종목코드, _오늘날짜) in self.세그먼트차단종목
if _이미차단됨:
    매수 = False  # 당일 재매수 차단: 이미 차단된 종목

# 아래 세그먼트 필터는 _이미차단됨 여부와 무관하게 평가됨
# ... (세그먼트 필터 조건) ...

# 세그먼트 필터에서 차단된 경우, 차단 목록에 기록
# 다음 번 같은 종목의 매수 시도 시 즉시 차단됨
if not 매수 and (종목코드, _오늘날짜) not in self.세그먼트차단종목:
    try:
        self.세그먼트차단종목[(종목코드, _오늘날짜)] = 시분초
    except NameError:
        self.세그먼트차단종목[(종목코드, _오늘날짜)] = 0
```

#### 8.4.2 변수별 출처와 접근 방법

| 변수 | 출처 | 접근 방법 | 설명 |
|------|------|----------|------|
| `self` | `Strategy(self, data)` 파라미터 | `locals()`에 포함 | 메서드의 첫 번째 파라미터 |
| `self.index` | 부모 클래스 인스턴스 속성 | `self.속성` 접근 | 현재 데이터의 타임스탬프 |
| `self._세그먼트차단_마지막날짜` | 부모 `__init__`에서 초기화 | `self.속성` 접근 | 날짜 변경 감지용 |
| `self.세그먼트차단종목` | 부모 `__init__`에서 초기화 | `self.속성` 접근 | 차단 목록 딕셔너리 |
| `종목코드` | `Strategy()` 내 `data` 언패킹 | `locals()`에 포함 | 예: "005930" |
| `매수` | `Strategy()` 내 로컬 변수 | `locals()`에 포함 | True/False |
| `시분초` | `Strategy()` 내 계산된 값 | `locals()`에 포함 | 예: 93000 |
| `_오늘날짜` | exec된 코드 내 정의 | 코드 내 로컬 | 예: 20260109 |
| `_이미차단됨` | exec된 코드 내 정의 | 코드 내 로컬 | True/False |

**모든 변수가 `exec()` 실행 컨텍스트에서 접근 가능합니다.**

---

### 8.5 백테스팅 vs 실전 거래 비교

#### 8.5.1 비교 테이블

| 항목 | 백테스팅 | 실전 거래 |
|------|----------|----------|
| **클래스** | `BackEngineKiwoomMin` | `KiwoomStrategyMin` |
| **부모 클래스** | `BackEngineKiwoomTick` | `KiwoomStrategyTick` |
| **인프라 초기화 위치** | `backengine_kiwoom_tick.py:77-82` | `kiwoom_strategy_tick.py:52-57` |
| **조건식 변수명** | `self.buystg` | `self.buystrategy` |
| **조건식 실행** | `exec(self.buystg)` | `exec(self.buystrategy)` |
| **self 접근** | ✅ 동일하게 가능 | ✅ 동일하게 가능 |
| **동작 메커니즘** | Python exec() 표준 동작 | Python exec() 표준 동작 |

#### 8.5.2 인프라 코드 비교

**백테스팅 (backengine_kiwoom_tick.py:77-82):**

```python
# === 세그먼트 필터 당일 재매수 차단 인프라 (2026-01-09 추가) ===
# 세그먼트 필터에서 차단된 종목을 당일 전체 매수 금지하기 위한 저장소
# 키: (종목코드, 날짜), 값: 최초 차단 시분초
# 조건식 코드에서 self.세그먼트차단종목[(종목코드, 날짜)] 형태로 접근
self.세그먼트차단종목 = {}
self._세그먼트차단_마지막날짜 = 0
```

**실전 거래 (kiwoom_strategy_tick.py:52-57):**

```python
# === 세그먼트 필터 당일 재매수 차단 인프라 (2026-01-09 추가) ===
# 세그먼트 필터에서 차단된 종목을 당일 전체 매수 금지하기 위한 저장소
# 키: (종목코드, 날짜), 값: 최초 차단 시분초
# 조건식 코드에서 self.세그먼트차단종목[(종목코드, 날짜)] 형태로 접근
self.세그먼트차단종목 = {}
self._세그먼트차단_마지막날짜 = 0
```

**동일한 인프라가 양쪽에 모두 존재하며, 동일한 메커니즘으로 동작합니다.**

---

### 8.6 잠재적 문제점 분석

#### 8.6.1 Python `exec()` 주의사항

```python
# 주의: exec() 내에서 새 로컬 변수 정의 시 함수 locals()에 추가 안 됨
def example():
    exec("x = 10")
    print(x)  # NameError! x는 함수 스코프에 없음

# 하지만 self.속성 수정은 정상 동작
def example2(self):
    exec("self.x = 10")  # ✅ 정상 동작
    print(self.x)        # ✅ 10 출력됨
```

#### 8.6.2 우리 구현에서의 안전성

| 작업 | 안전성 | 이유 |
|------|--------|------|
| `self.세그먼트차단종목` 읽기 | ✅ 안전 | 객체 속성 접근은 항상 동작 |
| `self.세그먼트차단종목` 쓰기 | ✅ 안전 | 객체 속성 수정은 항상 동작 |
| `self._세그먼트차단_마지막날짜` 읽기/쓰기 | ✅ 안전 | 객체 속성 접근/수정 |
| `_오늘날짜` 정의 및 사용 | ✅ 안전 | exec 내부에서만 사용됨 |
| `_이미차단됨` 정의 및 사용 | ✅ 안전 | exec 내부에서만 사용됨 |
| `매수` 변수 수정 | ✅ 안전 | 이미 Strategy()에서 정의됨 |

**결론: 우리 구현에서 사용하는 모든 작업은 Python의 표준 동작에서 안전합니다.**

#### 8.6.3 잠재적 위험 요소 (없음)

현재 구현에서 식별된 잠재적 문제점은 **없습니다**:

1. ✅ `self`는 항상 `locals()`에 포함됨
2. ✅ 객체 속성 (`self.속성`) 접근/수정은 `exec()` 내에서 항상 동작
3. ✅ 부모 클래스에서 초기화된 속성은 자식 클래스에서 항상 접근 가능
4. ✅ `compile()` + `exec()` 조합은 STOM 시스템 전체에서 이미 사용 중인 검증된 패턴

---

### 8.7 검증 방법

#### 8.7.1 간단한 테스트 코드

실전 거래 전에 아래 코드로 동작을 검증할 수 있습니다:

```python
# 테스트 코드 (실전 거래 전 검증용)
class TestStrategy:
    def __init__(self):
        # 인프라 변수 초기화 (실제 엔진과 동일)
        self.세그먼트차단종목 = {}
        self._세그먼트차단_마지막날짜 = 0
        self.index = 20260109093000000

    def Strategy(self):
        # 실제 Strategy() 메서드와 유사한 환경 구성
        종목코드 = "005930"
        시분초 = 93000
        매수 = True

        # 조건식 코드 (DB에서 로드된 것과 동일한 형태)
        test_code = """
# 날짜 추출
_오늘날짜 = int(str(self.index)[:8])

# 날짜 변경 시 초기화
if _오늘날짜 != self._세그먼트차단_마지막날짜:
    self.세그먼트차단종목 = {}
    self._세그먼트차단_마지막날짜 = _오늘날짜

# 이미 차단된 종목 확인
_이미차단됨 = (종목코드, _오늘날짜) in self.세그먼트차단종목
if _이미차단됨:
    매수 = False
    print(f"  → 이미 차단된 종목: {종목코드}")

# 차단 시 기록 (테스트용으로 항상 차단)
if (종목코드, _오늘날짜) not in self.세그먼트차단종목:
    self.세그먼트차단종목[(종목코드, _오늘날짜)] = 시분초
    print(f"  → 차단 목록에 추가: {종목코드}")
"""
        exec(compile(test_code, '<string>', 'exec'))
        print(f"매수 결과: {매수}")
        print(f"차단 목록: {self.세그먼트차단종목}")
        print()

# 테스트 실행
print("=== 테스트 시작 ===\n")
t = TestStrategy()

print("[1차 호출] 첫 번째 매수 시도")
t.Strategy()

print("[2차 호출] 같은 종목 재매수 시도")
t.Strategy()

print("[3차 호출] 같은 종목 또 다시 시도")
t.Strategy()
```

**예상 출력:**

```
=== 테스트 시작 ===

[1차 호출] 첫 번째 매수 시도
  → 차단 목록에 추가: 005930
매수 결과: True
차단 목록: {('005930', 20260109): 93000}

[2차 호출] 같은 종목 재매수 시도
  → 이미 차단된 종목: 005930
매수 결과: False
차단 목록: {('005930', 20260109): 93000}

[3차 호출] 같은 종목 또 다시 시도
  → 이미 차단된 종목: 005930
매수 결과: False
차단 목록: {('005930', 20260109): 93000}
```

#### 8.7.2 실전 거래 로그 확인

실전 거래 시작 후 로그에서 다음을 확인:

1. **차단 목록 추가 확인**: 세그먼트 필터에서 차단된 종목이 `self.세그먼트차단종목`에 추가되는지
2. **재매수 차단 확인**: 동일 종목 재매수 시도 시 즉시 차단되는지
3. **날짜 변경 초기화 확인**: 다음 날 거래 시작 시 차단 목록이 초기화되는지

---

### 8.8 전체 동작 흐름 (상세)

```
┌──────────────────────────────────────────────────────────────────────────────┐
│  [1단계] 전략 엔진 프로세스 시작                                               │
│                                                                              │
│  KiwoomStrategyTick.__init__() 실행                                          │
│  ├── self.buystrategy = None                                                │
│  ├── self.세그먼트차단종목 = {}           ← 인프라 변수 초기화                 │
│  └── self._세그먼트차단_마지막날짜 = 0    ← 인프라 변수 초기화                 │
└──────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌──────────────────────────────────────────────────────────────────────────────┐
│  [2단계] 조건식 로드                                                          │
│                                                                              │
│  SetBuyStg(buytxt) 호출                                                      │
│  ├── buytxt = DB에서 읽은 조건식 문자열 (세그먼트 필터 + 당일 차단 로직 포함)   │
│  ├── get_buy_indi_stg(buytxt) 호출                                          │
│  │   └── compile(buytxt, '<string>', 'exec')                                │
│  └── self.buystrategy = <compiled code object>                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌──────────────────────────────────────────────────────────────────────────────┐
│  [3단계] 실시간 데이터 수신 (반복)                                             │
│                                                                              │
│  KiwoomStrategyMin.Strategy(data) 호출                                       │
│  ├── 데이터 언패킹: 체결시간, 현재가, ..., 종목코드, 종목명, ... = data        │
│  ├── 시분초 = int(str(체결시간)[8:] + '00')                                  │
│  ├── 매수 = True                                                            │
│  │                                                                          │
│  └── exec(self.buystrategy)  ← 조건식 실행                                   │
│      │                                                                       │
│      ├── [당일 차단 로직] _오늘날짜 = int(str(self.index)[:8])               │
│      ├── [당일 차단 로직] 날짜 변경 시 self.세그먼트차단종목 = {} 초기화       │
│      ├── [당일 차단 로직] _이미차단됨 = (종목코드, _오늘날짜) in self.세그먼트차단종목
│      ├── [당일 차단 로직] if _이미차단됨: 매수 = False                        │
│      ├── [세그먼트 필터] 세그먼트별 조건 평가...                              │
│      └── [당일 차단 로직] if not 매수: self.세그먼트차단종목에 기록            │
└──────────────────────────────────────────────────────────────────────────────┘
                                    ↓
┌──────────────────────────────────────────────────────────────────────────────┐
│  [4단계] 매수 결정                                                            │
│                                                                              │
│  if 매수:                                                                    │
│      self.Buy(종목코드, 종목명, 매수수량, ...)  ← 주문 실행                   │
│  else:                                                                       │
│      pass  ← 매수 스킵 (세그먼트 필터 또는 당일 차단에 의해)                   │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

### 8.9 검증 결과 요약

| 항목 | 상태 | 코드 위치 | 비고 |
|------|------|----------|------|
| 인프라 변수 초기화 (실전) | ✅ 완료 | `kiwoom_strategy_tick.py:52-57` | 부모 클래스 __init__ |
| 인프라 변수 초기화 (백테스트) | ✅ 완료 | 4개 틱 엔진 | 동일한 패턴 |
| 상속 구조 | ✅ 정상 | `KiwoomStrategyMin(KiwoomStrategyTick)` | Python 표준 |
| exec() 내 self 접근 | ✅ 가능 | Python 기본 동작 | 항상 보장됨 |
| 객체 속성 읽기/쓰기 | ✅ 가능 | Python 기본 동작 | exec() 내에서 동작 |
| 코드 제너레이터 | ✅ 정상 | `code_generator.py:700-769` | 당일 차단 코드 생성 |
| 잠재적 문제점 | ✅ 없음 | - | 모든 작업이 안전 |

---

## 9. 향후 개선 방향

### 9.1 단기 개선

- [ ] 차단 통계 로깅 추가
- [ ] 차단 종목 목록 UI 표시

### 9.2 중장기 개선

- [ ] 세그먼트별 차단 정책 세분화
- [ ] 차단 해제 조건 추가 (예: 급등 시)
- [ ] 차단 이력 데이터베이스 저장

---

## 10. 예측-실제 괴리 근본 원인 분석 (2026-01-10)

### 10.1 발견된 새로운 괴리

당일 재매수 차단 기능 구현 후에도 예측과 실제 사이에 새로운 괴리가 발생했습니다:

| 구분 | 값 | 비고 |
|------|-----|------|
| 원본 백테스팅 | 5,087건 | Min_B_Study_251227 |
| 세그먼트 예측 | 1,497건 | 29.4% 잔여 |
| **실제 필터 백테스팅** | **753건** | **14.8% 잔여** |
| 괴리 | **-744건** | **예측 대비 49.6% 적음** |

### 10.2 근본 원인: 세그먼트 필터 평가 시점의 차이

#### 10.2.1 예측 로직의 한계

**세그먼트 예측 계산 방식** (`segment_outputs.py:99`):
```python
remaining_trades = total_trades - int(global_best.get('excluded_trades', 0))
```

이 계산은:
1. 원본 백테스팅의 5,087건 거래 기준
2. 각 거래를 **독립적으로** 세그먼트 필터 평가
3. 필터 통과 = 1,497건 예측

**핵심 문제**: 예측은 각 거래를 **시간 순서 무관하게 독립적으로** 평가합니다.

#### 10.2.2 실제 실행의 동작

**실제 필터 백테스팅에서는**:
1. 세그먼트 필터가 **모든 틱(tick)**에서 평가됨
2. 원본 조건을 통과하지 못한 틱에서도 세그먼트 필터는 평가됨
3. 세그먼트 필터 실패 시 당일 재매수 차단 발동
4. **이후 같은 종목은 당일 전체 차단**

```
실제 실행 흐름:
┌─────────────────────────────────────────────────────────────────┐
│ 틱 T1 (09:25) - 원본 조건 실패, 세그먼트 필터 실패              │
│   → 원본 백테스팅에 없음 (원본 조건 실패)                       │
│   → 당일 재매수 차단 발동! (세그먼트 필터 실패)                 │
├─────────────────────────────────────────────────────────────────┤
│ 틱 T2 (09:34) - 원본 조건 통과, 세그먼트 필터 통과              │
│   → 원본 백테스팅에 있음 (1 of 5,087)                          │
│   → 세그먼트 예측에 있음 (1 of 1,497)                          │
│   → 실제: 당일 차단으로 인해 거래 불가! ← 괴리 발생            │
└─────────────────────────────────────────────────────────────────┘
```

#### 10.2.3 구체적 사례: 현대힘스 2025-09-05

| 데이터셋 | 거래 수 | 시간 |
|---------|--------|------|
| 원본 백테스팅 | 3건 | 09:34, 10:11, 10:48 |
| 세그먼트 예측 | 2건 | 09:34, 10:11 (통과 예상) |
| **실제 필터** | **0건** | **해당 날짜 거래 없음!** |

**분석**:
- 09:34 이전에 세그먼트 필터가 실패한 틱이 존재
- 해당 틱에서 당일 재매수 차단 발동
- 09:34, 10:11 모두 차단됨 (세그먼트 필터 통과 여부와 무관)

### 10.3 데이터 분석 결과

```
=== 원본 백테스팅 (5,087건) ===
총 거래 수: 5,087
고유 종목+날짜 수: 4,758
중복 종목+날짜 조합: 289개 (같은 날 2회 이상 거래)

=== 세그먼트 예측 (1,497건) ===
총 거래 수: 1,497
고유 종목+날짜 수: 1,465
중복 종목+날짜 조합: 31개

=== 실제 필터 (753건) ===
총 거래 수: 753
고유 종목+날짜 수: 732
중복 종목+날짜 조합: 20개
```

### 10.4 해결 방안

#### 10.4.1 방안 A: 현상 인정 (권장 - 단기)

**설명**: 예측값은 "상한선(upper bound)"으로 해석

**장점**:
- 코드 수정 불필요
- 보수적 추정으로 안전

**단점**:
- 예측 정확도 낮음

#### 10.4.2 방안 B: 당일 차단 기록 위치 변경 (권장 - 중기)

**현재 코드 흐름**:
```python
매수 = True
# 1. 당일 차단 체크
if _이미차단됨:
    매수 = False
# 2. 세그먼트 필터 평가
if segment_fails:
    매수 = False
# 3. 당일 차단 기록 ← 여기서 기록 (원본 조건 체크 전!)
if not 매수:
    record()
# 4. 원본 조건 평가
if not original_condition:
    매수 = False
```

**개선 제안**:
```python
매수 = True
_segment_blocked = False
# 1. 당일 차단 체크
if _이미차단됨:
    매수 = False
# 2. 세그먼트 필터 평가
if segment_fails:
    매수 = False
    _segment_blocked = True
# 3. 원본 조건 평가
if not original_condition:
    매수 = False
# 4. 당일 차단 기록 (원본 조건 통과 시에만)
if _segment_blocked and original_condition_passed:  # 수정!
    record()
```

**장점**:
- 예측-실제 일치율 개선
- "실제 거래 기회"에서만 차단 발동

**단점**:
- 코드 구조 변경 필요
- 더 많은 거래가 실행됨 (수익/손실 모두 증가 가능)

#### 10.4.3 방안 C: 예측 로직 개선 (장기)

**설명**: 예측 계산 시 당일 차단 시뮬레이션 추가

**구현 방법**:
1. 원본 백테스팅의 모든 거래를 시간순 정렬
2. 각 종목+날짜 그룹에서:
   - 첫 거래가 세그먼트 필터 실패 → 이후 모든 거래 차단
   - 첫 거래가 세그먼트 필터 통과 → 해당 거래만 카운트
3. 수정된 예측 계산 적용

**장점**:
- 가장 정확한 예측 가능

**단점**:
- 원본 백테스팅에 없는 틱 정보 필요 (완벽한 시뮬레이션 불가)
- 복잡한 구현

### 10.5 결론 및 권장사항

1. **단기**: 방안 A 적용 - 예측을 상한선으로 해석
2. **중기**: 방안 B 검토 - 차단 기록 위치 변경
3. **문서화**: 예측과 실제의 차이점 명시

**핵심 교훈**:
> 세그먼트 필터의 당일 재매수 차단은 **모든 틱**에서 동작합니다.
> 원본 백테스팅에 나타나지 않는 틱에서도 차단이 발동될 수 있으며,
> 이로 인해 예측보다 적은 거래가 실행됩니다.

---

## 11. 관련 문서

- [세그먼트 필터 예측-실제 괴리 분석](../SystemAnalysis/20260108_Segment_Filter_Prediction_vs_Actual_Discrepancy_Analysis.md)
- [세그먼트 필터 조건식 통합 가이드](Segment_Filter_Condition_Integration_Guide.md)
- [세그먼트 필터 검증 체크리스트](Segment_Filter_Verification_Checklist.md)

---

## 12. 변경 이력

| 날짜 | 버전 | 변경 내용 |
|------|------|----------|
| 2026-01-09 | 1.0 | 최초 작성 |
| 2026-01-09 | 1.1 | 실전 거래 동작 원리 간략 섹션 추가 (섹션 8) |
| 2026-01-09 | 2.0 | 실전 거래 동작 원리 대폭 확장 - Python exec() 동작 원리, 상속 구조, 변수 해석, 잠재적 문제점 분석, 검증 방법 추가 |
| 2026-01-10 | 3.0 | 예측-실제 괴리 근본 원인 분석 추가 (섹션 10) - 세그먼트 필터 평가 시점 차이, 구체적 사례, 해결 방안 제시 |
