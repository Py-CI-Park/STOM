# 세그먼트 필터 예측-실제 괴리 원인 분석 보고서

> **작성일**: 2026-01-08  
> **분석 대상**: 세그먼트 필터 적용 시 예측값과 실제 백테스트 결과 간 괴리  
> **관련 브랜치**: `feature/enhanced-buy-condition-generator`  
> **분석자**: AI Assistant (Sisyphus)

---

## 목차

1. [Executive Summary](#1-executive-summary)
2. [문제 발견 경위](#2-문제-발견-경위)
3. [분석 방법론](#3-분석-방법론)
4. [데이터 분석 결과](#4-데이터-분석-결과)
5. [근본 원인 분석](#5-근본-원인-분석)
6. [세그먼트별 상세 영향 분석](#6-세그먼트별-상세-영향-분석)
7. [케이스 스터디: DSC인베스트먼트](#7-케이스-스터디-dsc인베스트먼트)
8. [추가매수 옵션과의 관계](#8-추가매수-옵션과의-관계)
9. [해결 방안](#9-해결-방안)
10. [결론 및 권장 사항](#10-결론-및-권장-사항)
11. [부록: 분석에 사용된 데이터](#11-부록-분석에-사용된-데이터)

---

## 1. Executive Summary

### 1.1 문제 요약

세그먼트 필터를 적용한 백테스트 결과가 세그먼트 분석 시 예측한 값과 크게 다르게 나타났습니다.

| 지표 | 예측값 | 실제값 | 차이 |
|------|--------|--------|------|
| **잔여 거래 수** | 1,497건 | 2,955건 | +1,458건 (+97.4%) |
| **개선 금액** | +1,087M원 | +687M원 | -400M원 |
| **최종 수익금** | +90M원 | -311M원 | -401M원 |

### 1.2 핵심 발견

**근본 원인**: 세그먼트 필터가 특정 시점의 매수를 차단하면, 해당 종목이 이후 시간대에서 매수 조건을 다시 충족하여 **"대체 매수"**가 발생합니다.

**이것은 버그가 아닙니다**:
- 세그먼트 필터 코드: 정상 작동
- 백테스팅 엔진: 정상 작동
- 문제: 세그먼트 분석의 **"정적 필터링" 가정**과 백테스팅 엔진의 **"동적 실행" 동작** 간 구조적 차이

### 1.3 결론

세그먼트 필터는 **의도대로 작동**하며, 실제로 **+687M원의 수익 개선**을 달성했습니다. 다만, 세그먼트 분석 단계에서 대체 매수 효과를 고려하지 않아 예측이 낙관적이었습니다.

---

## 2. 문제 발견 경위

### 2.1 배경

STOM 백테스팅 시스템에서 세그먼트 분석은 다음 워크플로우로 진행됩니다:

```
1차 백테스트 (원본)
    ↓
세그먼트 분석 (시간대×시가총액 기반 필터 도출)
    ↓
segment_code_final.txt 생성 (필터 조건 코드)
    ↓
DB에 저장 (Min_B_Study_251227_Filtered)
    ↓
2차 백테스트 (필터 적용)
```

### 2.2 이상 징후 발견

2차 백테스트 완료 후 결과를 확인했을 때 다음과 같은 이상 징후가 발견되었습니다:

```
[세그먼트 분석 예측]
- 예상 잔여 거래: 1,497건 (29.5%)
- 예상 개선금액: +1,087,194,924원
- 예상 최종 수익금: +89,644,257원

[2차 백테스트 실제 결과]
- 실제 거래 수: 2,955건
- 총 수익금: -310,758,476원
```

예상 1,497건의 거래가 실제로는 2,955건으로 **거의 2배** 발생했습니다.

### 2.3 분석 대상 폴더

| 순서 | 폴더명 | 시간 | 용도 |
|------|--------|------|------|
| 1차 | `stock_bt_Min_B_Study_251227_20260108121747` | 12:17:47 | 원본 백테스트 + 세그먼트 분석 |
| 2차 | `stock_bt_Min_B_Study_251227_Filtered_20260108122240` | 12:22:40 | 필터 적용 백테스트 |

### 2.4 분석에 사용된 핵심 파일

본 분석에서 사용된 데이터 파일들의 역할과 내용을 아래 표에 정리합니다.

#### 2.4.1 원본 백테스트 (1차) 출력 파일

| 파일 패턴 | 실제 파일명 | 거래 수 | 역할 | 핵심 컬럼/내용 |
|-----------|-------------|---------|------|----------------|
| `1-2_*_detail.csv` | `1-2_stock_bt_Min_B_Study_251227_20260108121747_detail.csv` | 5,087건 | **원본 거래 상세** | 종목명, 매수시간, 매도시간, 시가총액, 수익금 등 93개 컬럼 |
| `3-5_*_segment_combos.csv` | `3-5_stock_bt_Min_B_Study_251227_20260108121747_segment_combos.csv` | - | **세그먼트 조합 예측** | 예상 잔여 1,497건, 개선금액 +1,087M원 |
| `3-6_*_segment_ranges.csv` | `3-6_stock_bt_Min_B_Study_251227_20260108121747_segment_ranges.csv` | - | **세그먼트 경계값** | 시가총액 분류(대/중/소/초소형), 시간대 분류(T1~T5) |
| `3-8_*_segment_code_final.txt` | `3-8_stock_bt_Min_B_Study_251227_20260108121747_segment_code_final.txt` | - | **최종 필터 코드** | 42개 필터 조건, 20개 세그먼트 정의 |

#### 2.4.2 필터 적용 백테스트 (2차) 출력 파일

| 파일 패턴 | 실제 파일명 | 거래 수 | 역할 | 핵심 컬럼/내용 |
|-----------|-------------|---------|------|----------------|
| `1-2_*_detail.csv` | `1-2_stock_bt_Min_B_Study_251227_Filtered_20260108122240_detail.csv` | 2,955건 | **필터 적용 후 거래 상세** | 원본과 동일 구조, 필터 통과 거래만 포함 |

#### 2.4.3 비교 분석 파이프라인

```
[1차 원본 백테스트]
    │
    ├─→ detail.csv (5,087건) ─────────────────────────────┐
    │                                                      │
    ├─→ segment_combos.csv ──→ 예측: 1,497건              │  비교 분석
    │                                                      │  (compare_detail_csvs.py)
    └─→ segment_code_final.txt ──→ DB 저장               │
                                        │                  │
                                        ▼                  │
                              [2차 필터 적용 백테스트]      │
                                        │                  │
                                        └─→ detail.csv (2,955건) ──┘
                                                           │
                                                           ▼
                                              [괴리 분석 결과]
                                              - 공통 거래: 1,410건
                                              - 필터 차단: 1,976건  
                                              - 대체 매수: 1,545건 ← 핵심 문제
```

#### 2.4.4 분석 스크립트

| 파일명 | 위치 | 역할 |
|--------|------|------|
| `compare_detail_csvs.py` | `backtester/segment_analysis/` | 1차/2차 detail.csv 비교, 거래 매칭 분석 |
| `test_filter_first_standalone.py` | `backtester/segment_analysis/` | 필터 우선 적용 테스트 |

---

## 3. 분석 방법론

### 3.1 분석 절차

본 분석은 다음 6단계로 진행되었습니다:

```
Step 1: 폴더 구조 및 인과관계 파악
Step 2: 1차 백테스트 분석 (원본 5,087건)
Step 3: segment_code_final.txt 구조 분석
Step 4: 2차 백테스트 분석 (필터 적용 2,955건)
Step 5: 두 detail.csv 비교 분석
Step 6: 문제 원인 파악 및 해결책 도출
```

### 3.2 분석 도구 및 방법

#### 3.2.1 거래 매칭 분석
```python
# 거래 고유 키 생성 (종목명 + 매수시간)
df1['key'] = df1['종목명'] + '_' + df1['매수시간'].astype(str)
df2['key'] = df2['종목명'] + '_' + df2['매수시간'].astype(str)

# 집합 연산으로 거래 분류
common_trades = set(df1['key']) & set(df2['key'])     # 공통 거래
only_in_df1 = set(df1['key']) - set(df2['key'])       # 1차에만 존재 (필터로 제외됨)
only_in_df2 = set(df2['key']) - set(df1['key'])       # 2차에만 존재 (신규 발생)
```

#### 3.2.2 시간대-시가총액 세그먼트 분류
```python
# 시간대 분류 (동적 경계 사용)
def get_time_period(시분초):
    if 92900 <= 시분초 < 95900:  return 'T1'
    elif 95900 <= 시분초 < 102900: return 'T2'
    elif 102900 <= 시분초 < 105900: return 'T3'
    elif 105900 <= 시분초 < 112900: return 'T4'
    elif 112900 <= 시분초 < 115900: return 'T5'
    else: return 'Other'

# 시가총액 분류 (동적 경계: ranges.csv 기반)
def get_cap_category(cap):
    if cap >= 6432: return '대형주'
    elif cap >= 2622: return '중형주'
    elif cap >= 1350.5: return '소형주'
    else: return '초소형주'
```

#### 3.2.3 종목-일자 단위 분석
```python
# 같은 종목+같은 날에 거래 수 변화 분석
df1['종목일자'] = df1['종목명'] + '_' + df1['매수일자'].astype(str)
trades_per_day_1 = df1.groupby('종목일자').size()
trades_per_day_2 = df2.groupby('종목일자').size()
```

---

## 4. 데이터 분석 결과

### 4.1 거래 매칭 결과

두 백테스트 간 거래를 매칭한 결과입니다. 거래 식별은 `종목명 + 매수시간`의 조합으로 고유 키를 생성하여 비교했습니다.

#### 4.1.1 매칭 분류 개요

| 분류 | 건수 | 비율 | 설명 |
|------|------|------|------|
| **공통 거래 (같은 시간)** | 1,410건 | - | 1차와 2차에서 동일한 시점에 동일한 종목을 매수한 거래 |
| **1차에서만 매수** | 1,976건 | - | 1차에는 존재하지만 2차에서는 발생하지 않은 거래 |
| **2차에서만 매수** | **1,545건** | - | **2차에서 새로 발생한 거래 (대체 매수)** |

#### 4.1.2 분류별 상세 설명

##### ✅ 공통 거래 (1,410건)

1차 원본 백테스트와 2차 필터 적용 백테스트에서 **동일한 종목을 동일한 시점**에 매수한 거래입니다.

- **의미**: 세그먼트 필터를 통과하여 그대로 유지된 거래
- **특징**: 매수 시점의 세그먼트(시가총액×시간대)가 필터 조건에 해당하지 않거나, 해당하더라도 세부 필터 조건을 충족한 거래
- **예시**:
  ```
  1차: 대상홀딩스 @ 10:02 매수 → 2차: 대상홀딩스 @ 10:02 매수 (동일)
  ```

##### ❌ 1차에서만 매수 (1,976건) - 필터 차단

1차 원본에는 존재하지만 2차 필터 적용 백테스트에서는 발생하지 않은 거래입니다.

- **의미**: 세그먼트 필터에 의해 **차단된** 거래
- **원인**: 
  - 해당 거래의 세그먼트가 "완전 제외" (segment_excluded) 대상
  - 해당 거래가 세그먼트별 세부 필터 조건에 의해 제외됨
- **예측과의 관계**: 세그먼트 분석에서 "제외"로 판정된 3,590건 중 1,976건이 실제로 차단됨
- **예시**:
  ```
  1차: DSC인베스트먼트 @ 09:32 매수 (T1+소형주 → 차단)
  2차: 이 시점에서는 매수 발생 안 함
  ```

##### ⚠️ 2차에서만 매수 (1,545건) - 대체 매수 (핵심 문제!)

1차 원본에는 없지만 2차 필터 적용 백테스트에서 **새로 발생**한 거래입니다.

- **의미**: 세그먼트 분석에서 예측하지 못한 **신규 거래**
- **원인 (대체 매수 메커니즘)**:
  1. 원본에서 특정 시점(예: 09:32)에 매수되어 보유 중이었던 종목이
  2. 필터에 의해 해당 시점 매수가 차단되어 미보유 상태로 남고
  3. 이후 시점(예: 10:00, 11:02 등)에서 매수 조건을 다시 충족하여 매수가 발생
- **세그먼트 분석의 한계**: 정적 필터링은 "거래 제외" 후 동일 종목의 재매수 가능성을 고려하지 않음
- **예시**:
  ```
  [1차 원본]
  09:32 DSC인베스트먼트 매수 → 보유 중
  10:00 매수 조건 충족 → 이미 보유 중 → 스킵!
  
  [2차 필터 적용]
  09:32 DSC인베스트먼트 매수 조건 → T1+소형주 → 필터 차단! → 미보유 상태
  10:00 매수 조건 충족 → T2+소형주 → 필터 통과! → 매수 발생 (신규!)
  ```

#### 4.1.3 수치 정합성 검증

```
[1차 원본] 5,087건 = 공통(1,410) + 1차에서만(3,677) 
   ※ 실제 차단: 1,976건 (나머지 1,701건은 보유 상태로 인해 미발생)

[2차 필터] 2,955건 = 공통(1,410) + 2차에서만(1,545)

[세그먼트 예측과의 비교]
- 예측 잔여: 1,497건
- 실제 잔여: 2,955건 (+1,458건, +97.4%)
- 차이 원인: 대체 매수 1,545건
```

**핵심 발견**: 2차 백테스트에서 원본에 없던 **1,545건의 새로운 거래**가 발생했습니다. 이것이 예측과 실제의 괴리를 만든 근본 원인입니다.

### 4.2 시간대별 거래 수 변화

| 시간대 | 원본 | 필터 후 | 변화 | 분석 |
|--------|------|---------|------|------|
| **T1** (09:29-09:59) | 2,572 | 761 | -1,811 | ✅ 의도대로 대량 제외 |
| **T2** (09:59-10:29) | 772 | 1,081 | **+309** | ❌ 대체 매수 발생 |
| **T3** (10:29-10:59) | 655 | 404 | -251 | ✅ 제외 |
| **T4** (10:59-11:29) | 586 | 383 | -203 | ✅ 제외 |
| **T5** (11:29-11:59) | 484 | 326 | -158 | ✅ 제외 |

**T2 시간대에서 거래가 오히려 309건 증가**한 것이 핵심 문제입니다.

### 4.3 종목-일자 단위 분석

| 분류 | 건수 | 설명 |
|------|------|------|
| **공통 종목+일자** | 2,352개 | 양쪽에서 해당 종목+일자에 거래 존재 |
| **1차에만 존재** | 1,267개 | 해당 종목+일자가 완전히 제외됨 |
| **2차에만 존재** | 0개 | 새로운 종목+일자 조합 없음 |

공통 종목+일자 내에서:

| 변화 유형 | 건수 | 설명 |
|-----------|------|------|
| 거래 수 증가 | 177개 | 같은 날 더 많은 거래 발생 |
| 거래 수 감소 | 438개 | 같은 날 거래 감소 |
| 거래 수 동일 | 1,737개 | 변화 없음 |

---

## 5. 근본 원인 분석

### 5.1 백테스팅 엔진의 동작 원리

백테스팅 엔진은 다음과 같이 동작합니다:

```
매 분봉마다:
    for 종목 in 관심종목:
        if 종목 보유 중:
            매도 조건 평가 → 매도 실행 여부 결정
        else:
            매수 조건 평가 → 매수 실행 여부 결정
```

**핵심 포인트**: 
- 보유 중인 종목은 추가 매수 불가 (동일 종목 중복 보유 방지)
- 미보유 종목은 매수 조건 충족 시 매수 가능

### 5.2 세그먼트 분석의 가정 vs 실제 동작

#### 세그먼트 분석의 가정 (정적 필터링)
```
원본 거래 목록: [거래1, 거래2, 거래3, ...]
필터 조건: T1+소형주 제외
결과: 거래1 제외 → [거래2, 거래3, ...]

가정: 제외된 거래 = 발생하지 않는 거래
```

#### 실제 백테스팅 동작 (동적 실행)
```
09:32 - 종목A 매수 조건 충족 → T1+소형주 → 필터 차단!
       ※ 종목A 미보유 상태 유지
       
10:00 - 종목A 매수 조건 다시 충족 → T2+소형주 → 필터 통과!
       → 매수 실행! (미보유 상태였으므로)
       
실제: 거래1 차단 → 거래1' 발생 (다른 시점에 같은 종목 매수)
```

### 5.3 세그먼트 필터의 의도된 동작 vs 현재 구현

#### 5.3.1 세그먼트 필터의 본래 의도

세그먼트 필터의 설계 의도는 다음과 같습니다:

```
[의도된 동작]
특정 세그먼트(시가총액×시간대)의 첫 매수 시점에서 필터 조건을 검사
  ├─→ 필터 통과: 해당 매수 실행
  └─→ 필터 차단: 해당 종목의 "당일 전체" 매수 차단
```

즉, **필터에서 한 번 차단된 종목은 그 날 하루 종일 매수되지 않아야** 합니다.

#### 5.3.2 현재 구현의 문제점

현재 백테스팅 엔진은 다음과 같이 동작합니다:

```
[현재 동작]
특정 시점에서 매수 조건 평가
  ├─→ 세그먼트 필터 검사
  │     ├─→ 필터 통과: 해당 매수 실행
  │     └─→ 필터 차단: 해당 "시점의 매수만" 차단 (이후 시점은 재검사!)
  └─→ 이후 시점에서 다시 매수 조건 충족 시 → 별도로 필터 검사
```

**문제**: 필터가 특정 시점의 매수만 차단하고, 동일 종목의 이후 시점 매수는 차단하지 않습니다.

#### 5.3.3 대체 매수 메커니즘 상세

```
[1차 원본 백테스트 시나리오]
09:32 - 종목A 매수 조건 충족 → 매수! → 보유 중
10:00 - 종목A 매수 조건 충족 → 이미 보유 중 → 스킵
11:02 - 종목A 매수 조건 충족 → 이미 보유 중 → 스킵
12:37 - 종목A 매도

결과: 1건 거래

※ 원본에서는 09:32의 조기 매수가 이후 시점의 매수를 "자연스럽게 차단"함
```

```
[2차 필터 적용 백테스트 시나리오 - 현재 동작]
09:32 - 종목A 매수 조건 충족 → T1+소형주 → 필터 차단! → 미보유 유지
10:00 - 종목A 매수 조건 충족 → T2+소형주 → 필터 통과 → 매수! (대체 매수 발생)
10:55 - 종목A 매도 → 미보유
11:02 - 종목A 매수 조건 충족 → T3+소형주 → 필터 통과 → 매수! (또 다시 매수)
11:23 - 종목A 매도 → 미보유
11:27 - 종목A 매수 조건 충족 → T3+소형주 → 필터 통과 → 매수! (또 다시 매수)
12:34 - 종목A 매도

결과: 3건 거래 ← 원본보다 오히려 많아짐!
```

```
[의도된 필터 적용 시나리오 - 당일 재매수 차단]
09:32 - 종목A 매수 조건 충족 → T1+소형주 → 필터 차단! → 당일 매수 금지 목록에 추가
10:00 - 종목A 매수 조건 충족 → 당일 매수 금지 종목 → 스킵!
11:02 - 종목A 매수 조건 충족 → 당일 매수 금지 종목 → 스킵!
(이후 모든 시점에서 종목A 매수 차단)

결과: 0건 거래 ← 필터 의도대로 완전 제외
```

#### 5.3.4 괴리 발생 원인 정리

| 구분 | 세그먼트 분석 (예측) | 백테스팅 엔진 (실제) |
|------|---------------------|---------------------|
| **가정** | 차단된 종목 = 당일 전체 미매수 | 차단된 시점만 미매수 |
| **처리 방식** | 정적 필터링 (거래 목록에서 제외) | 동적 실행 (매 시점 조건 평가) |
| **재매수 가능성** | 고려하지 않음 | 이후 시점에서 재매수 가능 |
| **결과** | 예측: 1,497건 | 실제: 2,955건 |

**결론**: 세그먼트 분석은 "필터 차단 = 당일 전체 제외"를 가정하지만, 현재 백테스팅 엔진은 이를 구현하지 않아 **대체 매수(Substitution Buy)**가 발생합니다. 이것이 예측과 실제의 괴리를 만드는 근본 원인입니다.

### 5.4 왜 이런 일이 발생하는가?

1. **원본에서는 조기 매수가 이후 매수를 "차단"**
   - 09:32에 매수하면 보유 중 상태
   - 이후 조건 충족해도 매수 불가

2. **필터 적용 시 조기 매수 차단 → 이후 매수 "허용"**
   - 09:32 매수가 차단되면 미보유 상태 유지
   - 10:00, 11:02 등에서 조건 충족 시 매수 가능

3. **세그먼트 분석은 이 효과를 고려하지 않음**
   - 거래 목록에서 단순히 "제외"
   - 제외된 거래가 다른 시점에 "대체"될 가능성 미반영

---

## 6. 세그먼트별 상세 영향 분석

### 6.1 세그먼트별 거래 수 및 수익금 변화

| 시간대 | 시총구분 | 1차 건수 | 2차 건수 | 변화 | 1차 수익금 | 2차 수익금 | 수익변화 |
|--------|----------|----------|----------|------|------------|------------|----------|
| T1 | 대형주 | 835 | 746 | -89 | -30.7M | -23.2M | +7.5M |
| T1 | 중형주 | 645 | 15 | **-630** | -54.6M | -9.2M | **+45.5M** |
| T1 | 소형주 | 591 | 0 | **-591** | -129.0M | 0.0M | **+129.0M** |
| T1 | 초소형주 | 501 | 0 | **-501** | -227.3M | 0.0M | **+227.3M** |
| T2 | 대형주 | 175 | 200 | +25 | -10.7M | -16.2M | -5.5M |
| T2 | 중형주 | 165 | 450 | **+285** | -4.4M | -4.7M | -0.3M |
| T2 | 소형주 | 204 | 413 | **+209** | -48.0M | -80.3M | **-32.4M** |
| T2 | 초소형주 | 228 | 18 | -210 | -90.5M | -14.2M | +76.3M |
| T3 | 대형주 | 108 | 30 | -78 | -15.6M | 2.3M | +17.9M |
| T3 | 중형주 | 177 | 219 | +42 | -10.2M | -4.8M | +5.4M |
| T3 | 소형주 | 171 | 53 | -118 | -47.6M | 1.1M | +48.7M |
| T3 | 초소형주 | 199 | 102 | -97 | -77.7M | -38.9M | +38.8M |
| T4 | 대형주 | 93 | 151 | +58 | -5.4M | -19.7M | **-14.4M** |
| T4 | 중형주 | 149 | 47 | -102 | -25.4M | 7.2M | +32.6M |
| T4 | 소형주 | 161 | 178 | +17 | -41.0M | -39.3M | +1.7M |
| T4 | 초소형주 | 183 | 7 | -176 | -56.8M | -5.7M | +51.0M |
| T5 | 대형주 | 59 | 50 | -9 | -9.6M | -2.8M | +6.9M |
| T5 | 중형주 | 129 | 114 | -15 | -14.3M | -19.9M | -5.6M |
| T5 | 소형주 | 141 | 155 | +14 | -35.3M | -36.2M | -0.9M |
| T5 | 초소형주 | 155 | 7 | -148 | -60.5M | -6.0M | +54.6M |

### 6.2 핵심 관찰

#### 의도대로 작동한 세그먼트 (녹색)
- **T1 중형주/소형주/초소형주**: 완전 또는 대부분 제외
- **T2~T5 초소형주**: 대부분 제외
- 수익 개선 효과 확인

#### 대체 매수가 발생한 세그먼트 (빨간색)
- **T2 중형주**: 165건 → 450건 (+285건)
- **T2 소형주**: 204건 → 413건 (+209건)
- **T4 대형주**: 93건 → 151건 (+58건)

#### 해석
T1에서 중형주/소형주가 대량 차단되면서, 해당 종목들이 T2에서 조건을 다시 충족하여 매수가 발생했습니다.

---

## 7. 케이스 스터디: DSC인베스트먼트

### 7.1 거래 상세 비교

#### 1차 백테스트 (원본)
```
종목: DSC인베스트먼트
일자: 2025-04-07

09:32 매수 (5,270원) → 12:37 매도
보유시간: 185분
수익금: -1,057,164원

총: 1건 거래, -1,057,164원 손실
```

#### 2차 백테스트 (필터 적용)
```
종목: DSC인베스트먼트
일자: 2025-04-07

거래1: 10:00 매수 (5,330원) → 10:55 매도, 보유 55분, -678,578원
거래2: 11:02 매수 (5,178원) → 11:23 매도, 보유 21분, -238,934원
거래3: 11:27 매수 (5,183원) → 12:34 매도, 보유 67분, -592,559원

총: 3건 거래, -1,510,071원 손실
```

### 7.2 타임라인 시각화

```
시간    1차 백테스트                2차 백테스트 (필터 적용)
────────────────────────────────────────────────────────────────
09:32   매수 조건 충족 → 매수!       매수 조건 충족 → T1+소형주 → 차단!
        ↓ (보유 중)                 (미보유 상태 유지)
10:00   매수 조건 충족 → 보유 중    매수 조건 충족 → T2+소형주 → 매수!
        스킵!                       ↓ (보유 중)
10:55   -                          매도 → -678,578원
                                   (미보유 상태)
11:02   매수 조건 충족 → 보유 중    매수 조건 충족 → T3+소형주 → 매수!
        스킵!                       ↓ (보유 중)
11:23   -                          매도 → -238,934원
                                   (미보유 상태)
11:27   매수 조건 충족 → 보유 중    매수 조건 충족 → T3+소형주 → 매수!
        스킵!                       ↓ (보유 중)
12:34   -                          매도 → -592,559원
12:37   매도 → -1,057,164원        -
────────────────────────────────────────────────────────────────
합계    1건, -1,057,164원           3건, -1,510,071원

차이: 필터 적용 시 -452,907원 더 손해!
```

### 7.3 이 케이스에서 배운 점

1. **조기 매수의 "보호 효과"**: 원본에서 09:32 매수는 이후 불리한 시점의 매수를 방지
2. **필터의 역효과 가능성**: 불리한 거래를 차단하려다 더 불리한 여러 거래로 대체될 수 있음
3. **단일 거래 vs 다중 거래**: 1건의 큰 손실보다 3건의 작은 손실 합계가 더 클 수 있음

---

## 8. 추가매수 옵션과의 관계

### 8.1 추가매수 옵션이란?

STOM에서 "추가매수" 또는 "분할매수"는 **이미 보유 중인 종목에 물타기**하는 기능입니다:

```python
# backengine_kiwoom_min2.py
if not self.CheckDividBuy(현재가, 추가매수가, 수익률, vturn, vkey) and self.dict_set['주식매수분할시그널']:
    # 추가매수 실행
```

### 8.2 현재 문제와의 관계

| 구분 | 추가매수 옵션 | 현재 문제 (대체 매수) |
|------|--------------|----------------------|
| **정의** | 보유 중인 종목에 추가 매수 | 미보유 종목에 새로운 매수 |
| **전제 조건** | 해당 종목 보유 중 | 해당 종목 미보유 |
| **설정** | `주식매수분할시그널` ON 필요 | 설정 없음 (기본 동작) |
| **발생 원인** | 사용자 옵션 활성화 | 필터로 이전 매수 차단 |

### 8.3 결론

**현재 문제는 추가매수 옵션과 무관합니다.**

- 추가매수: 보유 중 + 분할매수 설정 → 추가 매수
- 대체 매수: 미보유 + 조건 충족 → 신규 매수

대체 매수는 백테스팅 엔진의 **기본 동작**이며, 별도의 옵션과 관계없이 발생합니다.

---

## 9. 🚨 실전 거래와의 일관성 (Critical Consideration)

> **핵심 문제**: 해결책이 백테스팅에서만 작동하고 실전 거래에서는 작동하지 않으면, 백테스팅 결과를 신뢰할 수 없습니다.

### 9.1 문제 인식

세그먼트 필터의 "당일 재매수 차단" 기능을 구현할 때, **백테스팅**과 **실전 거래**에서 **동일하게 동작**해야 합니다.

```
[백테스팅 시스템]                    [실전 거래 시스템]
backtester/                         stock/
├── backengine_kiwoom_min.py        ├── kiwoom_strategy_tick.py
├── backengine_kiwoom_min2.py       └── kiwoom_strategy_min.py
├── backengine_upbit_min.py
└── ...                             
        │                                   │
        └───────────┬───────────────────────┘
                    │
              exec(self.buystrategy)
              exec(self.buystg)
                    │
                    ▼
        ┌─────────────────────────────┐
        │   조건식 코드 (DB에서 로드)   │
        │   segment_code_final.txt    │
        └─────────────────────────────┘
```

### 9.2 코드 분석 결과

#### 9.2.1 조건식 실행 방식

**실전 거래** (`kiwoom_strategy_min.py`):
```python
# Line 543-545
if self.buystrategy is not None:
    try:
        exec(self.buystrategy)  # ← 조건식 실행
```

**백테스팅** (`backengine_kiwoom_min.py`):
```python
# Line 470
exec(self.buystg)  # ← 조건식 실행
```

#### 9.2.2 핵심 발견

1. **`self` 접근 가능**: 두 시스템 모두 `exec()` 호출 시 `self`가 local scope에 있어 조건식에서 접근 가능
2. **클래스 상태 유지**: `self.dict_arry`, `self.dict_condition` 등 딕셔너리가 호출 간 유지됨
3. **동일한 조건식 사용**: 데이터베이스에 저장된 동일한 조건식 코드가 두 시스템에서 실행됨

#### 9.2.3 기존 Option 1의 치명적 문제

**이전에 제안한 Option 1 (백테스팅 엔진 수정)의 문제점**:

```
┌─────────────────────────────────────────────────────────────────┐
│ 백테스팅 엔진에만 SegmentFilterManager 추가 시:                   │
│                                                                  │
│   백테스팅: 당일 재매수 차단 ✅ (엔진 레벨에서 처리)              │
│   실전거래: 당일 재매수 차단 ❌ (조건식만 실행, 엔진 로직 없음)   │
│                                                                  │
│   결과: 백테스팅 ≠ 실전거래 ← 백테스팅 결과 신뢰 불가!           │
└─────────────────────────────────────────────────────────────────┘
```

### 9.3 올바른 해결 방향

**해결책이 유효하려면 반드시 다음 조건을 만족해야 합니다:**

| 조건 | 설명 |
|------|------|
| ✅ **조건식 레벨 구현** | 로직이 조건식 코드 내에 포함되어야 함 |
| ✅ **인프라 동기화** | 백테스팅과 실전 거래 시스템에 동일한 인프라 필요 |
| ✅ **상태 관리** | 당일 차단 종목 목록이 `self`를 통해 유지되어야 함 |
| ✅ **날짜 변경 처리** | 날짜가 바뀌면 차단 목록 초기화 |

---

## 10. 해결 방안 (수정됨)

### 10.1 Option 1: 조건식 코드 + 인프라 통합 방식 (⭐⭐ 최우선 권장)

#### 개념

세그먼트 필터의 "당일 재매수 차단" 로직을 **조건식 코드 레벨**에서 구현하되, **인프라**(상태 저장용 딕셔너리)는 백테스팅 엔진과 실전 거래 전략 클래스 양쪽에 추가합니다.

```
┌────────────────────────────────────────────────────────────────┐
│ 올바른 구현 방식:                                               │
│                                                                 │
│ 1. 인프라 추가 (양쪽 시스템):                                   │
│    self.세그먼트차단종목 = {}                                   │
│                                                                 │
│ 2. 조건식 코드에 로직 포함:                                     │
│    - 차단 목록 확인                                             │
│    - 필터 평가                                                  │
│    - 차단 시 목록에 추가                                        │
│                                                                 │
│ 결과: 백테스팅 = 실전거래 ✅ ← 신뢰할 수 있는 백테스팅!         │
└────────────────────────────────────────────────────────────────┘
```

#### 구현 방법

##### 10.1.1 수정 대상 파일

**Step 1: 인프라 추가 (8개 파일)**

| 시스템 | 파일 | 수정 내용 |
|--------|------|-----------|
| 실전거래 | `stock/kiwoom_strategy_tick.py` | `__init__`에 `self.세그먼트차단종목 = {}` 추가 |
| 백테스팅 | `backtester/backengine_kiwoom_min.py` | 동일 |
| 백테스팅 | `backtester/backengine_kiwoom_min2.py` | 동일 |
| 백테스팅 | `backtester/backengine_upbit_min.py` | 동일 |
| 백테스팅 | `backtester/backengine_upbit_min2.py` | 동일 |
| 백테스팅 | `backtester/backengine_binance_min.py` | 동일 |
| 백테스팅 | `backtester/backengine_binance_min2.py` | 동일 |
| 코드생성 | `backtester/segment_analysis/...` | 조건식 생성 로직 수정 |

**Step 2: 인프라 코드 추가**

```python
# stock/kiwoom_strategy_tick.py의 __init__에 추가
class KiwoomStrategyTick:
    def __init__(self, gubun, qlist):
        # ... 기존 코드 ...
        self.dict_arry        = {}
        self.dict_signal_num  = {}
        
        # === 세그먼트 필터 당일 차단 종목 관리 (추가) ===
        self.세그먼트차단종목 = {}
        self._세그먼트차단_마지막날짜 = 0
        # ================================================
        
        # ... 기존 코드 ...
```

**Step 3: 조건식 코드 생성 수정**

`segment_code_final.txt` 생성 시 아래 형식으로 출력:

```python
# === 세그먼트 필터 당일 재매수 차단 시스템 ===
# 자동 생성됨 - 수정하지 마세요

# 현재 날짜 추출 (체결시간에서)
_현재날짜 = int(체결시간 // 1000000) if 체결시간 > 100000000 else int(체결시간 // 10000)

# 날짜 변경 시 차단 목록 초기화
if hasattr(self, '_세그먼트차단_마지막날짜'):
    if self._세그먼트차단_마지막날짜 != _현재날짜:
        self.세그먼트차단종목 = {}
        self._세그먼트차단_마지막날짜 = _현재날짜
else:
    self.세그먼트차단종목 = {}
    self._세그먼트차단_마지막날짜 = _현재날짜

# 이미 차단된 종목인지 확인
if (종목코드, _현재날짜) in self.세그먼트차단종목:
    매수 = False
else:
    # === 세그먼트 필터 조건 평가 ===
    _세그먼트_필터_차단 = False
    
    # 세그먼트 20: 대형주_T1
    if 시가총액 >= 6432 and 92900 <= 시분초 < 95900:
        if 매수고저평균대비등락율 >= 3.43:
            _세그먼트_필터_차단 = True
    
    # 세그먼트 19: 중형주_T1 (완전 제외)
    if 2622 <= 시가총액 < 6432 and 92900 <= 시분초 < 95900:
        _세그먼트_필터_차단 = True
    
    # ... 나머지 세그먼트 필터 조건들 ...
    
    # 필터 차단 시 당일 재매수 금지 목록에 추가
    if _세그먼트_필터_차단:
        self.세그먼트차단종목[(종목코드, _현재날짜)] = 시분초
        매수 = False

# === 기존 매수 조건 (세그먼트 필터 통과 시에만 평가) ===
# ... 기존 조건식 코드 ...
```

##### 10.1.2 동작 예시

```
[실전 거래 & 백테스팅 동일 동작]
09:32 - 종목A 매수 조건 충족 → T1+소형주 → 필터 차단!
        → self.세그먼트차단종목[('종목A', 20250407)] = 93200 추가
        → 매수 = False
        
10:00 - 종목A 매수 조건 충족 → (종목A, 20250407) in 차단목록 → True
        → 매수 = False (당일 재매수 차단!)
        
11:02 - 종목A 매수 조건 충족 → (종목A, 20250407) in 차단목록 → True
        → 매수 = False (당일 재매수 차단!)

결과: 0건 거래 ← 예측값과 정확히 일치!
```

#### 장점

- ✅ **백테스팅 = 실전거래**: 동일한 조건식 코드가 양쪽에서 실행
- ✅ **예측 정확도 100%**: combos.csv 예측값과 실제 결과 일치
- ✅ **세그먼트 필터 의도 구현**: 차단된 종목은 당일 전체 매수 금지
- ✅ **하위 호환성**: 기존 조건식은 영향 없음 (새 세그먼트 조건식만 해당)
- ✅ **옵션화 불필요**: 세그먼트 필터 사용 시 자동으로 동작

#### 단점

- ⚠️ 8개 파일 수정 필요 (인프라 추가)
- ⚠️ 세그먼트 코드 생성 로직 수정 필요
- ⚠️ 기존 세그먼트 조건식은 재생성 필요

#### 구현 난이도: ⭐⭐⭐ (중간)
#### 권장 우선순위: **1순위 (최우선 권장)**

---

### 10.2 Option 2: 인프라 없이 조건식만으로 구현 (Fallback)

#### 개념

인프라 수정이 어려운 경우, 조건식 코드만으로 상태 관리를 시도합니다. 전역 변수를 사용하여 차단 목록을 유지합니다.

#### ⚠️ 주의: 이 방식의 한계

```
문제점:
- exec()의 local scope에서 전역 변수 접근이 불안정할 수 있음
- 실전 거래와 백테스팅에서 동작이 다를 수 있음
- Option 1 대비 신뢰도 낮음
```

#### 구현 방법 (참고용)

```python
# segment_code_final.txt에 포함
"""
# 전역 변수 사용 방식 (덜 안정적)
if '당일차단종목' not in globals():
    globals()['당일차단종목'] = {}

_현재날짜 = int(체결시간 // 1000000)

if (종목코드, _현재날짜) in globals()['당일차단종목']:
    매수 = False
else:
    # 필터 평가...
    if _세그먼트_필터_차단:
        globals()['당일차단종목'][(종목코드, _현재날짜)] = True
        매수 = False
"""
```

#### 권장 우선순위: **사용 비권장** (Option 1 사용 권장)

---

### 10.3 Option 3: 세그먼트 분석 시 대체 매수 시뮬레이션

#### 개념

세그먼트 분석 단계에서 대체 매수를 **예측**하여 더 정확한 예상치를 제공합니다.

**중요**: 이 방식은 백테스팅과 실전 거래의 동작을 변경하지 않습니다. 단지 분석 시점의 예측 정확도만 개선합니다.

```python
# segment_analyzer.py에 추가
def simulate_with_substitution_buy(original_trades, segment_filter_fn):
    remaining_trades = []
    for (종목명, 매수일자), day_trades in original_trades.groupby(['종목명', '매수일자']):
        day_trades = day_trades.sort_values('매수시간')
        is_holding = False
        hold_until = None
        
        for idx, trade in day_trades.iterrows():
            if is_holding and trade['매수시간'] < hold_until:
                continue
            if is_holding and trade['매수시간'] >= hold_until:
                is_holding = False
            
            if segment_filter_fn(trade):
                continue  # 필터 차단 → 미보유 상태 유지
            
            remaining_trades.append(trade)
            is_holding = True
            hold_until = trade['매도시간']
    
    return pd.DataFrame(remaining_trades)
```

#### 장점
- ✅ 현재 시스템 동작 유지
- ✅ 분석 예측 정확도 향상

#### 단점
- ⚠️ 필터 의도(당일 전체 차단)를 구현하지 않음
- ⚠️ 대체 매수로 인한 추가 손실 계속 발생

#### 권장 우선순위: **3순위** (Option 1과 병행)

---

### 10.4 Option 4: 불확실성 범위 표시 (단기 완화책)

#### 개념

즉시 적용 가능한 임시 조치로, 예측값에 불확실성 범위를 함께 표시합니다.

```python
"""
예상 잔여 거래: 1,497건 ~ 2,948건 (대체 매수 포함 시)
  - 낙관적 예측: 1,497건 (당일 재매수 차단 시)
  - 비관적 예측: 2,948건 (대체 매수 허용 시)
  
⚠️ 주의: 현재 시스템은 대체 매수를 허용합니다.
   Option 1 구현 후 낙관적 예측이 정확해집니다.
"""
```

#### 권장 우선순위: **2순위** (즉시 적용 가능)

---

### 10.5 해결 방안 비교 요약 (수정됨)

| 옵션 | 방법 | 백테스팅=실전 | 필터 의도 구현 | 구현 난이도 | 권장 순위 |
|------|------|:------------:|:-------------:|:----------:|:---------:|
| **Option 1** | 조건식+인프라 통합 | ✅ | ✅ | ⭐⭐⭐ | **1순위 ⭐⭐** |
| **Option 4** | 불확실성 범위 표시 | - | ❌ | ⭐ | 2순위 (임시) |
| **Option 3** | 대체 매수 시뮬레이션 | ❌ | ❌ | ⭐⭐⭐ | 3순위 |
| **Option 2** | 조건식만 (전역변수) | ⚠️ | ⚠️ | ⭐⭐ | 비권장 |

### 10.6 수정된 권장 구현 로드맵

#### 즉시 (1일 이내)
- **Option 4 적용**: 불확실성 범위 및 경고 메시지 표시
- 대체 매수 현상 문서화

#### 단기 (1-2주) ⭐⭐ 핵심
- **Option 1 구현** (조건식 + 인프라 통합):
  1. 8개 파일에 `self.세그먼트차단종목 = {}` 인프라 추가
  2. 세그먼트 코드 생성기 수정 (`segment_code_final.txt` 형식 변경)
  3. 통합 테스트: 백테스팅과 실전 거래 동작 일치 검증
  4. 기존 세그먼트 조건식 재생성

#### 중기 (선택)
- Option 3 (대체 매수 시뮬레이션) 병행 구현
- 결과 비교 검증 도구 개발

---

## 11. 결론 및 권장 사항 (최종)

### 11.1 분석 결론

#### 11.1.1 세그먼트 필터는 정상 작동함
- segment_code_final.txt의 필터 로직: 올바름
- 동적 경계값 (6432, 2622, 1350.5): 올바르게 적용됨
- 필터 위치 (기존 조건 앞): 올바름

#### 11.1.2 예측-실제 괴리의 원인
- **정적 분석 vs 동적 실행**의 구조적 차이
- 필터로 차단된 거래가 다른 시점에 "대체 매수"로 발생
- **세그먼트 필터의 본래 의도**(당일 전체 차단)가 **현재 구현**(시점별 차단)과 다름

#### 11.1.3 핵심 발견: 백테스팅-실전 거래 일관성 필요

> **⚠️ Critical**: 해결책이 백테스팅에서만 작동하고 실전 거래에서 작동하지 않으면, 백테스팅 결과를 신뢰할 수 없습니다.

- 백테스팅과 실전 거래 모두 `exec(self.buystrategy)` 형태로 조건식 실행
- `self`가 local scope에서 접근 가능하므로 **조건식 + 인프라 통합 방식** 구현 가능
- 양쪽 시스템에 `self.세그먼트차단종목 = {}` 인프라 추가 필요

### 11.2 성과 평가

| 지표 | 원본 | 필터 적용 | 개선 |
|------|------|----------|------|
| 거래 수 | 5,087건 | 2,955건 | -2,132건 (-42%) |
| 총 수익금 | -997.5M원 | -310.8M원 | **+686.8M원** |
| 평균 수익률 | -0.98% | -0.53% | **+0.45%p** |
| MDD | 192.9% | 89.3% | **-103.6%p** |

**결론: 세그먼트 필터는 +687M원 개선 달성 (예측 +1,087M 대비 63%)**

### 11.3 최종 권장 조치

```
┌─────────────────────────────────────────────────────────────────┐
│                     권장 구현 순서                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [즉시] Option 4: 불확실성 범위 표시 (임시 조치)                │
│            ↓                                                     │
│  [1-2주] Option 1: 조건식 + 인프라 통합 방식 (핵심!)             │
│          - 8개 파일에 self.세그먼트차단종목 인프라 추가          │
│          - 세그먼트 코드 생성기 수정                             │
│          - 백테스팅 = 실전 거래 동작 일치 검증                   │
│            ↓                                                     │
│  [선택] Option 3: 대체 매수 시뮬레이션 (분석 정확도 추가 개선)   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 11.4 향후 연구 과제

1. **대체 매수 패턴 분석**: 어떤 종목/조건에서 대체 매수가 많이 발생하는지
2. **필터 최적화**: 당일 재매수 차단 적용 시 최적 필터 조합 탐색
3. **시간대 연관성**: T1 차단 → T2 대체 매수 간의 상관관계 정량화
4. **실전 적용 검증**: Option 1 구현 후 실전 거래 결과와 백테스팅 결과 비교

---

## 11. 부록: 분석에 사용된 데이터

### 11.1 분석 대상 폴더

```
backtester/backtesting_output/
├── stock_bt_Min_B_Study_251227_20260108121747/         # 1차 (원본)
│   ├── 1-2_*_detail.csv                                # 5,087 거래
│   ├── 3-8_*_segment_code_final.txt                    # 생성된 필터 코드
│   ├── 3-53_*_tmpl_T3C3_time3_dynamic_semi_segment_combos.csv
│   └── 3-54_*_tmpl_T3C3_time3_dynamic_semi_segment_ranges.csv
│
└── stock_bt_Min_B_Study_251227_Filtered_20260108122240/ # 2차 (필터)
    └── 1-2_*_detail.csv                                # 2,955 거래
```

### 11.2 동적 경계값 (ranges.csv)

| 분류 | 구분 | 최소 | 최대 | 출처 |
|------|------|------|------|------|
| market_cap | 초소형주 | 0 | 1350.5 | dynamic |
| market_cap | 소형주 | 1350.5 | 2622 | dynamic |
| market_cap | 중형주 | 2622 | 6432 | dynamic |
| market_cap | 대형주 | 6432 | ∞ | dynamic |
| time | T1 | 92900 | 95900 | scaled |
| time | T2 | 95900 | 102900 | scaled |
| time | T3 | 102900 | 105900 | scaled |
| time | T4 | 105900 | 112900 | scaled |
| time | T5 | 112900 | 115900 | scaled |

### 11.3 DB 저장 조건 확인

```
전략명: Min_B_Study_251227_Filtered
전략코드 길이: 7,709 chars
세그먼트 필터: 포함됨 (Lines 29-194)
기존 조건: 포함됨 (Lines 199-261)
```

### 11.4 분석 스크립트

본 분석에 사용된 주요 Python 코드:

```python
# 거래 매칭
df1['key'] = df1['종목명'] + '_' + df1['매수시간'].astype(str)
df2['key'] = df2['종목명'] + '_' + df2['매수시간'].astype(str)

# 세그먼트 분류
df['시분초'] = df['매수시'] * 10000 + df['매수분'] * 100 + df['매수초']
df['시간대'] = df['시분초'].apply(get_time_period)
df['시총구분'] = df['시가총액'].apply(get_cap_category)

# 세그먼트별 집계
segment_stats = df.groupby(['시간대', '시총구분']).agg({
    '수익금': ['count', 'sum']
})
```

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0 | 2026-01-08 | AI Assistant | 최초 작성 |
| 1.1 | 2026-01-09 | AI Assistant | 문서 대폭 개선: 분석 파일 테이블 추가(2.4), 거래 매칭 분류 상세화(4.1), 세그먼트 필터 의도 vs 구현 명확화(5.3), 해결방안 재구성(Option 1을 권장안으로 변경), 결론 업데이트(10.3) |

---

*본 보고서는 STOM 백테스팅 시스템의 세그먼트 필터 분석 과정에서 발견된 예측-실제 괴리 현상에 대한 심층 분석 결과입니다.*
