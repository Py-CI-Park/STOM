# 세그먼트 필터 예측-실제 괴리 원인 분석 보고서

> **작성일**: 2026-01-08  
> **분석 대상**: 세그먼트 필터 적용 시 예측값과 실제 백테스트 결과 간 괴리  
> **관련 브랜치**: `feature/enhanced-buy-condition-generator`  
> **분석자**: AI Assistant (Sisyphus)

---

## 목차

1. [Executive Summary](#1-executive-summary)
2. [문제 발견 경위](#2-문제-발견-경위)
3. [분석 방법론](#3-분석-방법론)
4. [데이터 분석 결과](#4-데이터-분석-결과)
5. [근본 원인 분석](#5-근본-원인-분석)
6. [세그먼트별 상세 영향 분석](#6-세그먼트별-상세-영향-분석)
7. [케이스 스터디: DSC인베스트먼트](#7-케이스-스터디-dsc인베스트먼트)
8. [추가매수 옵션과의 관계](#8-추가매수-옵션과의-관계)
9. [해결 방안](#9-해결-방안)
10. [결론 및 권장 사항](#10-결론-및-권장-사항)
11. [부록: 분석에 사용된 데이터](#11-부록-분석에-사용된-데이터)

---

## 1. Executive Summary

### 1.1 문제 요약

세그먼트 필터를 적용한 백테스트 결과가 세그먼트 분석 시 예측한 값과 크게 다르게 나타났습니다.

| 지표 | 예측값 | 실제값 | 차이 |
|------|--------|--------|------|
| **잔여 거래 수** | 1,497건 | 2,955건 | +1,458건 (+97.4%) |
| **개선 금액** | +1,087M원 | +687M원 | -400M원 |
| **최종 수익금** | +90M원 | -311M원 | -401M원 |

### 1.2 핵심 발견

**근본 원인**: 세그먼트 필터가 특정 시점의 매수를 차단하면, 해당 종목이 이후 시간대에서 매수 조건을 다시 충족하여 **"대체 매수"**가 발생합니다.

**이것은 버그가 아닙니다**:
- 세그먼트 필터 코드: 정상 작동
- 백테스팅 엔진: 정상 작동
- 문제: 세그먼트 분석의 **"정적 필터링" 가정**과 백테스팅 엔진의 **"동적 실행" 동작** 간 구조적 차이

### 1.3 결론

세그먼트 필터는 **의도대로 작동**하며, 실제로 **+687M원의 수익 개선**을 달성했습니다. 다만, 세그먼트 분석 단계에서 대체 매수 효과를 고려하지 않아 예측이 낙관적이었습니다.

---

## 2. 문제 발견 경위

### 2.1 배경

STOM 백테스팅 시스템에서 세그먼트 분석은 다음 워크플로우로 진행됩니다:

```
1차 백테스트 (원본)
    ↓
세그먼트 분석 (시간대×시가총액 기반 필터 도출)
    ↓
segment_code_final.txt 생성 (필터 조건 코드)
    ↓
DB에 저장 (Min_B_Study_251227_Filtered)
    ↓
2차 백테스트 (필터 적용)
```

### 2.2 이상 징후 발견

2차 백테스트 완료 후 결과를 확인했을 때 다음과 같은 이상 징후가 발견되었습니다:

```
[세그먼트 분석 예측]
- 예상 잔여 거래: 1,497건 (29.5%)
- 예상 개선금액: +1,087,194,924원
- 예상 최종 수익금: +89,644,257원

[2차 백테스트 실제 결과]
- 실제 거래 수: 2,955건
- 총 수익금: -310,758,476원
```

예상 1,497건의 거래가 실제로는 2,955건으로 **거의 2배** 발생했습니다.

### 2.3 분석 대상 폴더

| 순서 | 폴더명 | 시간 | 용도 |
|------|--------|------|------|
| 1차 | `stock_bt_Min_B_Study_251227_20260108121747` | 12:17:47 | 원본 백테스트 + 세그먼트 분석 |
| 2차 | `stock_bt_Min_B_Study_251227_Filtered_20260108122240` | 12:22:40 | 필터 적용 백테스트 |

---

## 3. 분석 방법론

### 3.1 분석 절차

본 분석은 다음 6단계로 진행되었습니다:

```
Step 1: 폴더 구조 및 인과관계 파악
Step 2: 1차 백테스트 분석 (원본 5,087건)
Step 3: segment_code_final.txt 구조 분석
Step 4: 2차 백테스트 분석 (필터 적용 2,955건)
Step 5: 두 detail.csv 비교 분석
Step 6: 문제 원인 파악 및 해결책 도출
```

### 3.2 분석 도구 및 방법

#### 3.2.1 거래 매칭 분석
```python
# 거래 고유 키 생성 (종목명 + 매수시간)
df1['key'] = df1['종목명'] + '_' + df1['매수시간'].astype(str)
df2['key'] = df2['종목명'] + '_' + df2['매수시간'].astype(str)

# 집합 연산으로 거래 분류
common_trades = set(df1['key']) & set(df2['key'])     # 공통 거래
only_in_df1 = set(df1['key']) - set(df2['key'])       # 1차에만 존재 (필터로 제외됨)
only_in_df2 = set(df2['key']) - set(df1['key'])       # 2차에만 존재 (신규 발생)
```

#### 3.2.2 시간대-시가총액 세그먼트 분류
```python
# 시간대 분류 (동적 경계 사용)
def get_time_period(시분초):
    if 92900 <= 시분초 < 95900:  return 'T1'
    elif 95900 <= 시분초 < 102900: return 'T2'
    elif 102900 <= 시분초 < 105900: return 'T3'
    elif 105900 <= 시분초 < 112900: return 'T4'
    elif 112900 <= 시분초 < 115900: return 'T5'
    else: return 'Other'

# 시가총액 분류 (동적 경계: ranges.csv 기반)
def get_cap_category(cap):
    if cap >= 6432: return '대형주'
    elif cap >= 2622: return '중형주'
    elif cap >= 1350.5: return '소형주'
    else: return '초소형주'
```

#### 3.2.3 종목-일자 단위 분석
```python
# 같은 종목+같은 날에 거래 수 변화 분석
df1['종목일자'] = df1['종목명'] + '_' + df1['매수일자'].astype(str)
trades_per_day_1 = df1.groupby('종목일자').size()
trades_per_day_2 = df2.groupby('종목일자').size()
```

---

## 4. 데이터 분석 결과

### 4.1 거래 매칭 결과

두 백테스트 간 거래를 매칭한 결과:

| 분류 | 건수 | 설명 |
|------|------|------|
| **공통 거래 (같은 시간)** | 1,410건 | 원본과 동일한 거래 (필터 통과) |
| **1차에서만 매수** | 1,976건 | 필터로 차단된 거래 |
| **2차에서만 매수** | **1,545건** | **신규 발생 거래 (대체 매수)** |

**핵심 발견**: 2차 백테스트에서 원본에 없던 **1,545건의 새로운 거래**가 발생했습니다.

### 4.2 시간대별 거래 수 변화

| 시간대 | 원본 | 필터 후 | 변화 | 분석 |
|--------|------|---------|------|------|
| **T1** (09:29-09:59) | 2,572 | 761 | -1,811 | ✅ 의도대로 대량 제외 |
| **T2** (09:59-10:29) | 772 | 1,081 | **+309** | ❌ 대체 매수 발생 |
| **T3** (10:29-10:59) | 655 | 404 | -251 | ✅ 제외 |
| **T4** (10:59-11:29) | 586 | 383 | -203 | ✅ 제외 |
| **T5** (11:29-11:59) | 484 | 326 | -158 | ✅ 제외 |

**T2 시간대에서 거래가 오히려 309건 증가**한 것이 핵심 문제입니다.

### 4.3 종목-일자 단위 분석

| 분류 | 건수 | 설명 |
|------|------|------|
| **공통 종목+일자** | 2,352개 | 양쪽에서 해당 종목+일자에 거래 존재 |
| **1차에만 존재** | 1,267개 | 해당 종목+일자가 완전히 제외됨 |
| **2차에만 존재** | 0개 | 새로운 종목+일자 조합 없음 |

공통 종목+일자 내에서:

| 변화 유형 | 건수 | 설명 |
|-----------|------|------|
| 거래 수 증가 | 177개 | 같은 날 더 많은 거래 발생 |
| 거래 수 감소 | 438개 | 같은 날 거래 감소 |
| 거래 수 동일 | 1,737개 | 변화 없음 |

---

## 5. 근본 원인 분석

### 5.1 백테스팅 엔진의 동작 원리

백테스팅 엔진은 다음과 같이 동작합니다:

```
매 분봉마다:
    for 종목 in 관심종목:
        if 종목 보유 중:
            매도 조건 평가 → 매도 실행 여부 결정
        else:
            매수 조건 평가 → 매수 실행 여부 결정
```

**핵심 포인트**: 
- 보유 중인 종목은 추가 매수 불가 (동일 종목 중복 보유 방지)
- 미보유 종목은 매수 조건 충족 시 매수 가능

### 5.2 세그먼트 분석의 가정 vs 실제 동작

#### 세그먼트 분석의 가정 (정적 필터링)
```
원본 거래 목록: [거래1, 거래2, 거래3, ...]
필터 조건: T1+소형주 제외
결과: 거래1 제외 → [거래2, 거래3, ...]

가정: 제외된 거래 = 발생하지 않는 거래
```

#### 실제 백테스팅 동작 (동적 실행)
```
09:32 - 종목A 매수 조건 충족 → T1+소형주 → 필터 차단!
       ※ 종목A 미보유 상태 유지
       
10:00 - 종목A 매수 조건 다시 충족 → T2+소형주 → 필터 통과!
       → 매수 실행! (미보유 상태였으므로)
       
실제: 거래1 차단 → 거래1' 발생 (다른 시점에 같은 종목 매수)
```

### 5.3 대체 매수 메커니즘 상세

```
[원본 백테스트 시나리오]
09:32 - 종목A 매수 → 보유 중
10:00 - 종목A 매수 조건 충족 → 이미 보유 중 → 스킵
11:02 - 종목A 매수 조건 충족 → 이미 보유 중 → 스킵
12:37 - 종목A 매도

결과: 1건 거래

[필터 적용 백테스트 시나리오]
09:32 - 종목A 매수 조건 충족 → T1 필터 차단 → 미보유 유지
10:00 - 종목A 매수 조건 충족 → T2 필터 통과 → 매수!
10:55 - 종목A 매도 → 미보유
11:02 - 종목A 매수 조건 충족 → T3 필터 통과 → 매수!
11:23 - 종목A 매도 → 미보유
11:27 - 종목A 매수 조건 충족 → T3 필터 통과 → 매수!
12:34 - 종목A 매도

결과: 3건 거래
```

### 5.4 왜 이런 일이 발생하는가?

1. **원본에서는 조기 매수가 이후 매수를 "차단"**
   - 09:32에 매수하면 보유 중 상태
   - 이후 조건 충족해도 매수 불가

2. **필터 적용 시 조기 매수 차단 → 이후 매수 "허용"**
   - 09:32 매수가 차단되면 미보유 상태 유지
   - 10:00, 11:02 등에서 조건 충족 시 매수 가능

3. **세그먼트 분석은 이 효과를 고려하지 않음**
   - 거래 목록에서 단순히 "제외"
   - 제외된 거래가 다른 시점에 "대체"될 가능성 미반영

---

## 6. 세그먼트별 상세 영향 분석

### 6.1 세그먼트별 거래 수 및 수익금 변화

| 시간대 | 시총구분 | 1차 건수 | 2차 건수 | 변화 | 1차 수익금 | 2차 수익금 | 수익변화 |
|--------|----------|----------|----------|------|------------|------------|----------|
| T1 | 대형주 | 835 | 746 | -89 | -30.7M | -23.2M | +7.5M |
| T1 | 중형주 | 645 | 15 | **-630** | -54.6M | -9.2M | **+45.5M** |
| T1 | 소형주 | 591 | 0 | **-591** | -129.0M | 0.0M | **+129.0M** |
| T1 | 초소형주 | 501 | 0 | **-501** | -227.3M | 0.0M | **+227.3M** |
| T2 | 대형주 | 175 | 200 | +25 | -10.7M | -16.2M | -5.5M |
| T2 | 중형주 | 165 | 450 | **+285** | -4.4M | -4.7M | -0.3M |
| T2 | 소형주 | 204 | 413 | **+209** | -48.0M | -80.3M | **-32.4M** |
| T2 | 초소형주 | 228 | 18 | -210 | -90.5M | -14.2M | +76.3M |
| T3 | 대형주 | 108 | 30 | -78 | -15.6M | 2.3M | +17.9M |
| T3 | 중형주 | 177 | 219 | +42 | -10.2M | -4.8M | +5.4M |
| T3 | 소형주 | 171 | 53 | -118 | -47.6M | 1.1M | +48.7M |
| T3 | 초소형주 | 199 | 102 | -97 | -77.7M | -38.9M | +38.8M |
| T4 | 대형주 | 93 | 151 | +58 | -5.4M | -19.7M | **-14.4M** |
| T4 | 중형주 | 149 | 47 | -102 | -25.4M | 7.2M | +32.6M |
| T4 | 소형주 | 161 | 178 | +17 | -41.0M | -39.3M | +1.7M |
| T4 | 초소형주 | 183 | 7 | -176 | -56.8M | -5.7M | +51.0M |
| T5 | 대형주 | 59 | 50 | -9 | -9.6M | -2.8M | +6.9M |
| T5 | 중형주 | 129 | 114 | -15 | -14.3M | -19.9M | -5.6M |
| T5 | 소형주 | 141 | 155 | +14 | -35.3M | -36.2M | -0.9M |
| T5 | 초소형주 | 155 | 7 | -148 | -60.5M | -6.0M | +54.6M |

### 6.2 핵심 관찰

#### 의도대로 작동한 세그먼트 (녹색)
- **T1 중형주/소형주/초소형주**: 완전 또는 대부분 제외
- **T2~T5 초소형주**: 대부분 제외
- 수익 개선 효과 확인

#### 대체 매수가 발생한 세그먼트 (빨간색)
- **T2 중형주**: 165건 → 450건 (+285건)
- **T2 소형주**: 204건 → 413건 (+209건)
- **T4 대형주**: 93건 → 151건 (+58건)

#### 해석
T1에서 중형주/소형주가 대량 차단되면서, 해당 종목들이 T2에서 조건을 다시 충족하여 매수가 발생했습니다.

---

## 7. 케이스 스터디: DSC인베스트먼트

### 7.1 거래 상세 비교

#### 1차 백테스트 (원본)
```
종목: DSC인베스트먼트
일자: 2025-04-07

09:32 매수 (5,270원) → 12:37 매도
보유시간: 185분
수익금: -1,057,164원

총: 1건 거래, -1,057,164원 손실
```

#### 2차 백테스트 (필터 적용)
```
종목: DSC인베스트먼트
일자: 2025-04-07

거래1: 10:00 매수 (5,330원) → 10:55 매도, 보유 55분, -678,578원
거래2: 11:02 매수 (5,178원) → 11:23 매도, 보유 21분, -238,934원
거래3: 11:27 매수 (5,183원) → 12:34 매도, 보유 67분, -592,559원

총: 3건 거래, -1,510,071원 손실
```

### 7.2 타임라인 시각화

```
시간    1차 백테스트                2차 백테스트 (필터 적용)
────────────────────────────────────────────────────────────────
09:32   매수 조건 충족 → 매수!       매수 조건 충족 → T1+소형주 → 차단!
        ↓ (보유 중)                 (미보유 상태 유지)
10:00   매수 조건 충족 → 보유 중    매수 조건 충족 → T2+소형주 → 매수!
        스킵!                       ↓ (보유 중)
10:55   -                          매도 → -678,578원
                                   (미보유 상태)
11:02   매수 조건 충족 → 보유 중    매수 조건 충족 → T3+소형주 → 매수!
        스킵!                       ↓ (보유 중)
11:23   -                          매도 → -238,934원
                                   (미보유 상태)
11:27   매수 조건 충족 → 보유 중    매수 조건 충족 → T3+소형주 → 매수!
        스킵!                       ↓ (보유 중)
12:34   -                          매도 → -592,559원
12:37   매도 → -1,057,164원        -
────────────────────────────────────────────────────────────────
합계    1건, -1,057,164원           3건, -1,510,071원

차이: 필터 적용 시 -452,907원 더 손해!
```

### 7.3 이 케이스에서 배운 점

1. **조기 매수의 "보호 효과"**: 원본에서 09:32 매수는 이후 불리한 시점의 매수를 방지
2. **필터의 역효과 가능성**: 불리한 거래를 차단하려다 더 불리한 여러 거래로 대체될 수 있음
3. **단일 거래 vs 다중 거래**: 1건의 큰 손실보다 3건의 작은 손실 합계가 더 클 수 있음

---

## 8. 추가매수 옵션과의 관계

### 8.1 추가매수 옵션이란?

STOM에서 "추가매수" 또는 "분할매수"는 **이미 보유 중인 종목에 물타기**하는 기능입니다:

```python
# backengine_kiwoom_min2.py
if not self.CheckDividBuy(현재가, 추가매수가, 수익률, vturn, vkey) and self.dict_set['주식매수분할시그널']:
    # 추가매수 실행
```

### 8.2 현재 문제와의 관계

| 구분 | 추가매수 옵션 | 현재 문제 (대체 매수) |
|------|--------------|----------------------|
| **정의** | 보유 중인 종목에 추가 매수 | 미보유 종목에 새로운 매수 |
| **전제 조건** | 해당 종목 보유 중 | 해당 종목 미보유 |
| **설정** | `주식매수분할시그널` ON 필요 | 설정 없음 (기본 동작) |
| **발생 원인** | 사용자 옵션 활성화 | 필터로 이전 매수 차단 |

### 8.3 결론

**현재 문제는 추가매수 옵션과 무관합니다.**

- 추가매수: 보유 중 + 분할매수 설정 → 추가 매수
- 대체 매수: 미보유 + 조건 충족 → 신규 매수

대체 매수는 백테스팅 엔진의 **기본 동작**이며, 별도의 옵션과 관계없이 발생합니다.

---

## 9. 해결 방안

### 9.1 Option 1: 세그먼트 분석 시 대체 매수 시뮬레이션 (권장)

#### 개념
세그먼트 분석 단계에서 필터 적용 후 동일 종목의 이후 매수 가능성을 시뮬레이션합니다.

#### 구현 방법
```python
# 현재 로직 (정적 필터링)
for trade in original_trades:
    if segment_filter_excludes(trade):
        continue  # 단순 제외
    remaining_trades.append(trade)

# 개선 로직 (대체 매수 시뮬레이션)
for stock_date in unique_stock_date_pairs:
    trades_on_day = get_trades(stock, date)
    trades_on_day.sort(by='매수시간')  # 시간순 정렬
    
    is_holding = False
    hold_until = None
    
    for trade in trades_on_day:
        # 아직 보유 중이면 스킵
        if is_holding and trade.매수시간 < hold_until:
            continue
        
        # 보유 종료 확인
        if is_holding and trade.매수시간 >= hold_until:
            is_holding = False
        
        # 필터 적용
        if segment_filter_excludes(trade):
            continue  # 차단 → 미보유 상태 유지
        
        # 매수 발생
        remaining_trades.append(trade)
        is_holding = True
        hold_until = trade.매도시간  # 매도 시점까지 보유
```

#### 장점
- 예측 정확도 대폭 향상
- 실제 백테스팅 동작과 일치
- 대체 매수 효과 정확히 반영

#### 단점
- 구현 복잡도 증가
- 매도 시간 정보 필요 (현재 분석에서 사용 가능)

#### 난이도: ⭐⭐⭐ (중간)

### 9.2 Option 2: 종목-일 단위 필터 적용

#### 개념
특정 시점 차단 대신, 해당 종목의 그 날 전체 거래를 차단합니다.

#### 구현 방법
```python
# 차단할 종목+일자 목록 생성
blocked_stock_dates = set()
for trade in original_trades:
    if segment_filter_excludes(trade):
        blocked_stock_dates.add((trade.종목명, trade.매수일자))

# 필터링
for trade in original_trades:
    if (trade.종목명, trade.매수일자) in blocked_stock_dates:
        continue  # 해당 종목+일자 전체 제외
    remaining_trades.append(trade)
```

#### 장점
- 구현 간단
- 대체 매수 원천 차단
- 예측 = 실제 (정확히 일치)

#### 단점
- 너무 공격적인 필터링
- 실제로 괜찮은 시간대 거래도 함께 제외
- 수익 기회 손실 가능

#### 난이도: ⭐⭐ (쉬움)

### 9.3 Option 3: 백테스팅 엔진에 "당일 재매수 차단" 옵션 추가

#### 개념
필터로 차단된 종목은 해당 일에 재매수를 금지하는 옵션을 추가합니다.

#### 구현 방법
```python
# backengine_kiwoom_min2.py 수정
class BackEngine:
    def __init__(self):
        self.filtered_today = set()  # 오늘 필터로 차단된 종목
    
    def evaluate_buy(self, 종목코드, ...):
        today = get_today()
        
        # 옵션 확인
        if self.dict_set.get('필터차단종목_당일재매수금지', False):
            if (종목코드, today) in self.filtered_today:
                return  # 재매수 차단
        
        # 기존 매수 조건 평가
        매수 = True
        
        # 세그먼트 필터 평가
        if segment_filter_excludes(...):
            매수 = False
            self.filtered_today.add((종목코드, today))  # 차단 기록
        
        if 매수:
            self.Buy(...)
```

#### 장점
- 세그먼트 분석 예측 = 실제 결과 (정확히 일치)
- 옵션 OFF 시 현재 동작 유지 (하위 호환성)
- 사용자가 동작 선택 가능

#### 단점
- 백테스팅 엔진 수정 필요
- 테스트 범위 증가

#### 난이도: ⭐⭐⭐ (중간)

### 9.4 Option 4: 세그먼트 분석 결과에 불확실성 범위 표시

#### 개념
예측값에 불확실성 범위를 함께 표시하여 사용자의 과신을 방지합니다.

#### 구현 방법
```python
# combos.csv 출력 시
remaining_trades_optimistic = 1497   # 대체 매수 없다고 가정 (하한)
remaining_trades_pessimistic = 2955  # 최대 대체 매수 발생 (상한, 실제 결과 기반 추정)
remaining_trades_expected = (1497 + 2955) / 2  # 2,226건

# 출력 형식
print(f"예상 잔여 거래: {remaining_trades_optimistic:,}~{remaining_trades_pessimistic:,}건")
print(f"(중앙값: {remaining_trades_expected:,.0f}건)")
```

#### 장점
- 구현 매우 간단
- 사용자 기대 조정
- 과신 방지

#### 단점
- 근본적인 해결이 아님
- 범위가 너무 넓으면 유용성 저하

#### 난이도: ⭐ (매우 쉬움)

### 9.5 해결 방안 비교 요약

| 옵션 | 정확도 향상 | 구현 난이도 | 호환성 | 권장도 |
|------|------------|------------|--------|--------|
| Option 1: 대체 매수 시뮬레이션 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **1순위** |
| Option 2: 종목-일 단위 필터 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 3순위 |
| Option 3: 재매수 차단 옵션 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | 2순위 |
| Option 4: 불확실성 범위 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 단기 조치 |

---

## 10. 결론 및 권장 사항

### 10.1 분석 결론

#### 10.1.1 세그먼트 필터는 정상 작동함
- segment_code_final.txt의 필터 로직: 올바름
- 동적 경계값 (6432, 2622, 1350.5): 올바르게 적용됨
- 필터 위치 (기존 조건 앞): 올바름

#### 10.1.2 예측-실제 괴리의 원인
- **정적 분석 vs 동적 실행**의 구조적 차이
- 세그먼트 분석: 거래 목록에서 단순 필터링 (정적)
- 백테스팅 엔진: 매 시점 조건 평가 (동적)
- 필터로 차단된 거래가 다른 시점에 "대체 매수"로 발생

#### 10.1.3 이것은 버그가 아님
- 모든 시스템이 설계대로 동작
- 문제는 **분석 가정**과 **실제 동작**의 차이
- 시스템 개선이 아닌 **예측 방법 개선** 필요

### 10.2 성과 평가

실제 필터 적용 결과를 평가하면:

| 지표 | 원본 | 필터 적용 | 개선 |
|------|------|----------|------|
| 거래 수 | 5,087건 | 2,955건 | -2,132건 (-42%) |
| 총 수익금 | -997.5M원 | -310.8M원 | **+686.8M원** |
| 평균 수익률 | -0.98% | -0.53% | **+0.45%p** |
| MDD | 192.9% | 89.3% | **-103.6%p** |

**결론: 세그먼트 필터는 실질적인 성과 개선을 달성했습니다.**

예측(+1,087M)보다는 적지만, 실제로 **+687M원의 개선**이 발생했으며, MDD도 절반 이하로 감소했습니다.

### 10.3 권장 조치

#### 단기 (즉시)
- **Option 4 적용**: 세그먼트 분석 결과에 불확실성 범위 표시
- 사용자 문서에 대체 매수 현상 설명 추가

#### 중기 (1-2주)
- **Option 1 적용**: 세그먼트 분석에 대체 매수 시뮬레이션 로직 추가
- 예측 정확도 검증 테스트

#### 장기 (선택)
- **Option 3 적용**: 백테스팅 엔진에 재매수 차단 옵션 추가
- 사용자가 원하는 동작을 선택할 수 있도록 옵션 제공

### 10.4 향후 연구 과제

1. **대체 매수 패턴 분석**: 어떤 종목/조건에서 대체 매수가 많이 발생하는지
2. **필터 최적화**: 대체 매수를 고려한 최적 필터 조합 탐색
3. **시간대 연관성**: T1 차단 → T2 대체 매수 간의 상관관계 정량화

---

## 11. 부록: 분석에 사용된 데이터

### 11.1 분석 대상 폴더

```
backtester/backtesting_output/
├── stock_bt_Min_B_Study_251227_20260108121747/         # 1차 (원본)
│   ├── 1-2_*_detail.csv                                # 5,087 거래
│   ├── 3-8_*_segment_code_final.txt                    # 생성된 필터 코드
│   ├── 3-53_*_tmpl_T3C3_time3_dynamic_semi_segment_combos.csv
│   └── 3-54_*_tmpl_T3C3_time3_dynamic_semi_segment_ranges.csv
│
└── stock_bt_Min_B_Study_251227_Filtered_20260108122240/ # 2차 (필터)
    └── 1-2_*_detail.csv                                # 2,955 거래
```

### 11.2 동적 경계값 (ranges.csv)

| 분류 | 구분 | 최소 | 최대 | 출처 |
|------|------|------|------|------|
| market_cap | 초소형주 | 0 | 1350.5 | dynamic |
| market_cap | 소형주 | 1350.5 | 2622 | dynamic |
| market_cap | 중형주 | 2622 | 6432 | dynamic |
| market_cap | 대형주 | 6432 | ∞ | dynamic |
| time | T1 | 92900 | 95900 | scaled |
| time | T2 | 95900 | 102900 | scaled |
| time | T3 | 102900 | 105900 | scaled |
| time | T4 | 105900 | 112900 | scaled |
| time | T5 | 112900 | 115900 | scaled |

### 11.3 DB 저장 조건 확인

```
전략명: Min_B_Study_251227_Filtered
전략코드 길이: 7,709 chars
세그먼트 필터: 포함됨 (Lines 29-194)
기존 조건: 포함됨 (Lines 199-261)
```

### 11.4 분석 스크립트

본 분석에 사용된 주요 Python 코드:

```python
# 거래 매칭
df1['key'] = df1['종목명'] + '_' + df1['매수시간'].astype(str)
df2['key'] = df2['종목명'] + '_' + df2['매수시간'].astype(str)

# 세그먼트 분류
df['시분초'] = df['매수시'] * 10000 + df['매수분'] * 100 + df['매수초']
df['시간대'] = df['시분초'].apply(get_time_period)
df['시총구분'] = df['시가총액'].apply(get_cap_category)

# 세그먼트별 집계
segment_stats = df.groupby(['시간대', '시총구분']).agg({
    '수익금': ['count', 'sum']
})
```

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0 | 2026-01-08 | AI Assistant | 최초 작성 |

---

*본 보고서는 STOM 백테스팅 시스템의 세그먼트 필터 분석 과정에서 발견된 예측-실제 괴리 현상에 대한 심층 분석 결과입니다.*
