# Enhanced Backtesting Analysis System: 완전 분석 보고서

**작성일**: 2026-01-07
**기준 커밋**: `12d4a1226fe9d075c6d81e1752b0a398d0553f6f` (강화 기능 없음) vs 현재 (`d81ecdb`)
**목적**: 백테스팅 결과 분석 시스템의 전체 구조, 추가된 데이터/변수, 문제 가능성 및 개선 방안 도출

---

## 📋 Executive Summary

### 변경 규모
- **신규 파일 수**: 78개
- **신규 코드 라인**: ~24,000+
- **신규 모듈**: `analysis/`, `analysis_enhanced/`, `segment_analysis/`
- **추가된 파생 지표 수**: 93개 이상

### 핵심 발견사항

| 구분 | 내용 | 심각도 |
|------|------|--------|
| **문제 1** | 예측-실제 불일치 (최대 90% 오차) | 🔴 Critical |
| **문제 2** | 런타임 매핑 기본값 버그 | 🟠 High |
| **문제 3** | 타임프레임 변수 혼동 | 🟠 High |
| **문제 4** | 동적 세그먼트 경계 드리프트 | 🔴 Critical |
| **문제 5** | 변수 컨텍스트 불일치 (Pandas vs exec) | 🟡 Medium |

---

## 1. 시스템 아키텍처 변경 개요

### 1.1 기준 커밋 (12d4a1226) - 기능 없음

```
backtester/
├── back_static.py          # 기본 백테스팅 유틸리티만
├── backengine_kiwoom_*.py  # 기본 엔진
├── backtest.py             # 기본 실행
└── (기타 기존 파일들)
```

### 1.2 현재 커밋 - 강화 분석 시스템

```
backtester/
├── analysis/                          # [신규] 기본 분석 모듈 (18개 파일)
│   ├── metrics_base.py               # 기본 지표 계산
│   ├── plotting.py                   # 시각화 (2,902 라인)
│   ├── exports.py                    # 데이터 내보내기
│   └── ...
│
├── analysis_enhanced/                 # [신규] 강화 분석 모듈 (16개 파일)
│   ├── metrics_enhanced.py           # 파생 지표 계산 (573 라인)
│   ├── runner.py                     # 분석 오케스트레이션 (1,592 라인)
│   ├── filters.py                    # 필터 후보 생성 (1,001 라인)
│   ├── ml.py                         # ML 모델 (1,281 라인)
│   ├── analysis_logger.py            # 텔레그램 로깅 (1,175 라인)
│   └── ...
│
├── segment_analysis/                  # [신규] 세그먼트 분석 모듈 (24개 파일)
│   ├── code_generator.py             # 코드 생성 (1,283 라인)
│   ├── segmentation.py               # 세그먼트 분할 (991 라인)
│   ├── segment_apply.py              # 필터 적용 (129 라인)
│   ├── genetic_optimizer.py          # GA 최적화 (428 라인)
│   └── ...
│
├── output_manifest.py                 # [신규] 출력 파일 관리
├── output_paths.py                    # [신규] 경로 관리
└── detail_schema.py                   # [신규] 스키마 정의
```

---

## 2. 추가된 파생 변수/지표 목록

### 2.1 metrics_enhanced.py에서 계산되는 파생 지표 (93개+)

#### 변화량 지표 (매도 - 매수)
| 지표명 | 계산식 | 용도 |
|--------|--------|------|
| `등락율변화` | `매도등락율 - 매수등락율` | 보유 중 추세 변화 |
| `체결강도변화` | `매도체결강도 - 매수체결강도` | 수급 변화 감지 |
| `전일비변화` | `매도전일비 - 매수전일비` | 전일비 변화 |
| `회전율변화` | `매도회전율 - 매수회전율` | 회전율 변화 |
| `호가잔량비변화` | `매도호가잔량비 - 매수호가잔량비` | 호가 불균형 변화 |

#### 변화율 지표 (매도 / 매수)
| 지표명 | 계산식 | 용도 |
|--------|--------|------|
| `거래대금변화율` | `매도당일거래대금 / 매수당일거래대금` | 거래량 추세 |
| `체결강도변화율` | `매도체결강도 / 매수체결강도` | 체결강도 비율 |

#### 복합 점수 지표
| 지표명 | 범위 | 계산 요소 | 용도 |
|--------|------|-----------|------|
| `거래품질점수` | 0-100 | 체결강도, 호가잔량비, 시가총액, 등락율, 스프레드 | 거래 품질 평가 |
| `위험도점수` | 0-100 | 등락율, 체결강도, 거래대금, 시가총액, 호가잔량비, 스프레드, 회전율, 변동폭 | 위험 신호 점수 |
| `모멘텀점수` | -30~+30 | `(등락율/10 * 0.4 + (체결강도-100)/50 * 0.6) * 10` | 모멘텀 강도 |

#### 타임프레임별 지표 (Tick vs Min)

**틱 모드 (timeframe='tick')**
| 지표명 | 계산식 |
|--------|--------|
| `초당매수수량_매도총잔량_비율` | `매수초당매수수량 / 매수매도총잔량 * 100` |
| `초당매도_매수_비율` | `매수초당매도수량 / 매수초당매수수량` |
| `초당매수_매도_비율` | `매수초당매수수량 / 매수초당매도수량` |
| `초당순매수수량` | `매수초당매수수량 - 매수초당매도수량` |
| `초당순매수금액` | `초당순매수수량 * 매수가 / 1,000,000` |
| `초당순매수비율` | `매수초당매수수량 / (매수초당매수수량 + 매수초당매도수량) * 100` |
| `초당거래대금_당일비중` | `매수초당거래대금 / 매수당일거래대금 * 10000` |

**분봉 모드 (timeframe='min')**
| 지표명 | 계산식 |
|--------|--------|
| `분당매수수량_매도총잔량_비율` | `매수분당매수수량 / 매수매도총잔량 * 100` |
| `분당매도_매수_비율` | `매수분당매도수량 / 매수분당매수수량` |
| `분당매수_매도_비율` | `매수분당매수수량 / 매수분당매도수량` |
| `분당순매수수량` | `매수분당매수수량 - 매수분당매도수량` |
| `분당순매수금액` | `분당순매수수량 * 매수가 / 1,000,000` |
| `분당순매수비율` | `매수분당매수수량 / (매수분당매수수량 + 매수분당매도수량) * 100` |
| `분당거래대금_당일비중` | `매수분당거래대금 / 매수당일거래대금 * 10000` |

### 2.2 code_generator.py에서 런타임 매핑되는 변수 (49개+)

#### 기본 런타임 매핑 블록
```python
# 파일: backtester/segment_analysis/code_generator.py
# 함수: _get_segment_runtime_blocks(timeframe='tick')

# 틱 모드
try:
    초당매수수량 = 초당매수수량  # 틱 엔진에서 직접 정의
except NameError:
    초당매수수량 = 0

# 분봉 모드
try:
    분당매수수량 = 분당매수수량  # 분봉 엔진에서 직접 정의
except NameError:
    분당매수수량 = 0
```

#### 스냅샷 매핑 변수 (매수 시점 캡처)
| 런타임 변수명 | 원본 변수 | 그룹 |
|---------------|-----------|------|
| `매수매수호가1` | `매수호가1` | snapshot |
| `매수매도호가1` | `매도호가1` | snapshot |
| `매수매수총잔량` | `매수총잔량` | snapshot |
| `매수매도총잔량` | `매도총잔량` | snapshot |
| `매수전일비` | `전일비` | snapshot |
| `매수체결강도` | `체결강도` | snapshot |
| `매수등락율` | `등락율` | snapshot |
| `매수회전율` | `회전율` | snapshot |
| `매수당일거래대금` | `당일거래대금` | snapshot |
| `매수고가` | `고가` | snapshot |
| `매수저가` | `저가` | snapshot |
| `매수시가` | `시가` | snapshot |
| `매수가` | `현재가` | snapshot |

#### 계산 파생 변수
| 변수명 | 의존 변수 | 계산식 |
|--------|-----------|--------|
| `매수스프레드` | `매도호가1`, `매수호가1` | `((매도호가1 - 매수호가1) / 매수호가1) * 100` |
| `매수호가잔량비` | `매수총잔량`, `매도총잔량` | `(매수총잔량 / (매도총잔량 + 1e-6)) * 100` |
| `매수변동폭` | `고가`, `저가` | `고가 - 저가` |
| `매수변동폭비율` | `고가`, `저가` | `((고가 - 저가) / 저가) * 100` |
| `현재가_고저범위_위치` | `현재가`, `고가`, `저가` | `(현재가 - 저가) / (고가 - 저가 + 1e-6) * 100` |

---

## 3. 데이터 흐름 아키텍처

### 3.1 백테스팅 결과 분석 파이프라인

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1: 백테스트 실행                                          │
│  backengine_kiwoom_*.py → detail.csv (93+ columns)             │
└────────────────────────────────┬────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│  Phase 2: 파생 지표 계산                                         │
│  metrics_enhanced.py::CalculateEnhancedDerivedMetrics()        │
│  - 입력: df_tsg (detail.csv 데이터)                             │
│  - 출력: df_enhanced (93 → 150+ columns)                       │
│  - 타임프레임 감지: save_file_name에서 tick/min 자동 판별        │
└────────────────────────────────┬────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│  Phase 3: 세그먼트 분할                                          │
│  segmentation.py::SegmentBuilder.build_segments()              │
│  - 시가총액 분할: 대형주/중형주/소형주/초소형주 (동적 분위수)      │
│  - 시간대 분할: T1~T5 (장 시작 ~ 장 종료)                        │
│  - 경계값 저장: ranges.csv                                      │
└────────────────────────────────┬────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│  Phase 4: 세그먼트별 필터 최적화                                  │
│  filter_evaluator.py, combination_optimizer.py                 │
│  - 각 세그먼트에서 최적 필터 조합 탐색                           │
│  - t-test, effect size 기반 필터 선별                           │
│  - 출력: segment_combos.csv                                     │
└────────────────────────────────┬────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│  Phase 5: 코드 생성                                              │
│  code_generator.py                                              │
│  - segment_code.txt: 순수 필터 조건만                           │
│  - segment_code_final.txt: 원본 조건 + 런타임 매핑 + 필터       │
│  - filter_code_final.txt: 일반 필터 조건식                      │
└────────────────────────────────┬────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│  Phase 6: 필터 적용 (재백테스트)                                  │
│  backengine에서 exec(segment_code_final.txt)                   │
│  - 런타임 매핑 블록이 변수 정의                                  │
│  - if/elif 체인으로 세그먼트 필터 적용                           │
│  - 필터통과 = True/False                                        │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 변수 컨텍스트 비교

| 항목 | 내부 분석 (Pandas) | 실제 실행 (exec) |
|------|-------------------|------------------|
| **데이터 소스** | DataFrame 컬럼 | Strategy() 로컬 변수 |
| **변수 접근** | `df['시분초']` | `시분초` |
| **에러 처리** | `pd.to_numeric(..., errors='coerce')` | `try/except NameError → 0` |
| **누락 시 동작** | NaN → False (필터 미통과) | 0 (조건 평가에 영향) |
| **타입 정밀도** | float64 | Python float |

---

## 4. 발견된 문제점 및 불일치 원인

### 4.1 문제 1: 예측-실제 불일치 (Critical)

**증상** (실제 사례):
```
예상: 필터 통과 1,458개 (28.76%), 수익 개선 +1,087M원
실제: 필터 통과 2,790개 (54.8%), 수익 개선 +733M원
차이: +1,327개 (+90.7%), -354M원 (-32.6%)
```

**근본 원인**: 동적 세그먼트 경계 드리프트 (Quantile Drift)

```python
# Phase 3 세그먼트 분석 시
builder = SegmentBuilder(SegmentConfig(dynamic_mode='semi'))
segments = builder.build_segments(df_detail)  # 분위수 계산 → 경계 A
# 결과: 대형주 >= 6,432억

# Phase 6 필터 적용 시 (기존 버그)
builder = SegmentBuilder()  # 기본 설정 → dynamic 모드!
segments = builder.build_segments(df_enhanced)  # 재계산 → 경계 B (다름!)
# 결과: 대형주 >= 5,800억 (다른 데이터 분포로 인해 변경)
```

**해결 방법**: `ranges.csv` 저장 및 `fixed` 모드 강제
```python
# 수정된 코드 (back_static.py)
seg_config = load_segment_config_from_ranges(global_best)  # ranges.csv 로드
builder = SegmentBuilder(seg_config)  # fixed 모드
```

### 4.2 문제 2: 런타임 매핑 기본값 버그 (High)

**증상**: 함수 호출 실패 시 필터가 무력화됨

**버그 코드** (code_generator.py:277-289):
```python
try:
    _prev_trade = 당일거래대금N(1)
    당일거래대금_전틱분봉_비율 = 당일거래대금 / (_prev_trade + 1e-6)
except (NameError, TypeError):
    당일거래대금_전틱분봉_비율 = 1.0  # ❌ BUG: >= 0.6 필터를 통과시킴!
```

**영향 분석**:
- 필터 조건: `당일거래대금_전틱분봉_비율 >= 0.600332`
- 함수 실패 시: `1.0 >= 0.600332` → **True** (잘못된 통과)
- 의도: 전틱 분봉 대비 비율이 0.6 이상인 거래만 통과

**해결 방법** (2026-01-07 적용됨):
```python
except (NameError, TypeError):
    당일거래대금_전틱분봉_비율 = 0.0  # ✅ >= 조건 실패 (보수적)
```

### 4.3 문제 3: 타임프레임 변수 혼동 (High)

**증상**: 분봉 모드에서 `초당* = 분당*/60` 변환 시 정밀도 손실

**이전 버그 코드**:
```python
# 분봉 모드에서 틱 변수를 변환
초당매수수량 = (분당매수수량 / 60) if '분당매수수량' in locals() else 0
```

**문제점**:
1. 분봉 DB에는 `초당*` 변수가 존재하지 않음
2. `분당*/60` 변환은 의미가 다름 (평균 vs 순간값)
3. 분석 시점과 실행 시점의 변수명 불일치

**해결 방법** (2026-01-07 d81ecdb 커밋):
- 타임프레임별 완전 분리
- 틱 모드: `초당*` 변수만 사용
- 분봉 모드: `분당*` 변수만 사용
- 변환 금지: 같은 접두사의 변수만 사용

### 4.4 문제 4: 시분초 변환 차이 (Medium)

**분석 시점** (detail.csv 기반):
```python
시분초 = int(str(매수시간)[8:] + '00')  # 202504070929 → 92900
```

**실행 시점** (backengine):
```python
# 틱 모드
시분초 = int(str(self.index)[8:])  # 20250407092935 → 92935 (초 포함)

# 분봉 모드
시분초 = int(str(self.index)[8:] + '00')  # 202504070929 → 92900
```

**영향**: 시간대 세그먼트 경계에서 일부 거래가 다른 세그먼트로 분류될 수 있음

### 4.5 문제 5: exec() 스코프 제한 (Medium)

**백테스팅 엔진 실행 구조**:
```python
def Strategy(self):
    # 로컬 변수 정의
    현재가, 시가, 고가, 저가, ... = self.arry_data[self.indexn, 1:45]
    
    # 함수 정의
    def 당일거래대금N(pre):
        return Parameter_Previous(6, pre)
    
    # exec() 실행
    exec(self.dict_set['매수조건'], globals(), locals())
```

**잠재적 문제**:
1. `locals()`는 읽기 전용 (Python 구현에 따라 다름)
2. exec() 내에서 정의된 변수가 외부에서 접근 불가할 수 있음
3. 변수명 충돌 시 예상치 못한 동작

---

## 5. 코드 위치 참조표

### 5.1 파생 지표 계산

| 지표 종류 | 파일 | 함수/라인 |
|-----------|------|-----------|
| 변화량/변화율 지표 | `metrics_enhanced.py` | `CalculateEnhancedDerivedMetrics()` L61-120 |
| 위험도점수 | `metrics_enhanced.py` | L168-230 |
| 거래품질점수 | `metrics_enhanced.py` | L272-294 |
| 모멘텀점수 | `metrics_enhanced.py` | L144-149 |
| 초당* 지표 (틱) | `metrics_enhanced.py` | L300-372 |
| 분당* 지표 (분봉) | `metrics_enhanced.py` | L374-455 |

### 5.2 런타임 매핑

| 매핑 종류 | 파일 | 함수/라인 |
|-----------|------|-----------|
| 런타임 블록 정의 | `code_generator.py` | `_get_segment_runtime_blocks()` L594-900 |
| 런타임 프리앰블 빌드 | `code_generator.py` | `_build_segment_runtime_preamble()` L500-556 |
| 의존성 해결 | `code_generator.py` | `_resolve_runtime_dependencies()` L576-591 |
| 타임프레임 감지 | `code_generator.py` | `_detect_timeframe_from_name()` L1076-1092 |

### 5.3 세그먼트 분할

| 기능 | 파일 | 함수/라인 |
|------|------|-----------|
| 세그먼트 빌더 | `segmentation.py` | `SegmentBuilder` class |
| 경계 설정 | `segmentation.py` | `SegmentConfig` class |
| 마스크 생성 | `segment_apply.py` | `build_segment_mask_from_global_best()` L49-128 |
| 경계 로드 | `segment_apply.py` | `load_segment_config_from_ranges()` L13-46 |

### 5.4 백테스팅 엔진

| 기능 | 파일 | 라인 |
|------|------|------|
| Strategy() 함수 | `backengine_kiwoom_tick.py` | L432-700+ |
| 변수 언패킹 | `backengine_kiwoom_tick.py` | L657-662 |
| 함수 정의 (당일거래대금N 등) | `backengine_kiwoom_tick.py` | L457-650 |
| exec() 호출 | `backengine_kiwoom_tick.py` | L691 |

---

## 6. 개선 방안 및 권장 사항

### 6.1 즉시 조치 (Immediate)

| 항목 | 상태 | 조치 |
|------|------|------|
| 런타임 매핑 기본값 0.0 | ✅ 완료 | d81ecdb 커밋 |
| 타임프레임 변수 분리 | ✅ 완료 | d81ecdb 커밋 |
| ranges.csv 고정 모드 | ✅ 완료 | 기존 커밋 |

### 6.2 단기 개선 (Short-term)

| 항목 | 우선순위 | 설명 |
|------|----------|------|
| 런타임 검증 로깅 | 🟠 High | exec() 실행 시 변수 값 로깅 추가 |
| 시분초 정규화 | 🟡 Medium | 분석/실행 시점의 시분초 형식 통일 |
| 필터 적용 전 검증 | 🟠 High | segment_code 적용 전 내부 검증 의무화 |

### 6.3 중장기 개선 (Long-term)

| 항목 | 우선순위 | 설명 |
|------|----------|------|
| 컴파일 방식 전환 | 🟡 Medium | exec() → 함수 생성 방식 전환 |
| 단위 테스트 강화 | 🟡 Medium | 런타임 매핑 블록별 테스트 |
| Walk-Forward 검증 | 🟠 High | 과적합 방지 검증 시스템 |

---

## 7. 검증 체크리스트

### 7.1 신규 지표 추가 시

- [ ] `metrics_enhanced.py`에 계산 로직 추가
- [ ] `code_generator.py`의 `_get_segment_runtime_blocks()`에 매핑 블록 추가
- [ ] 틱/분봉 모드 분기 확인
- [ ] 기본값 설정 확인 (0.0 또는 안전한 값)
- [ ] 의존성 변수 목록 정확성 확인

### 7.2 세그먼트 필터 적용 시

- [ ] `ranges.csv` 파일 존재 확인
- [ ] `global_best['ranges_path']` 설정 확인
- [ ] `SegmentConfig(dynamic_mode='fixed')` 사용 확인
- [ ] 내부 검증 결과 vs 예상 결과 비교
- [ ] `필터통과` 변수 로깅 활성화

### 7.3 타임프레임 호환성

- [ ] 파일명에서 타임프레임 자동 감지 확인
- [ ] 틱 모드: `초당*` 변수만 사용
- [ ] 분봉 모드: `분당*` 변수만 사용
- [ ] 변환 로직 없음 확인 (`초당 = 분당/60` 금지)

---

## 8. 관련 문서 참조

| 문서 | 설명 |
|------|------|
| `segment_filter_verification_issue.md` | 예측-실제 불일치 상세 분석 |
| `20260107_Enhanced_Backtesting_Analysis_System_Deep_Dive.md` | 시스템 심층 분석 |
| `20260106_Segment_Filter_Variable_Definition_Study.md` | 변수 정의 스터디 (기존) |
| `Back_Testing_Guideline_Tick.md` | 틱 백테스팅 가이드 |
| `Back_Testing_Guideline_Min.md` | 분봉 백테스팅 가이드 |

---

## 9. 변경 이력

| 날짜 | 커밋 | 내용 |
|------|------|------|
| 2026-01-07 | d81ecdb | 타임프레임별 변수 완전 분리 |
| 2026-01-07 | 91931ee | 틱 엔진 초당* 변수 덮어쓰기 버그 수정 |
| 2026-01-01 | - | 런타임 매핑 기본값 1.0 → 0.0 수정 |
| 2026-01-01 | - | ranges.csv 고정 모드 도입 |
| 2025-12-31 | - | if/elif 체인 버그 수정 |

---

**문서 작성자**: AI Assistant
**최종 업데이트**: 2026-01-07
**상태**: ✅ 완료
