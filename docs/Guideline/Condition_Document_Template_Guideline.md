# 조건식/최적화 문서 템플릿 가이드라인 (Tick/Min 공통)

---

> 이 문서는 **조건식 + 최적화 문서**를 항상 같은 형식과 품질로 작성하기 위한 템플릿 가이드입니다.  
> `Back_Testing_Guideline_Tick.md`, `Back_Testing_Guideline_Min.md` 와 함께 사용하면,  
> 새 Tick/Min 전략 문서를 일관된 구조로 빠르게 생성할 수 있습니다.

---

## 0. 필수 준수사항 요약 체크리스트

조건식/최적화 문서를 새로 만들거나 기존 문서를 점검할 때 **아래 항목이 모두 충족되는지 먼저 확인**한다. 어느 하나라도 빠지면 템플릿 위반으로 간주하고 즉시 수정해야 한다.

1. **상단 참조 표기 필수**: Tick/Min 구분에 맞춰 `Back_Testing_Guideline_*` 와 본 템플릿을 모두 링크한다.
2. **개요(Overview) 5대 필수 정보**: 시간 구간, 대상 종목 범위, 전략 타입, 핵심 변수·지표, 업데이트 이력(해당 시) 모두 명시한다.
3. **템플릿 목차/섹션 구조 유지**: 목차, 가이드라인, 조건식, 최적화, 개선 방향 연구, 태그 순서를 삭제하거나 임의 변경하지 않는다.
4. **명명 규칙 준수**: 전략 ID(`C_T_900_920_U1_B` 등)·파일명(`Condition_Tick_900_920.md` 등)·GA/OR 접미사를 일관되게 사용한다.
5. **공통 계산 지표 상단 정리**: 중복 계산식은 조건식/최적화 섹션의 최상단에 모아 두고, 본문에서 재사용한다.
6. **최적화 변수 매핑 주석 필수**: `self.vars[i]`마다 의미·단위·범위·간격·개수 주석을 작성하고, 매수/매도/OR/GA에서 동일한 인덱스를 재사용한다.
7. **조건식 개선 방향 연구 섹션 포함**: 최소 3개 이상의 개선 아이디어(우선순위 포함)를 작성한다.
8. **예상 경우의 수·소요 시간 계산**: 최적화 범위를 정의했으면 총 경우의 수와 시간 가정을 표시하고, 비현실적이면 GA/OR 제안을 추가한다.
9. **불용어/모호 표현 금지**: "적당히", "유동적으로" 같은 모호 표현을 피하고, 수치·조건을 명확히 기입한다.
10. **백테스트 코드 호환성 점검**: STOM 백테스팅 스크립트에서 사용하는 변수명(`self.vars`, `self.Buy`, `self.Sell`, `시분초`, `등락율`)을 그대로 사용하고, 새 변수는 계산식을 포함해 정의한다.
11. **매수/매도 초기값 및 로직 패턴 준수**: 매수는 `True`로 시작, 매도는 `False`로 시작 (2.6절 참조)
12. **self.vars 인덱스 연속 사용 규칙 준수**:
    - `self.vars[0]`: 고정값 전용 (최적화 대상 아님)
    - `self.vars[1]` 이후: 최적화 변수 (매수/매도 순서대로)
    - **반드시 연속된 번호로 사용** (건너뛰기 금지)
    - 예: 매수 3개, 매도 2개 → vars[0]=고정값, vars[1~3]=매수, vars[4~5]=매도
    - 자세한 규칙은 2.7절 참조
13. **if/elif 체인 구조 준수**: 첫 조건만 `if`, 나머지는 `elif` 사용 (2.8절 참조)
14. **범위 함수 괄호 사용 및 변수 검증 규칙 준수** (2.11절 참조):
    - 범위 함수(`이동평균`, `최고현재가` 등) 반드시 괄호와 함께 사용: `이동평균(30)`, `최고현재가(20, 1)`
    - self.vars 형식: `[[시작, 끝, 간격], 초기값]` 준수
    - 범위 값 개수: 각 변수당 최대 20개 이하 (`(끝값 - 시작값) / 간격 + 1 ≤ 20`)
    - 간격 부호: 시작값 < 끝값이면 양수, 시작값 > 끝값이면 음수
    - **Range Step 정합성**: `(끝값 - 시작값) % 간격 == 0` 필수 (Optuna 호환성)
    - **NumPy 호환성**: 연쇄 비교 금지 (`a < b < c` → `a < b and b < c`)

---

## 1. 문서 목적

- STOM 자동 매매 시스템에서 사용하는 **Tick / 분봉(Min) 조건식 및 최적화 문서**의 표준 형식을 정의한다.
- 사람이 직접 문서를 쓸 때도, AI 에게 문서 생성을 요청할 때도 모두 활용 가능하도록 한다.
- 전략별 문서 구조를 통일하여:
  - 전략 비교 / 재현 / 백테스트 설정을 쉽게 하고,
  - 최적화 변수(`self.vars`) 관리와 GA(유전 알고리즘) 설정을 명확히 한다.
- 실제 작성된 문서들(`Condition_Tick_902_905_update_2.md`, `Condition_Tick_900_920.md` 등)의 패턴을 반영한다.

---

## 2. 공통 작성 규칙

### 2.1 파일 위치 및 디렉토리 구조

- **Tick 전략 문서**
  - 위치: `docs/Condition/Tick/`
  - 예: `docs/Condition/Tick/Condition_Tick_902_905_update_2.md`

- **Min 전략 문서**
  - 위치: `docs/Condition/Min/` (현재 미사용, 향후 확장 예정)
  - 예: `docs/Condition/Min/Condition_Study_5_9010_min.md`

- **디렉토리 구조**
  ```
  docs/
  ├── Guideline/
  │   ├── Back_Testing_Guideline_Tick.md
  │   ├── Back_Testing_Guideline_Min.md
  │   └── Condition_Document_Template_Guideline.md  # 본 문서
  └── Condition/
      ├── Tick/
      │   ├── Condition_Tick_902.md
      │   ├── Condition_Tick_902_905_update_2.md
      │   └── Condition_Tick_900_920.md
      └── Min/
          └── (향후 분봉 전략 문서)
  ```

### 2.2 파일명 규칙

- **Tick 전략 문서**
  - 예: `Condition_Tick_900_920.md`, `Condition_Tick_902_905_update_2.md`
  - 기본 형식:
    `Condition_Tick_<시작분초>_<종료분초>[_update_<버전>].md`
  - `update_2`: 두 번째 업데이트 버전을 의미

- **Min 전략 문서**
  - 예: `Condition_Study_5_9010_min.md`
  - 기본 형식:
    `Condition_Study_<스터디번호>_<시간구간>_min.md`

### 2.3 문서 상단 참조 표기 방식

모든 조건식 문서의 상단에는 다음과 같은 참조 표기를 포함해야 한다:

- **Tick 전략 문서 상단 예시**:
  ```markdown
  # 조건식(Condition)

  - STOM 주식 자동거래에 사용하기 위한 조건식 문서
  - [[Back_Testing_Guideline_Tick]] 을(를) 기반으로 작성한 Tick 조건식
  - [[Condition_Document_Template_Guideline]] 을(를) 바탕으로 템플릿 구조를 적용한 문서
  ```

- **Min 전략 문서 상단 예시**:
  ```markdown
  # 조건식(Condition) - 분봉(Minute) 기반

  - STOM 주식 자동거래에 사용하기 위한 분봉 조건식 문서
  - [[Back_Testing_Guideline_Min]] 을(를) 기반으로 작성
  - [[Condition_Document_Template_Guideline]] 을(를) 바탕으로 템플릿 구조를 적용한 문서
  ```

### 2.4 코드/전략 이름 규칙 (요약)

- **Tick 전략 명명 규칙**
  - `C_T_900_920_U1_B` : Tick, 09:00~09:20, Update1, Buy
  - `C_T_900_920_U1_S` : Sell
  - `C_T_900_920_U1_BO` : Buy Optimize 조건식
  - `C_T_900_920_U1_BOR` : Buy Optimize Range
  - `C_T_900_920_U1_SO`, `..._SOR`, `..._OR`, `..._GAR` 등

- **Min 전략 명명 규칙**
  - `C_S_5_B_Min` : Study 5, Min, Buy
  - `C_S_5_S_Min` : Sell
  - `C_S_5_BO_Min`, `C_S_5_BOR_Min`, `C_S_5_SO_Min`, `C_S_5_SOR_Min`, `C_S_5_OR_Min`, `C_S_5_GAR_Min` 등

**명명 규칙 요소 설명**:
- `C` = Condition (조건식)
- `T` = Tick, `S` = Study (분봉 스터디)
- 숫자 = 시간 또는 전략 번호
- `U1`, `U2` = Update 버전
- `B` = Buy, `S` = Sell
- `BO` = Buy Optimize, `SO` = Sell Optimize
- `BOR` = Buy Optimize Range, `SOR` = Sell Optimize Range
- `OR` = Optimize Range (통합), `GAR` = GA Range

### 2.5 공통 원칙

- 조건식은 다음 흐름을 따른다:
  1. **기본 필터** (가격, 거래대금, 종목 타입 등)
  2. **추세/모멘텀/거래 강도 필터**
  3. **시간대별 세부 조건** (장초/장중/장마감)
  4. **위험 관리 / 예외 처리**
- 최적화 조건식은 동일 로직에서 **임계값만 `self.vars[i][1]`** 로 바꾼 구조를 사용한다.
- 최적화 범위는
  - 일반 범위: `[[시작, 끝, 간격], 기본값]`
  - GA 범위(리스트): `[[값1, 값2, ...], 기본값]`
  형식으로 정의한다.

### 2.6 **[필수] 매수/매도 초기값 및 로직 패턴**

**🚨 이 규칙을 반드시 준수해야 합니다:**

#### 매수 조건식 패턴
```python
# ✅ 올바른 패턴
매수 = True  # 반드시 True로 시작

if not (조건1):
    매수 = False
elif not (조건2):
    매수 = False
elif not (조건3):
    매수 = False
# ... (추가 조건들)

# 매수 호출
if 매수:
    self.Buy(종목코드, 종목명, 매수수량, 현재가, 매도호가1, 매수호가1, 데이터길이)
```

```python
# ❌ 잘못된 패턴
매수 = False  # False로 시작하면 안 됨

if 조건1:
    매수 = True  # 이 패턴은 조건 최적화에서 사용할 수 없음
```

**매수 조건식 작성 규칙**:
1. **반드시 `매수 = True`로 시작**
2. 조건을 체크하면서 **불만족 시 `매수 = False`로 변경**
3. `if not (조건):` 또는 `elif not (조건):` 형태로 작성
4. 이 패턴은 **조건 최적화(optimiz_conditions.py)**에서 단위 조건들을 조합할 때 필수

#### 매도 조건식 패턴
```python
# ✅ 올바른 패턴
매도 = False  # 반드시 False로 시작

if 조건1:
    매도 = True
elif 조건2:
    매도 = True
elif 조건3:
    매도 = True
# ... (추가 조건들)

# 매도 호출
if 매도:
    self.Sell(종목코드, 종목명, 매도수량, 현재가, 매도호가1, 매수호가1, 강제청산)
```

```python
# ❌ 잘못된 패턴
매도 = True  # True로 시작하면 안 됨

if not (조건1):
    매도 = False  # 이 패턴은 조건 최적화에서 사용할 수 없음
```

**매도 조건식 작성 규칙**:
1. **반드시 `매도 = False`로 시작**
2. 조건을 체크하면서 **만족 시 `매도 = True`로 변경**
3. `if 조건:` 또는 `elif 조건:` 형태로 작성
4. 이 패턴은 **조건 최적화(optimiz_conditions.py)**에서 단위 조건들을 조합할 때 필수

#### 조건 최적화 시스템과의 연관성

`backtester/optimiz_conditions.py`에서는 단위 조건들을 다음과 같이 조합합니다:

```python
# 매수 조건 조합 (ShowTopCondlist 함수)
buyconds = 'if ' + ':\n    매수 = False\nelif '.join(value[0]) + ':\n    매수 = False'

# 매도 조건 조합 (ShowTopCondlist 함수)
sellconds = 'if ' + ':\n    매도 = True\nelif '.join(value[1]) + ':\n    매도 = True'
```

이 시스템이 올바르게 작동하려면 **모든 조건식이 위 패턴을 준수**해야 합니다.

### 2.7 **[필수] self.vars 변수 인덱스 사용 규칙**

**🚨 이 규칙을 반드시 준수해야 합니다:**

#### 규칙 1: self.vars[0]은 고정값 전용
```python
# ✅ 올바른 사용
self.vars[0] = [[30], 30]  # 평균 틱수 고정값

# ❌ 잘못된 사용
self.vars[0] = [[20, 40, 10], 30]  # 최적화 범위를 넣으면 안 됨
```

**self.vars[0] 사용 규칙**:
- **오직 고정값만 저장** (예: 평균 틱수, 고정 기준값)
- 범위는 항상 `[[값], 값]` 형태로 단일 값만 포함
- 최적화 대상이 아닌 상수값에만 사용

#### 규칙 2: 최적화 변수는 self.vars[1]부터 시작
```python
# ✅ 올바른 사용
self.vars[0] = [[30], 30]              # 고정값
self.vars[1] = [[6.0, 10.0, 1.0], 8.0] # 첫 번째 최적화 변수
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]  # 두 번째 최적화 변수
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]  # 세 번째 최적화 변수
# ...

# ❌ 잘못된 사용
self.vars[0] = [[6.0, 10.0, 1.0], 8.0] # self.vars[0]에 최적화 변수를 넣으면 안 됨
```

#### 규칙 3: 인덱스는 연속으로 사용 (공백 없이)

**🔢 인덱스 번호 할당 원칙**:

1. **`self.vars[0]`**: 고정값 전용 - 평균 틱수 등 상수값만 사용
2. **`self.vars[1]` 이후**: 최적화 변수를 **연속된 번호**로 할당
   - 매수 변수 먼저, 이어서 매도 변수
   - **반드시 번호를 건너뛰지 않고 연속으로 사용**

**✅ 올바른 인덱스 사용 패턴**:
```python
# 패턴 1: 매수 3개, 매도 2개
self.vars[0] = [[30], 30]                   # 고정값

self.vars[1] = [[6.0, 10.0, 1.0], 8.0]      # 매수 변수 1
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]       # 매수 변수 2
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]       # 매수 변수 3

self.vars[4] = [[28.0, 30.0, 0.5], 29.5]    # 매도 변수 1
self.vars[5] = [[-3.0, -1.0, 0.5], -2.0]    # 매도 변수 2
# ✅ vars[1]~[5]까지 연속 사용
```

```python
# 패턴 2: 매수 5개, 매도 3개
self.vars[0] = [[30], 30]                   # 고정값

self.vars[1] = [[6.0, 10.0, 1.0], 8.0]      # 매수 변수 1
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]       # 매수 변수 2
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]       # 매수 변수 3
self.vars[4] = [[0.3, 1.0, 0.2], 0.5]       # 매수 변수 4
self.vars[5] = [[5.0, 8.0, 1.0], 6.0]       # 매수 변수 5

self.vars[6] = [[28.0, 30.0, 0.5], 29.5]    # 매도 변수 1
self.vars[7] = [[-3.0, -1.0, 0.5], -2.0]    # 매도 변수 2
self.vars[8] = [[4.0, 6.0, 0.5], 5.0]       # 매도 변수 3
# ✅ vars[1]~[8]까지 연속 사용
```

**❌ 잘못된 인덱스 사용 패턴**:
```python
# ❌ 오류 1: 인덱스 건너뛰기
self.vars[0] = [[30], 30]                   # 고정값
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]      # 매수 변수 1
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]       # ❌ vars[2]가 없음
self.vars[7] = [[5, 10, 1], 7]              # ❌ vars[4], [5], [6]이 없음

# ❌ 오류 2: 매수/매도 순서 섞임
self.vars[0] = [[30], 30]                   # 고정값
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]      # 매수
self.vars[2] = [[28.0, 30.0, 0.5], 29.5]    # 매도
self.vars[3] = [[1.5, 3.0, 0.5], 2.0]       # ❌ 매수 (매도 다음에 다시 매수 오면 안 됨)

# ❌ 오류 3: vars[0]에 최적화 변수
self.vars[0] = [[6.0, 10.0, 1.0], 8.0]      # ❌ vars[0]은 고정값만
```

**인덱스 연속성 규칙 요약**:
- `self.vars[0]`: 고정값 (반드시 단일값 `[[값], 값]` 형태)
- `self.vars[1]`부터: 매수 변수 나열
- 매수 변수 끝난 다음 인덱스부터: 매도 변수 나열
- **중간에 번호를 건너뛰지 말 것**
- 사용하지 않는 변수는 정의하지 말 것

**실제 사용 예시**:
```python
# 매수 조건 5개, 매도 조건 3개인 경우
self.vars[0] = [[30], 30]                   # 고정값: 평균 틱수

# 매수 변수 (vars[1]~[5])
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]      # 등락율 상한
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]       # 시가등락율 하한
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]       # 시가등락율 상한
self.vars[4] = [[0.3, 1.0, 0.2], 0.5]       # 시가대비등락율 하한
self.vars[5] = [[5.0, 8.0, 1.0], 6.0]       # 시가대비등락율 상한

# 매도 변수 (vars[6]~[8])
self.vars[6] = [[28.0, 30.0, 0.5], 29.5]    # 등락율 상한가
self.vars[7] = [[-3.0, -1.0, 0.5], -2.0]    # 손실 수익률
self.vars[8] = [[4.0, 6.0, 0.5], 5.0]       # 수익률 상한

# ✅ vars[0]~[8]까지 총 9개 사용 (고정값 1개 + 매수 5개 + 매도 3개)
```

**인덱스 검증 방법**:

1. **전체 인덱스 연속성 검증**:
   ```python
   # self.vars에서 사용된 모든 인덱스 추출 (vars[0] 제외)
   사용된_인덱스 = [1, 2, 3, 4, 5, 6, 7, 8]  # 실제 사용한 인덱스 (vars[0] 제외)

   # vars[0] 검증
   if 0 in self.vars:
       if len(self.vars[0][0]) != 1:  # [[값], 값] 형태 확인
           print("❌ 오류: vars[0]은 고정값 전용입니다. [[값], 값] 형태로 작성하세요.")

   # vars[1]부터 시작 확인
   if 사용된_인덱스[0] != 1:
       print(f"❌ 오류: vars[1]부터 시작해야 합니다. 현재: vars[{사용된_인덱스[0]}]")

   # 연속성 확인
   for i in range(len(사용된_인덱스) - 1):
       if 사용된_인덱스[i+1] - 사용된_인덱스[i] != 1:
           print(f"❌ 오류: vars[{사용된_인덱스[i]}]와 vars[{사용된_인덱스[i+1]}] 사이에 건너뛰기 발견")
           print(f"   → vars[{사용된_인덱스[i]+1}]을(를) 추가하거나 불필요한 인덱스를 제거하세요")

   # 모든 검증 통과
   if all checks passed:
       print(f"✅ 인덱스 검증 성공: vars[0]=고정값, vars[1]~vars[{사용된_인덱스[-1]}]=최적화 변수")
   ```

2. **매수/매도 변수 구분 확인**:
   ```python
   # 매수 변수 개수 확인 (예: 5개)
   매수_변수_개수 = 5
   매도_변수_시작_인덱스 = 1 + 매수_변수_개수  # vars[6]부터 매도 시작

   # 매도 변수 개수 확인 (예: 3개)
   매도_변수_개수 = 3

   # 전체 변수 개수 확인
   전체_변수_개수 = 매수_변수_개수 + 매도_변수_개수  # 8개
   예상_마지막_인덱스 = 전체_변수_개수  # vars[8]

   if 사용된_인덱스[-1] == 예상_마지막_인덱스:
       print(f"✅ 변수 개수 확인: 매수 {매수_변수_개수}개 + 매도 {매도_변수_개수}개 = 총 {전체_변수_개수}개")
   else:
       print(f"❌ 오류: 예상 마지막 인덱스 vars[{예상_마지막_인덱스}], 실제 vars[{사용된_인덱스[-1]}]")
   ```

3. **실전 검증 예시**:
   ```python
   # 매수 3개, 매도 2개인 경우
   # 예상: vars[0]=고정값, vars[1~3]=매수, vars[4~5]=매도

   # vars[0] 검증
   assert self.vars[0] == [[30], 30], "vars[0]은 고정값 형태여야 함"

   # 연속성 검증
   expected_indices = [1, 2, 3, 4, 5]
   actual_indices = sorted([k for k in self.vars.keys() if k != 0])

   assert actual_indices == expected_indices, \
       f"인덱스 불연속: 예상={expected_indices}, 실제={actual_indices}"

   print("✅ 모든 인덱스 규칙 준수 확인 완료")
   ```

#### 규칙 4: 각 변수마다 주석 필수
```python
# ✅ 올바른 주석
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]  # 등락율 상한: 6.0%~10.0%, 1.0% 간격, 범위 갯수: 5
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]   # 시가등락율 하한: 1.5%~3.0%, 0.5% 간격, 범위 갯수: 4

# ❌ 불충분한 주석
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]  # 등락율
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]   # 주석 없음
```

**주석 작성 규칙**:
- 변수의 의미 (예: 등락율 상한, 시가등락율 하한)
- 범위 (예: 6.0%~10.0%)
- 간격 (예: 1.0%)
- 범위 개수 계산 (예: (10.0 - 6.0) / 1.0 + 1 = 5개)

### 2.8 **[필수] 조건식 작성 시 if/elif 체인 구조**

**🚨 이 규칙을 반드시 준수해야 합니다:**

```python
# ✅ 올바른 구조
매수 = True

if not (관심종목 == 1):
    매수 = False
elif not (1000 < 현재가 <= 50000):  # elif 사용
    매수 = False
elif not (1.0 < 등락율 <= 8.0):    # elif 사용
    매수 = False
elif 시분초 < 90200:                # elif + 중첩 if
    if 시가총액 < 3000:
        if not (체결강도 >= 50):
            매수 = False
        elif not (회전율 > 2):       # 중첩된 elif도 OK
            매수 = False
    else:
        매수 = False
else:
    매수 = False

# ❌ 잘못된 구조
매수 = True

if not (관심종목 == 1):
    매수 = False

if not (1000 < 현재가 <= 50000):  # 독립된 if 사용 - 잘못됨
    매수 = False

if not (1.0 < 등락율 <= 8.0):    # 독립된 if 사용 - 잘못됨
    매수 = False
```

**if/elif 체인 구조 규칙**:
1. **첫 조건만 `if`, 나머지는 `elif`** 사용
2. 독립된 `if` 여러 개 사용 금지
3. 시간대별 분기는 `elif`로 연결
4. 중첩된 조건 내부에서는 새로운 if/elif 체인 시작 가능

### 2.9 준수 여부 셀프 체크 절차 (필수)

조건식을 작성한 뒤, 아래 **3단계 점검**을 거쳐야 한다. 최종 문서 업로드 전 반드시 체크리스트를 기록(예: 문서 하단 체크 완료 기록)한다.

#### 1) 헤더/개요 정합성 확인

- [ ] 상단 참조 3줄(Tick/Min 구분) 누락 여부 확인
  ```markdown
  - STOM 주식 자동거래에 사용하기 위한 조건식 문서
  - [[Back_Testing_Guideline_Tick]] 을(를) 기반으로 작성한 Tick 조건식
  - [[Condition_Document_Template_Guideline]] 을(를) 바탕으로 템플릿 구조를 적용한 문서
  ```
- [ ] 개요 섹션의 5대 필수 정보 기입 여부 확인
  - 전략 시간 구간
  - 대상 종목 범위
  - 전략 타입
  - 핵심 변수/지표
  - 업데이트 이력 (해당 시)
- [ ] 전략 시간대가 파일명 및 전략 ID와 일치하는지 확인
  - 예: `Condition_Tick_902_905.md` ↔ 09:02~09:05 ↔ `C_T_902_905_B`

#### 2) 조건식 구조·변수 검증

- [ ] **공통 계산 지표가 조건식/최적화 양쪽에 동일하게 정의**되어 있는지 확인
  ```python
  # ✅ 올바름 - 공통 계산 지표를 상단에 한 번만 정의
  # ================================
  #  공통 계산 지표
  # ================================
  전일종가 = 현재가 / (1 + (등락율 / 100))
  시가등락율 = ((시가 - 전일종가) / 전일종가) * 100
  ```
- [ ] **self.vars 인덱스가 연속으로 사용**되었는지 확인
  - `self.vars[0]`: 고정값 전용 (`[[값], 값]` 형태)
  - `self.vars[1]` 이후: 매수 변수 → 매도 변수 순서로 **연속된 번호** 사용
  - **중간에 번호를 건너뛰지 않았는지** 확인 필수

  **검증 방법**:
  ```python
  # 문서에서 사용된 모든 인덱스를 찾아 리스트로 작성
  # 예시: 매수 5개 (vars[1~5]), 매도 3개 (vars[6~8])
  매수_변수_개수 = 5
  매도_변수_개수 = 3

  # 예상되는 인덱스 리스트
  expected_indices = list(range(1, 1 + 매수_변수_개수 + 매도_변수_개수))
  # expected_indices = [1, 2, 3, 4, 5, 6, 7, 8]

  # 실제 사용된 인덱스 (vars[0] 제외)
  actual_indices = [1, 2, 3, 4, 5, 6, 7, 8]  # 문서에서 실제 사용한 인덱스

  # 1) vars[0] 고정값 검증
  if 0 in self.vars:
      if len(self.vars[0][0]) != 1:
          print("❌ vars[0]은 고정값 전용입니다. [[값], 값] 형태로 작성하세요.")

  # 2) vars[1]부터 시작 검증
  if actual_indices[0] != 1:
      print(f"❌ vars[1]부터 시작해야 합니다. 현재: vars[{actual_indices[0]}]")

  # 3) 전체 연속성 검증
  if actual_indices != expected_indices:
      print(f"❌ 인덱스 불연속 또는 누락: 예상={expected_indices}, 실제={actual_indices}")
      # 어디서 건너뛰었는지 찾기
      for i in range(len(actual_indices) - 1):
          if actual_indices[i+1] - actual_indices[i] != 1:
              print(f"   → vars[{actual_indices[i]}]와 vars[{actual_indices[i+1]}] 사이 건너뛰기")
  else:
      print(f"✅ 인덱스 연속성 검증 통과: vars[0]=고정값, vars[1]~vars[{actual_indices[-1]}]=최적화 변수")
  ```
- [ ] **`self.Buy`/`self.Sell` 호출 인자 순서**가 STOM 실행 코드와 동일한지 확인
  ```python
  # backtester/ 및 utility/ 내 스크립트 기준
  self.Buy(종목코드, 종목명, 매수수량, 현재가, 매도호가1, 매수호가1, 데이터길이)
  self.Sell(종목코드, 종목명, 매도수량, 현재가, 매도호가1, 매수호가1, 강제청산)
  ```
- [ ] **매수는 `True`로 시작, 매도는 `False`로 시작** (2.6절 참조)
- [ ] **`self.vars[0]`은 고정값만 사용** (2.7절 참조)
- [ ] **if/elif 체인 구조 준수** (2.8절 참조)

#### 3) 검토/개선 기록 남기기

- [ ] **조건식 개선 방향 연구 섹션**에 최소 3개 아이디어와 우선순위 작성
  - 예: High Priority, Medium Priority, Low Priority
- [ ] **최적화 범위를 정의했다면** 총 경우의 수·예상 시간 계산 및 GA/OR 활용 여부 기재
  ```python
  # 매수 총 경우의 수: 5 × 4 × 4 × 4 × 4 × 4 × 3 × 3 = 30,720
  # 매도 총 경우의 수: 5 × 5 × 5 × 5 = 625
  # 통합 경우의 수: 30,720 × 625 = 19,200,000
  # 예상 시간: 비현실적 → GA/OR 활용 권장
  ```
- [ ] **체크 완료 일자와 검토자**(또는 검토 도구)를 문서 하단에 남긴다
  ```markdown
  ## 검증 기록
  - 2025-11-24, 셀프 체크 완료
  - 검증자: [이름] 또는 자동 검증 스크립트
  ```

### 2.10 개요(Overview) 섹션 작성 가이드

모든 조건식 문서에는 **개요** 섹션이 필수이며, 다음 정보를 포함해야 한다:

**필수 포함 사항**:
1. **전략 시간 구간**: 정확한 시작/종료 시간 (예: 09:00:00 ~ 09:05:00)
2. **대상 종목 범위**: 시가총액, 가격대, 유동성 조건
3. **전략 타입**: 갭상승, 모멘텀, 돌파, 추세추종, 스캘핑 등
4. **핵심 전략**: 어떤 변수/지표를 중심으로 하는지
5. **업데이트 이력**: (해당하는 경우) 이전 버전 대비 변경사항

**작성 예시 (Tick 전략)**:
```markdown
## 개요

본 문서는 STOM 주식 자동거래 시스템에서 **장 초반 09:02:00 ~ 09:05:00 (Tick 데이터)** 구간에 사용하는 조건식을 정의한다.

- **대상 구간**: 09:02:00 ~ 09:05:00 (장초 3분)
- **대상 종목**: 시가총액 3,000억 미만, 최소 거래대금 50억 이상
- **전략 타입**: 갭상승 + 거래대금 가속 모멘텀 추종
- **핵심 변수**: 체결강도, 초당거래대금, 시가등락율, 일일거래대금각도

**Update 2의 주요 변경사항**:
- 902 전략: 체결강도 하한값 100 → 50으로 완화
- 902 전략: 회전율 조건 명확화
- 902 전략: 당일거래대금각도 하한값 1 → 5로 강화
```

**작성 예시 (Min 전략)**:
```markdown
## 개요

본 문서는 **09:00~10:00 구간 1분봉 데이터**를 활용한 추세 추종 전략을 정의한다.

- **사용 봉**: 1분봉
- **전략 지표**: 20/60 분봉 이동평균, RSI, MACD
- **대상 종목**: 분당거래대금 상위, 시가총액 1,000억~1조
- **손익 목표**: 손절 -2.5%, 익절 +5%
```

### 2.11 **[필수] 범위 함수 및 변수 검증 규칙**

**🚨 이 규칙은 `back_code_test.py`의 검증 로직에 기반한 필수 준수 사항입니다:**

STOM 백테스트 엔진은 조건식을 실행하기 전에 `backtester/back_code_test.py`의 검증 로직을 통해 코드를 검사합니다. 검증에 실패하면 백테스트가 실행되지 않으므로, 아래 규칙을 반드시 준수해야 합니다.

#### 규칙 1: 범위 함수는 반드시 괄호와 함께 사용 (CheckFactor 검증)

**검증 대상 범위 함수 목록** (`back_code_test.py` lines 52-59):
```python
gugan_factors = [
    '이동평균', '최고현재가', '최저현재가', '초당거래대금평균', '체결강도평균',
    '최고체결강도', '최저체결강도', '누적초당매수수량', '누적초당매도수량',
    '최고초당매수수량', '최고초당매도수량', '당일거래대금각도', '전일비각도',
    '분당거래대금평균', '누적분당매수수량', '누적분당매도수량', '최고분당매수수량',
    '최고분당매도수량', '최고분봉고가', '최저분봉저가'
]
```

**✅ 올바른 사용**:
```python
# 단일 인자: 범위값만 지정
이동평균값 = 이동평균(30)
최고가 = 최고현재가(20)
체결강도 = 체결강도평균(10)

# 두 인자: 범위값 + 오프셋 지정
이동평균값 = 이동평균(30, 1)    # 30틱 이동평균, 1틱 전
최고가 = 최고현재가(20, 2)      # 20틱 중 최고가, 2틱 전
```

**❌ 잘못된 사용**:
```python
# 괄호 없이 숫자만 붙이는 경우 - 검증 실패
이동평균값 = 이동평균30          # ❌ 오류: CheckFactor 검증 실패
최고가 = 최고현재가20            # ❌ 오류: CheckFactor 검증 실패
체결강도 = 체결강도평균10        # ❌ 오류: CheckFactor 검증 실패

# 변수명에 범위 함수 이름을 포함한 경우도 주의
이동평균_조건 = True             # ⚠️ 주의: 변수명에 '이동평균' 포함 시 검증 오류 가능
```

**검증 에러 메시지**:
```
이동평균(30), 이동평균(30, 1) 형태로 사용하십시오.
최고현재가(20), 최고현재가(20, 1) 형태로 사용하십시오.
체결강도평균(10), 체결강도평균(10, 1) 형태로 사용하십시오.
```

#### 규칙 2: self.vars 형식 검증 (`back_code_test.py` lines 26-38)

**self.vars 형식 규칙**:
```python
# 올바른 형식: [[시작값, 끝값, 간격], 초기값]
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]   # ✅ 정상
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]    # ✅ 정상
self.vars[0] = [[30], 30]                # ✅ 고정값 정상

# 잘못된 형식
self.vars[1] = [[6.0, 10.0], 8.0]        # ❌ 간격 누락
self.vars[2] = [1.5, 3.0, 0.5]           # ❌ 중첩 리스트 누락
self.vars[3] = [[1.5, 3.0, 0.5, 2.0]]    # ❌ 초기값 분리 안됨
```

**검증 에러 메시지**:
```
self.vars[1]의 범위 설정 방법 오류
→ 올바른 형식: [[시작값, 끝값, 간격], 초기값]
```

#### 규칙 3: 범위 값 개수 제한 (최대 20개)

각 변수의 범위 설정 시, **생성되는 값의 개수가 20개를 초과하면 안 됩니다**.

**값 개수 계산 공식**:
```python
값_개수 = (끝값 - 시작값) / 간격 + 1
```

**✅ 올바른 범위 설정**:
```python
# 값 개수: (10.0 - 6.0) / 1.0 + 1 = 5개 ✅
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]

# 값 개수: (3.0 - 1.5) / 0.5 + 1 = 4개 ✅
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]

# 값 개수: (100 - 1) / 5 + 1 = 20개 ✅ (경계값)
self.vars[3] = [[1, 100, 5], 50]
```

**❌ 잘못된 범위 설정**:
```python
# 값 개수: (100 - 1) / 1 + 1 = 100개 ❌ (20개 초과)
self.vars[1] = [[1, 100, 1], 50]

# 값 개수: (10.0 - 1.0) / 0.1 + 1 = 91개 ❌ (20개 초과)
self.vars[2] = [[1.0, 10.0, 0.1], 5.0]

# 값 개수: (50 - 10) / 1 + 1 = 41개 ❌ (20개 초과)
self.vars[3] = [[10, 50, 1], 30]
```

**검증 에러 메시지**:
```
self.vars[1]의 범위 설정 갯수 20개 초과
→ 현재 설정으로 생성되는 값: 100개
→ 간격을 늘리거나 범위를 줄여주세요
```

**범위 조정 예시**:
```python
# ❌ 원래 설정: 100개 생성
self.vars[1] = [[1, 100, 1], 50]

# ✅ 해결 방법 1: 간격을 5로 증가
self.vars[1] = [[1, 100, 5], 50]  # 20개 생성

# ✅ 해결 방법 2: 범위를 축소
self.vars[1] = [[40, 60, 1], 50]  # 21개 생성 → 간격 2로 조정하면 11개
self.vars[1] = [[40, 60, 2], 50]  # 11개 생성
```

#### 규칙 4: 간격 부호 검증

**시작값과 끝값의 대소 관계에 따라 간격 부호가 올바른지 검증합니다**:

**✅ 올바른 간격 부호**:
```python
# 시작 < 끝 → 간격은 양수
self.vars[1] = [[1.0, 10.0, 1.0], 5.0]    # ✅ 1.0 < 10.0, 간격 +1.0
self.vars[2] = [[5, 20, 5], 10]           # ✅ 5 < 20, 간격 +5

# 시작 > 끝 → 간격은 음수
self.vars[3] = [[10.0, 1.0, -1.0], 5.0]   # ✅ 10.0 > 1.0, 간격 -1.0
self.vars[4] = [[20, 5, -5], 10]          # ✅ 20 > 5, 간격 -5
```

**❌ 잘못된 간격 부호**:
```python
# 시작 < 끝인데 간격이 음수 → 검증 실패
self.vars[1] = [[1.0, 10.0, -1.0], 5.0]   # ❌ 1.0 < 10.0인데 간격 -1.0
self.vars[2] = [[5, 20, -5], 10]          # ❌ 5 < 20인데 간격 -5

# 시작 > 끝인데 간격이 양수 → 검증 실패
self.vars[3] = [[10.0, 1.0, 1.0], 5.0]    # ❌ 10.0 > 1.0인데 간격 +1.0
self.vars[4] = [[20, 5, 5], 10]           # ❌ 20 > 5인데 간격 +5
```

**검증 에러 메시지**:
```
self.vars[1]의 범위 간격 부호 오류
→ 시작값(1.0) < 끝값(10.0)인데 간격이 음수(-1.0)입니다
→ 간격을 양수로 변경하세요: [[1.0, 10.0, 1.0], 5.0]
```

#### 규칙 5: 검증 통과 체크리스트

조건식 작성 후 아래 항목을 모두 확인하세요:

- [ ] **범위 함수 괄호 사용**: 모든 범위 함수(`이동평균`, `최고현재가` 등)를 괄호와 함께 사용
  ```python
  # ✅ 올바름: 이동평균(30), 최고현재가(20, 1)
  # ❌ 잘못됨: 이동평균30, 최고현재가20
  ```

- [ ] **self.vars 형식**: `[[시작, 끝, 간격], 초기값]` 형태 준수
  ```python
  # ✅ 올바름: [[6.0, 10.0, 1.0], 8.0]
  # ❌ 잘못됨: [[6.0, 10.0], 8.0] 또는 [6.0, 10.0, 1.0, 8.0]
  ```

- [ ] **범위 값 개수**: 각 변수의 값 개수가 20개 이하
  ```python
  # 계산: (끝값 - 시작값) / 간격 + 1 ≤ 20
  # ✅ 예: (10.0 - 6.0) / 1.0 + 1 = 5개
  # ❌ 예: (100 - 1) / 1 + 1 = 100개 (20개 초과)
  ```

- [ ] **간격 부호**: 시작값 < 끝값이면 간격은 양수, 시작값 > 끝값이면 간격은 음수
  ```python
  # ✅ 올바름: [[1.0, 10.0, 1.0], ...] - 양수 간격
  # ✅ 올바름: [[10.0, 1.0, -1.0], ...] - 음수 간격
  # ❌ 잘못됨: [[1.0, 10.0, -1.0], ...] - 간격 부호 오류
  ```

#### 검증 실패 시 대처 방법

**1. 범위 함수 괄호 오류**:
```python
# 오류 메시지: "이동평균(30), 이동평균(30, 1) 형태로 사용하십시오."
# 해결: 모든 범위 함수에 괄호 추가
# 변경 전: 이동평균30
# 변경 후: 이동평균(30)
```

**2. 범위 값 20개 초과 오류**:
```python
# 오류 메시지: "self.vars[1]의 범위 설정 갯수 20개 초과"
# 해결 방법 1: 간격 증가
self.vars[1] = [[1, 100, 1], 50]    # 100개 → 오류
self.vars[1] = [[1, 100, 5], 50]    # 20개 → 정상

# 해결 방법 2: 범위 축소
self.vars[1] = [[1.0, 10.0, 0.1], 5.0]  # 91개 → 오류
self.vars[1] = [[3.0, 8.0, 0.5], 5.0]   # 11개 → 정상
```

**3. 간격 부호 오류**:
```python
# 오류 메시지: "self.vars[1]의 범위 간격 부호 오류"
# 해결: 간격 부호를 시작/끝값 관계에 맞게 수정
# 잘못됨: [[1.0, 10.0, -1.0], 5.0]
# 올바름: [[1.0, 10.0, 1.0], 5.0]  또는  [[10.0, 1.0, -1.0], 5.0]
```

#### 규칙 6: Range Step 정합성 검증 (Optuna 호환성)

**Optuna 최적화 엔진은 범위가 간격으로 정확히 나누어떨어지는지 검증합니다**. 나누어떨어지지 않으면 경고 메시지와 함께 범위가 자동 조정됩니다.

**정합성 공식**:
```python
(끝값 - 시작값) % 간격 == 0.0
```

**✅ 올바른 범위 설정**:
```python
# (3.0 - 1.5) / 0.5 = 3.0 → 정수 ✅
self.vars[1] = [[1.5, 3.0, 0.5], 2.0]   # 1.5, 2.0, 2.5, 3.0

# (10.0 - 6.0) / 1.0 = 4.0 → 정수 ✅
self.vars[2] = [[6.0, 10.0, 1.0], 8.0]  # 6.0, 7.0, 8.0, 9.0, 10.0

# (0.9 - 0.3) / 0.2 = 3.0 → 정수 ✅
self.vars[3] = [[0.3, 0.9, 0.2], 0.5]   # 0.3, 0.5, 0.7, 0.9
```

**❌ 잘못된 범위 설정**:
```python
# (1.0 - 0.3) / 0.2 = 3.5 → 정수 아님 ❌
self.vars[1] = [[0.3, 1.0, 0.2], 0.5]
# Optuna 경고: "The range is not divisible by step. It will be replaced by [0.3, 0.9]"

# (5.0 - 1.5) / 1.0 = 3.5 → 정수 아님 ❌
self.vars[2] = [[1.5, 5.0, 1.0], 3.0]
# Optuna 경고: "The range is not divisible by step. It will be replaced by [1.5, 4.5]"

# (10.0 - 6.0) / 0.3 = 13.333... → 정수 아님 ❌
self.vars[3] = [[6.0, 10.0, 0.3], 8.0]
# Optuna 경고: "The range is not divisible by step. It will be replaced by [6.0, 9.9]"
```

**Optuna 경고 메시지**:
```
UserWarning: The distribution is specified by [0.3, 1.0] and step=0.2,
but the range is not divisible by `step`.
It will be replaced by [0.3, 0.9].
```

**검증 방법**:
```python
# 모든 BOR/SOR/OR 범위에 대해 아래 검증 수행
def validate_range_step(start, end, step):
    if (end - start) % step != 0.0:
        print(f"❌ Range 오류: ({end} - {start}) % {step} = {(end - start) % step}")
        # 올바른 끝값 계산
        correct_end = start + int((end - start) / step) * step
        print(f"✅ 권장 수정: [[{start}, {correct_end}, {step}], ...]")
        return False
    return True

# 사용 예시
validate_range_step(0.3, 1.0, 0.2)   # ❌ False
validate_range_step(0.3, 0.9, 0.2)   # ✅ True
validate_range_step(6.0, 10.0, 1.0)  # ✅ True
```

**수정 방법**:
```python
# ❌ 원래 설정: (1.0 - 0.3) / 0.2 = 3.5
self.vars[4] = [[0.3, 1.0, 0.2], 0.5]

# ✅ 해결 방법 1: 끝값 조정 (아래로)
self.vars[4] = [[0.3, 0.9, 0.2], 0.5]  # (0.9 - 0.3) / 0.2 = 3.0

# ✅ 해결 방법 2: 끝값 조정 (위로)
self.vars[4] = [[0.3, 1.1, 0.2], 0.5]  # (1.1 - 0.3) / 0.2 = 4.0

# ✅ 해결 방법 3: 간격 조정
self.vars[4] = [[0.3, 1.0, 0.1], 0.5]  # (1.0 - 0.3) / 0.1 = 7.0
```

#### 규칙 7: NumPy 배열 호환성 (연쇄 비교 금지)

**NumPy 배열과 함께 사용하는 조건식에서는 Python의 연쇄 비교 구문이 작동하지 않습니다**. 백테스트 엔진에서 `ValueError: setting an array element with a sequence` 오류가 발생합니다.

**오류 원인**:
- Python 연쇄 비교: `a < b < c`는 `(a < b) and (b < c)`로 확장됨
- NumPy 배열에서는 중간 결과가 배열이 되어 불균일한 shape 생성

**❌ 잘못된 조건문 (연쇄 비교)**:
```python
# 단일 부등호 체인 - NumPy 배열에서 오류 발생
elif not (누적초당매수수량(30) * 0.5 < 누적초당매도수량(30) < 누적초당매수수량(30) * 1.0):
    매수 = False

# 최적화 조건식에서도 동일한 오류
elif not (누적초당매수수량(30) * self.vars[22] < 누적초당매도수량(30) < 누적초당매수수량(30) * self.vars[23]):
    매수 = False

# 다른 예시
if 5 < 등락율 < 10:  # ❌ NumPy 배열일 경우 오류
    매수 = True
```

**오류 메시지**:
```python
ValueError: setting an array element with a sequence.
The requested array has an inhomogeneous shape after 1 dimensions.
The detected shape was (2,) + inhomogeneous part.
```

**✅ 올바른 조건문 (AND 연산자 분리)**:
```python
# AND 연산자로 명시적 분리
elif not (누적초당매수수량(30) * 0.5 < 누적초당매도수량(30) and
          누적초당매도수량(30) < 누적초당매수수량(30) * 1.0):
    매수 = False

# 최적화 조건식
elif not (누적초당매수수량(30) * self.vars[22] < 누적초당매도수량(30) and
          누적초당매도수량(30) < 누적초당매수수량(30) * self.vars[23]):
    매수 = False

# 다른 예시
if 5 < 등락율 and 등락율 < 10:  # ✅ 올바름
    매수 = True

# 또는 더 명확하게
if (등락율 > 5) and (등락율 < 10):  # ✅ 올바름
    매수 = True
```

**단순화 가능한 경우**:
```python
# 연쇄 비교가 불필요한 경우 - 단순화 권장
# ❌ 복잡함
elif not (누적초당매수수량(30) * 0.5 < 누적초당매도수량(30) and
          누적초당매도수량(30) < 누적초당매수수량(30) * 1.0):
    매수 = False

# ✅ 단순화 (논리적으로 동일하다면)
elif not (누적초당매수수량(30) * 0.5 < 누적초당매도수량(30)):
    매수 = False
elif not (누적초당매도수량(30) < 누적초당매수수량(30)):
    매수 = False
```

**검증 체크리스트**:
- [ ] 모든 조건식에서 `a < b < c` 패턴 검색
- [ ] 연쇄 비교를 `a < b and b < c`로 변경
- [ ] 중복 계산이 있는 경우 변수로 추출하여 최적화
- [ ] 백테스트 실행하여 `ValueError` 오류 확인

**변경 전후 예시**:
```python
# ===== 변경 전 =====
# Line 204-206 (매수 조건식)
elif not (누적초당매수수량(30) * 0.5 < 누적초당매도수량(30) * 1.0):
    매수 = False
elif not (누적초당매도수량(30) * 1.0 < 누적초당매수수량(30) * 1.0):
    매수 = False

# Line 383 (매수 최적화 조건식)
elif not (누적초당매수수량(30) * self.vars[22] < 누적초당매도수량(30) < 누적초당매수수량(30) * self.vars[23]):
    매수 = False

# ===== 변경 후 =====
# Line 204-206 (매수 조건식) - 단순화
elif not (누적초당매수수량(30) * 0.5 < 누적초당매도수량(30)):
    매수 = False
elif not (누적초당매도수량(30) < 누적초당매수수량(30)):
    매수 = False

# Line 383 (매수 최적화 조건식) - AND 분리
elif not (누적초당매수수량(30) * self.vars[22] < 누적초당매도수량(30) and
          누적초당매도수량(30) < 누적초당매수수량(30) * self.vars[23]):
    매수 = False
```

---

## 3. Tick 조건식 템플릿

### 3.1 문서 기본 뼈대

새 Tick 전략 문서의 기본 구조는 아래를 그대로 사용하고, `{{...}}` 부분만 채운다.

```markdown
# 조건식(Condition) - Tick 기반 {{전략명}}

- STOM 주식 자동거래에 사용하기 위한 조건식 문서
- [[Back_Testing_Guideline_Tick]] 을(를) 기반으로 작성

## 목차
- [조건식(Condition) - Tick 기반 {{전략명}}](#조건식condition---tick-기반-전략명)
  - [목차](#목차)
  - [개요](#개요)
  - [가이드라인](#가이드라인)
    - [변수·이름 규칙](#변수이름-규칙)
- [Condition - Tick {{전략ID}}](#condition---tick-전략id)
  - [조건식](#조건식)
    - [매수 조건식 - {{C_T_..._B}}](#매수-조건식---c_t__b)
    - [매도 조건식 - {{C_T_..._S}}](#매도-조건식---c_t__s)
  - [최적화 조건식](#최적화-조건식)
    - [매수 최적화 조건식 - {{C_T_..._BO}}](#매수-최적화-조건식---c_t__bo)
    - [매수 최적화 범위 - {{C_T_..._BOR}}](#매수-최적화-범위---c_t__bor)
    - [매도 최적화 조건식 - {{C_T_..._SO}}](#매도-최적화-조건식---c_t__so)
    - [매도 최적화 범위 - {{C_T_..._SOR}}](#매도-최적화-범위---c_t__sor)
    - [매수·매도 통합 최적화 범위 - {{C_T_..._OR}}](#매수매도-통합-최적화-범위---c_t__or)
    - [이상 시간 계산](#이상-시간-계산)
    - [GA 최적화 범위 - {{C_T_..._GAR}}](#ga-최적화-범위---c_t__gar)
  - [조건식 개선 방향 연구](#조건식-개선-방향-연구)
  - [태그](#태그)
```

### 3.2 Tick 매수/매도 조건식 섹션 템플릿

#### 3.2.1 매수 조건식 작성 패턴

**필수 구조**:
1. **공통 계산 지표** - 재사용되는 계산식을 상단에 정의
2. **매수 = True 초기화**
3. **단계별 필터링** - if/elif 체인으로 순차 검증

**실제 예제 (Condition_Tick_902_905_update_2.md 기반)**:

```python
# ================================
#  공통 계산 지표
# ================================
전일종가          = 현재가 / (1 + (등락율 / 100))                      # 단위: 원
시가등락율        = ((시가 - 전일종가) / 전일종가) * 100                # 단위: 퍼센트
시가대비등락율    = ((현재가 - 시가) / 시가) * 100                      # 단위: 퍼센트
초당순매수금액    = (초당매수수량 - 초당매도수량) * 현재가 / 1_000_000   # 단위: 백만원

# ================================
#  매수 조건
# ================================
매수 = True

# 1. 공통 필터
if not (관심종목 == 1):
    매수 = False
elif not (1000 < 현재가 <= 50000):
    매수 = False
elif not (1.0 < 등락율 <= 8.0):
    매수 = False

# 2. 시간대별 전략 분기
elif 시분초 < 90200:  # 09:00:00 ~ 09:02:00
    if 시가총액 < 3000:
        if not (2.0 <= 시가등락율 < 4.0):
            매수 = False
        elif not (체결강도 >= 50 and 체결강도 <= 300):
            매수 = False
        elif not (당일거래대금각도(30) > 5 and 당일거래대금각도(30) < 30):
            매수 = False
        # ... 추가 조건
    else:
        매수 = False

elif 90200 <= 시분초 < 90500:  # 09:02:00 ~ 09:05:00
    if 시가총액 < 3000:
        if not (3.0 <= 시가대비등락율 < 8.0):
            매수 = False
        elif not (초당거래대금 / 초당거래대금평균(30) > 2.0):
            매수 = False
        # ... 추가 조건
    else:
        매수 = False

else:
    매수 = False

# 매수 호출
if 매수:
    self.Buy(종목코드, 종목명, 매수수량, 현재가, 매도호가1, 매수호가1, 데이터길이)
```

**핵심 작성 원칙**:
- **공통 계산 지표는 상단에 집중**: 재사용성과 가독성 향상
- **조건은 하드코딩으로 먼저 작성**: 최적화는 이후 단계
- **시간대별 분기는 명확하게**: `시분초` 변수로 구간 구분
- **시가총액 등 종목 특성별 차등 조건**: 대형주/소형주 구분
- **주석으로 로직 설명**: `# 1. 공통 필터`, `# 09:00~09:02` 등

#### 3.2.2 매도 조건식 작성 패턴

**필수 구조**:
1. **매도 = False 초기화**
2. **손절/익절 조건 우선**
3. **추세 훼손 조건**
4. **시간 기반 청산**

**실제 예제**:

```python
# ================================
#  공통 계산 지표
# ================================
시가대비등락율    = ((현재가 - 시가) / 시가) * 100

# ================================
#  매도 조건
# ================================
매도 = False

# 1. 상한가 직전 익절
if 등락율 > 29.5:
    매도 = True

# 2. 손절 조건
elif 시가대비등락율 < 0 and 수익률 <= -2.0 and 현재가 < 최저현재가(int(60), int(보유시간)):
    매도 = True

# 3. 시간 기반 청산
elif 보유시간 > 60 and 현재가 < 최저현재가(int(60), int(보유시간)):
    매도 = True

# 4. 익절/손절 조건 (시간대별)
elif 시분초 < 93000:
    if 수익률 >= 5 or 수익률 <= -5.0:
        매도 = True
    elif 최고수익률 > 6 and 최고수익률 * 0.6 >= 수익률:
        매도 = True
    # 5. 추세 훼손 조건 (시가총액별)
    elif 시가총액 < 10000:
        if 등락율각도(30) >= 10 and (초당매도수량 - 초당매수수량) >= 매수총잔량 * 0.5:
            if (현재가 / 현재가N(1) - 1) * 100 < -0.5:
                매도 = True

# 매도 호출
if 매도:
    self.Sell(종목코드, 종목명, 매도수량, 현재가, 매도호가1, 매수호가1, 강제청산)
```

**핵심 작성 원칙**:
- **손절/익절은 최우선**: 리스크 관리가 가장 중요
- **시간 기반 청산 로직**: 장초 전략은 빠른 청산 필요
- **추세 훼손 감지**: 등락율각도 + 매도압력 복합 판단
- **최고수익률 추적**: 고점 대비 일정 % 하락 시 익절

### 3.3 Tick 최적화 섹션 템플릿

#### 3.3.1 최적화 변수 설계 원칙

1. **변수 매핑 규칙**
   - `self.vars[0]`: 고정값 또는 평균 틱수 (예: `[[30], 30]`)
   - `self.vars[1]` 부터 순차적으로 매수 조건 변수 할당
   - 매도 조건 변수는 매수 변수 마지막 인덱스 다음부터 시작

2. **주석 작성 필수**
   - 각 변수의 의미, 범위, 간격, 범위 개수를 주석으로 명시
   - 예: `self.vars[1] = [[6.0, 10.0, 1.0], 8.0]  # 등락율 범위: 6.0%에서 10.0%까지 1.0% 간격, 범위 갯수: 5`

3. **범위 설정 가이드**
   - 각 변수당 후보값 최대 20개 이하
   - 간격은 의미 있는 단위로 (퍼센트는 0.5~1.0, 금액은 큰 단위)
   - 전체 조합 수를 계산하여 현실적인 시간 내 완료 가능한지 확인

#### 3.3.2 매수 최적화 조건식 예제

**실제 예제 (Condition_Tick_902_905_update_2.md 기반)**:

```python
# ================================
#  공통 계산 지표
# ================================
전일종가          = 현재가 / (1 + (등락율 / 100))
시가등락율        = ((시가 - 전일종가) / 전일종가) * 100
시가대비등락율    = ((현재가 - 시가) / 시가) * 100
초당순매수금액    = (초당매수수량 - 초당매도수량) * 현재가 / 1_000_000

매수 = True

if not (관심종목 == 1):
    매수 = False
elif 시분초 < 90200:  # 902 전략
    if not (1.0 < 등락율 <= self.vars[1][1]):  # 최적화 변수 1: 등락율 상한
        매수 = False
    elif 시가총액 < 3000:
        if not (self.vars[2][1] <= 시가등락율 < self.vars[3][1]):  # 변수 2,3: 시가등락율 범위
            매수 = False
        elif not (self.vars[4][1] <= 시가대비등락율 < self.vars[5][1]):  # 변수 4,5: 시가대비등락율 범위
            매수 = False
        elif not (회전율 > self.vars[6][1]):  # 변수 6: 최소 회전율
            매수 = False
        elif not (당일거래대금각도(30) > self.vars[7][1] and 당일거래대금각도(30) < 30):
            매수 = False
        elif not (체결강도 >= self.vars[10][1] and 체결강도 <= 300):  # 변수 10: 최소 체결강도
            매수 = False
    else:
        매수 = False

# 매수 호출
if 매수:
    self.Buy(종목코드, 종목명, 매수수량, 현재가, 매도호가1, 매수호가1, 데이터길이)
```

**변수 매핑표**:
- `self.vars[1]`: 등락율 상한 (%)
- `self.vars[2]`: 시가등락율 하한 (%)
- `self.vars[3]`: 시가등락율 상한 (%)
- `self.vars[4]`: 시가대비등락율 하한 (%)
- `self.vars[5]`: 시가대비등락율 상한 (%)
- `self.vars[6]`: 최소 회전율 (배)
- `self.vars[7]`: 당일거래대금각도 하한
- `self.vars[10]`: 최소 체결강도

#### 3.3.3 매수 최적화 범위 예제

```python
# 평균 틱수 고정값
self.vars[0] = [[30], 30]  # 평균 틱수 고정값: 30, 범위 갯수: 1

# 매수 최적화 범위 - 902 전략
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]         # 등락율 범위: 6.0%~10.0%, 1.0% 간격, 범위 갯수: 5
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]          # 시가등락율 하한: 1.5%~3.0%, 0.5% 간격, 범위 갯수: 4
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]          # 시가등락율 상한: 3.5%~5.0%, 0.5% 간격, 범위 갯수: 4
self.vars[4] = [[0.3, 1.0, 0.2], 0.5]          # 시가대비등락율 하한: 0.3%~1.0%, 0.2% 간격, 범위 갯수: 4
self.vars[5] = [[5.0, 8.0, 1.0], 6.0]          # 시가대비등락율 상한: 5.0%~8.0%, 1.0% 간격, 범위 갯수: 4
self.vars[6] = [[1.5, 3.0, 0.5], 2.0]          # 회전율: 1.5배~3.0배, 0.5배 간격, 범위 갯수: 4
self.vars[7] = [[3, 7, 2], 5]                  # 당일거래대금각도 하한: 3~7, 2 간격, 범위 갯수: 3
self.vars[10] = [[40, 60, 10], 50]             # 체결강도 하한: 40~60, 10 간격, 범위 갯수: 3

# 매수 총 경우의 수: 5 × 4 × 4 × 4 × 4 × 4 × 3 × 3 = 30,720
```

#### 3.3.4 매도 최적화 범위 예제

```python
# 매도 최적화 범위 (매수 변수 24 다음부터 25번부터 시작)
self.vars[25] = [[28.0, 30.0, 0.5], 29.5]      # 등락율 상한가: 28.0%~30.0%, 0.5% 간격, 범위 갯수: 5
self.vars[26] = [[-3.0, -1.0, 0.5], -2.0]      # 손실 수익률: -3.0%~-1.0%, 0.5% 간격, 범위 갯수: 5
self.vars[27] = [[4.0, 6.0, 0.5], 5.0]         # 수익률 상한: 4.0%~6.0%, 0.5% 간격, 범위 갯수: 5
self.vars[28] = [[-6.0, -4.0, 0.5], -5.0]      # 수익률 하한: -6.0%~-4.0%, 0.5% 간격, 범위 갯수: 5

# 매도 총 경우의 수: 5 × 5 × 5 × 5 = 625
```

#### 3.3.5 통합 최적화 범위 (OR)

핵심 변수만 묶어 탐색 효율 향상:

```python
OR_INDEX = [1, 2, 3, 7, 10, 25, 26, 27]  # 핵심 8개 변수만 선택
# 경우의 수: 5 × 4 × 4 × 3 × 3 × 5 × 5 × 5 = 90,000
```

#### 3.3.6 GA 최적화 범위 예제

**GA 변환 방법**: 범위를 리스트 형태로 변환

```python
# 일반 범위: [[시작, 끝, 간격], 기본값]
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]

# GA 범위: [[값1, 값2, ...], 기본값]
self.vars[1] = [[6.0, 7.0, 8.0, 9.0, 10.0], 8.0]
```

**실제 GA 범위 예제**:

```python
# GA 최적화 범위 - 매수 902 전략
self.vars[1] = [[6.0, 7.0, 8.0, 9.0, 10.0], 8.0]              # 등락율 범위, 범위 갯수: 5
self.vars[2] = [[1.5, 2.0, 2.5, 3.0], 2.0]                    # 시가등락율 하한, 범위 갯수: 4
self.vars[7] = [[3, 5, 7], 5]                                 # 당일거래대금각도 하한, 범위 갯수: 3

# GA 최적화 범위 - 매도
self.vars[25] = [[28.0, 28.5, 29.0, 29.5, 30.0], 29.5]        # 등락율 상한가, 범위 갯수: 5
self.vars[26] = [[-3.0, -2.5, -2.0, -1.5, -1.0], -2.0]        # 손실 수익률, 범위 갯수: 5
```

#### 3.3.7 예상 시간 계산 방법

```python
# 1. 각 변수의 범위 개수를 곱하여 총 경우의 수 계산
매수_경우의수 = 5 × 4 × 4 × 4 × 4 × 4 × 3 × 3  # = 30,720
매도_경우의수 = 5 × 5 × 5 × 5                    # = 625
총_경우의수 = 30,720 × 625                        # = 19,200,000

# 2. 각 경우에 소요 시간 가정 (예: 1경우당 1분)
예상_시간_분 = 19,200,000 분
예상_시간_시간 = 19,200,000 / 60 ≈ 320,000 시간
예상_시간_일 = 320,000 / 24 ≈ 13,333 일
예상_시간_년 = 13,333 / 365 ≈ 36.5 년

# 3. 비현실적 시간 → 범위 축소 또는 GA 사용 필요
```

---

## 4. Min(분봉) 조건식 템플릿

### 4.1 문서 기본 뼈대

```markdown
# 조건식(Condition) - 분봉(Minute) 기반 {{전략명}}

- STOM 주식 자동거래에 사용하기 위한 분봉 조건식 문서
- [[Back_Testing_Guideline_Min]] 을(를) 기반으로 작성

## 목차
- [[#조건식(Condition) - 분봉(Minute) 기반 {{전략명}}]]
  - [[#목차]]
  - [[#개요]]
  - [[#가이드라인]]
    - [[#변수·이름 규칙]]
- [[#Condition - Study {{스터디번호}}_{{시간구간}} (Min)]]
  - [[#조건식]]
    - [[#매수 조건식 - C_S_{{스터디번호}}_B_Min]]
    - [[#매도 조건식 - C_S_{{스터디번호}}_S_Min]]
  - [[#최적화 조건식]]
    - [[#매수 최적화 조건식 - C_S_{{스터디번호}}_BO_Min]]
    - [[#매수 최적화 범위 - C_S_{{스터디번호}}_BOR_Min]]
    - [[#매도 최적화 조건식 - C_S_{{스터디번호}}_SO_Min]]
    - [[#매도 최적화 범위 - C_S_{{스터디번호}}_SOR_Min]]
    - [[#매수·매도 통합 최적화 범위 - C_S_{{스터디번호}}_OR_Min]]
    - [[#GA 최적화 범위 - C_S_{{스터디번호}}_GAR_Min]]
```

### 4.2 Min 조건식/최적화 섹션 템플릿

Tick 템플릿과 구조는 동일하되, 다음 사항을 분명히 표기한다.

- `_Min` 접미사 사용 (예: `C_S_5_B_Min`)
- `초당` → `분당` 변환 규칙 (Tick 전략을 분봉으로 변환하는 경우)
- 변수는 모두 [[Back_Testing_Guideline_Min]] 의 `stock_buy_var2`, `stock_sell_var2` 기준으로 선택

```markdown
## 개요

{{사용 분봉 (예: 1분봉, 3분봉)}}
{{전략이 활용하는 지표(MA, MACD, RSI, BBand 등)}}

## 가이드라인

- 분봉(1분봉) 기준 종가/시가/고가/저가 사용
- 분당거래대금, 분당매수/매도량 등 분봉 전용 변수 활용

### 변수·이름 규칙

{{C_S_스터디번호_B/S/BO/SO/BOR/SOR/OR/GAR_Min 규칙 요약}}
```

---

## 5. 템플릿 사용 방법 (실무 절차)

이 섹션은 **사람 또는 AI가 새 조건식 문서를 만들 때 따라야 할 단계**를 정리한 것입니다.

### 5.1 새 전략 정의

1. 전략 타입 결정
   - Tick 또는 Min (또는 둘 다)
   - 장초/장중/장마감 중 어디에 초점을 둘지
2. 시간 구간 정의
   - 예: Tick → `09:00:00~09:05:00`, `09:00:00~09:20:00`
   - 예: Min → `09:00~10:00` 사이 1분봉 기준
3. 전략 의도 정리
   - 갭상승 초단타, 거래대금 가속 추세 추종, 눌림목 매수 등

### 5.2 변수 선택

1. Tick 전략:
   - `Back_Testing_Guideline_Tick.md` 의 **stock_buy_var / stock_sell_var** 목록에서만 변수 선택
   - 체결강도, 초당거래대금, 일일비, 회전율, 각도 계열(일일거래대금각도, 등락각도 등)을 우선 고려
2. Min 전략:
   - `Back_Testing_Guideline_Min.md` 의 **stock_buy_var2 / stock_sell_var2** 기준
   - 분봉시가/고가/저가/종가, 분당거래대금, 분당매수/매도량, TA-Lib 지표(MA, MACD, RSI, BBand 등) 활용

### 5.3 초기 조건식 설계

1. 템플릿의 **Tick 또는 Min 기본 뼈대**를 복사한다.
2. `개요`, `가이드라인`, `변수·이름 규칙` 섹션에 전략 정보를 채운다.
3. `매수 조건식`:
   - 기본 필터(가격, 일일거래대금, 회전율 등)부터 작성
   - 추세/거래 강도 조건(체결강도, 거래대금, 각도, 보조지표 등) 추가
   - 필요하면 시간대별로 `if 분초 < ...`, `elif ...` 형태로 세분화
4. `매도 조건식`:
   - 손절/익절 기준 먼저 정의
   - 추세 훼손(체결강도 급락, 거래대금 감소 등) 조건 추가
   - 시간 기반 / 전략 종료 시간 조건 추가

### 5.4 최적화 조건식 설계 (`self.vars` 매핑)

1. 매수/매도 조건식에서 **튜닝이 필요한 임계값**을 모두 리스트업한다.
   - 예: 최소 현재가, 최대 현재가, 최소 일일거래대금, 최소 체결강도, 최소 등락률, 손절/익절 %, 최대 보유시간 등
2. 각 임계값에 `self.vars[i]` 인덱스를 할당한다.
   - 문서에서 `self.vars[1]` 이 무엇을 의미하는지 명시적으로 적어둔다.
3. 최적화용 조건식(`BO`, `SO`) 에서는 하드코딩된 숫자를 모두 `self.vars[i][1]` 로 치환한다.

### 5.5 최적화 범위 설계 (`BOR`, `SOR`, `OR`)

1. 각 `self.vars[i]` 에 대해:
   - **넓은 범위 + 적당한 간격** 으로 1차 범위(그리드 탐색용)를 정의한다.
   - 예: `[[1.0, 15.0, 0.5], 1.5]` (1%~15%, 0.5% 간격)
2. Tick 가이드라인의 원칙 준수:
   - 한 변수당 후보값 최대 20개 내외
   - 전체 변수 수도 과도하게 늘리지 않도록 조정
3. 핵심 변수만 모아 `OR`(통합 최적화 세트) 를 정의한다.
   - 예: `OR_INDEX = [1, 3, 7, 9, 10, 21, 22, 24]`

### 5.6 GA 최적화 범위 설계 (`GAR`)

1. 1차 범위(BOR/SOR)를 기반으로, **핵심 변수들만 추려** 리스트 형태로 재정의한다.
   - 예: `self.vars[30] = [[1.0, 1.5, 2.0, 2.5, 3.0], 1.5]`
2. GA 2단계 전략:
   - 1단계: 넓은 후보 리스트로 대략적인 좋은 구간 탐색
   - 2단계: 1단계 결과 주변에 더 촘촘한 리스트를 다시 정의하여 재탐색

---

## 6. 조건식 개선 방향 연구 섹션 작성 가이드

모든 조건식 문서에는 **조건식 개선 방향 연구** 섹션을 포함하는 것을 강력히 권장한다. 이 섹션은 전략의 지속적인 개선을 위한 로드맵 역할을 한다.

### 6.1 필수 포함 카테고리

실제 문서(`Condition_Tick_902_905_update_2.md`)를 참고하여, 다음 카테고리 중 관련 있는 항목을 포함한다:

**1. 추가 지표 활용 연구**
- 현재 주석 처리된 지표 활성화 방안
- 새로운 복합 지표 개발
- 예시:
  ```markdown
  #### 1.1 누적거래대금비율
  - **정의**: `당일거래대금 / (시가총액 * 회전율 / 100) * 100`
  - **활용 방안**: 시가총액 대비 거래대금 비율로 종목 과열 여부 판단
  - **적용 예시**: `누적거래대금비율 > 150` → 과열 구간, 매수 제한
  - **최적화 범위**: `[[100, 200, 20], 150]`
  ```

**2. TA-Lib 보조지표 활용 연구**
- 볼린저 밴드 (BBU, BBM, BBL)
- MACD 지표
- RSI 지표
- 예시:
  ```markdown
  #### 2.1 볼린저 밴드 활용
  - **매수 조건 추가**: `BBL < 현재가 < BBM` (하단과 중심선 사이)
  - **활용 방안**: 과매도 구간에서 매수
  - **최적화 범위**: BBL 대비 현재가 위치 `[[0.98, 1.02, 0.01], 1.00]`
  ```

**3. 구간 연산 변수 활용 연구**
- 이동평균 활용
- 등락율각도 세분화
- 체결강도 패턴 분석

**4. 매도 조건 고도화 연구**
- 손절 조건 세분화 (시가총액별 차등)
- 이익 실현 조건 강화 (보유시간별)
- 예시:
  ```markdown
  #### 4.1 시가총액별 손절 기준
  - 소형주: -3% 손절
  - 중형주: -2.5% 손절
  - 대형주: -2% 손절
  ```

**5. 복합 지표 조합 연구**
- 매수세 강도 지수
- 거래 신뢰도 지수
- 예시:
  ```markdown
  #### 5.1 매수세 강도 지수
  ```python
  매수세강도 = (
      (초당매수수량 / 매도총잔량 * 100) * 0.3 +
      체결강도 * 0.3 +
      (초당순매수금액 / 100) * 0.2 +
      등락율각도(30) * 0.2
  )
  ```

**6. 시간대별 전략 세분화 연구**
- 예: 09:00~09:01 vs 09:01~09:02 차등 조건

**7. 최적화 전략 개선 연구**
- GA 최적화 변수 간격 조정
- 2단계 최적화 전략

**8. 리스크 관리 강화 연구**
- 동시 보유 종목 수 제한
- 연속 손실 제한

**9. 백테스팅 개선 방향**
- 슬리피지(Slippage) 반영
- 시장 충격(Market Impact) 반영

**10. 구현 우선순위**
- 즉시 적용 가능 (High Priority)
- 단기 적용 (Medium Priority)
- 중장기 연구 (Low Priority)

### 6.2 작성 예시

```markdown
## 조건식 개선 방향 연구

### 1. RSI 필터 추가 (High Priority)

**현재 문제**:
- 과매수/과매도 구간에서도 무분별하게 진입

**개선 방안**:
```python
if not (30 < RSI < 70):
    매수 = False
```

**최적화 범위**:
- RSI 하한: `[[25, 35, 5], 30]`
- RSI 상한: `[[65, 75, 5], 70]`

### 2. 볼린저 밴드 활용 (Medium Priority)

**활용 방안**:
- 902 전략에서 볼린저 밴드 하단 근처 매수 조건 추가
- 905 전략에서 중심선 돌파 확인

**예상 효과**:
- 승률 5~7% 향상 예상
- MDD 2~3% 감소 예상
```

---

## 7. AI 에게 문서 생성을 요청하는 방법

이 템플릿과 Tick/Min 가이드라인을 함께 제공하면, AI 가 **거의 완성된 수준의 전략 문서**를 자동으로 생성할 수 있다.

### 7.1 Tick 전략 예시 프롬프트

```text
1) 아래 문서들을 참고해서
 - docs/Guideline/Back_Testing_Guideline_Tick.md
 - docs/Guideline/Condition_Document_Template_Guideline.md

2) 09:00~09:15 구간에 사용하는 새로운 Tick 모멘텀 전략 조건식 + 최적화 문서를 만들어 주세요.

- 전략 요약:
  - 갭상승 + 거래대금 가속 종목 집중
  - 최소 일일거래대금 30억 이상
  - 손절 -3%, 익절 +7% 목표

Tick 템플릿 구조(C_T_xxx 형식, 매수/매도/최적화/범위/GA 등)를 그대로 사용해서
새 파일용 Markdown 본문을 생성해 주세요.
```

### 7.2 Min 전략 예시 프롬프트

```text
1) 아래 문서들을 참고해서
 - docs/Guideline/Back_Testing_Guideline_Min.md
 - docs/Guideline/Condition_Document_Template_Guideline.md

2) 09:00~10:00 사이 1분봉을 사용하는 추세 추종 분봉 전략
   조건식 + 최적화 문서를 만들어 주세요.

- 전략 요약:
  - 20/60 분봉 이동평균 골든크로스 + RSI 50 이상
  - 분당거래대금 상위 종목 위주
  - 손절 -2.5%, 익절 +5% 목표

Min 템플릿 구조(C_S_xxx_B_Min 형식)를 사용해서
새 파일용 Markdown 본문을 생성해 주세요.
```

---

## 8. 정리

- 이 가이드는 **조건식/최적화 문서의 형식과 작성 절차를 표준화**하기 위한 것이다.
- 새 전략을 만들 때는
  1. 이 템플릿 가이드 (`Condition_Document_Template_Guideline.md`)
  2. Tick/Min 백테스팅 가이드라인 (`Back_Testing_Guideline_Tick.md`, `Back_Testing_Guideline_Min.md`)
  를 항상 함께 참고해야 한다.
- AI 에게 문서 생성을 요청할 때도, 위 문서들을 함께 제공하면
  - 전략 설명만으로도 높은 완성도의 조건식/최적화 문서를 반복적으로 얻을 수 있다.

---

## 9. 실제 작성 사례 참고

다음 실제 문서들이 본 템플릿을 충실히 따른 우수 사례이다:

### 9.1 Tick 전략 완성 사례

**문서**: `docs/Condition/Tick/Condition_Tick_902_905_update_2.md`

**특징**:
- ✅ 공통 계산 지표를 상단에 명확히 정의
- ✅ 시간대별(902/905) 전략 분기가 명확
- ✅ 시가총액별 차등 조건 적용
- ✅ `self.vars[i]` 변수마다 상세한 주석 포함
- ✅ 예상 시간 계산 및 GA 범위 변환 원리 설명
- ✅ 10개 카테고리의 조건식 개선 방향 연구 포함
- ✅ 총 850+ 라인의 완벽한 문서화

**핵심 패턴**:
```python
# 공통 계산 지표 (상단 집중)
전일종가 = 현재가 / (1 + (등락율 / 100))
시가등락율 = ((시가 - 전일종가) / 전일종가) * 100

# 시간대별 전략 분기
if 시분초 < 90200:  # 902 전략
    if 시가총액 < 3000:
        # 소형주 조건
elif 90200 <= 시분초 < 90500:  # 905 전략
    if 시가총액 < 3000:
        # 소형주 조건
```

**문서**: `docs/Condition/Tick/Condition_Tick_900_920.md`

**특징**:
- ✅ 장초 20분을 4구간으로 세분화 (09:00~09:05, 09:05~09:10, 09:10~09:15, 09:15~09:20)
- ✅ 각 구간별 차등 조건 명확
- ✅ 위키링크 스타일 참조 표기 (`[[Back_Testing_Guideline_Tick]]`)
- ✅ 개요 섹션에서 전략 타입, 대상 종목, 핵심 변수 명시
- ✅ 변수 매핑표로 `self.vars[i]` 의미 정리

### 9.2 템플릿 준수 체크리스트

새 조건식 문서를 작성할 때 다음 항목을 확인한다:

**문서 구조**:
- [ ] 파일 위치가 `docs/Condition/Tick/` 또는 `docs/Condition/Min/`인가?
- [ ] 파일명이 `Condition_Tick_<시작분초>_<종료분초>[_update_<버전>].md` 형식인가?
- [ ] 상단에 참조 문서 표기 (`[[Back_Testing_Guideline_Tick]]`, `[[Condition_Document_Template_Guideline]]`)가 있는가?

**개요 섹션**:
- [ ] 전략 시간 구간이 명시되어 있는가?
- [ ] 대상 종목 범위(시가총액, 가격대, 유동성)가 명시되어 있는가?
- [ ] 전략 타입(갭상승, 모멘텀 등)이 명시되어 있는가?
- [ ] 핵심 변수/지표가 명시되어 있는가?

**조건식 섹션**:
- [ ] 공통 계산 지표를 상단에 정의했는가?
- [ ] 매수 = True / 매도 = False로 초기화했는가?
- [ ] if/elif 체인으로 조건을 순차 검증하는가?
- [ ] 주석으로 로직을 설명했는가?
- [ ] 시간대별/시가총액별 분기가 명확한가?

**최적화 섹션**:
- [ ] 각 `self.vars[i]`의 의미를 주석으로 설명했는가?
- [ ] 주석에 범위, 간격, 범위 개수를 명시했는가?
- [ ] 총 경우의 수를 계산했는가?
- [ ] 예상 시간 계산을 했는가?
- [ ] GA 범위 변환 방법을 설명했는가?

**조건식 개선 방향 연구 섹션**:
- [ ] 추가 지표 활용 연구를 포함했는가?
- [ ] TA-Lib 보조지표 활용 방안을 제시했는가?
- [ ] 구현 우선순위를 명시했는가?

### 9.3 조건식 검증 체크리스트

새 조건식 문서를 작성한 후, 다음 체크리스트를 사용하여 **필수 규칙 준수 여부**를 검증합니다:

#### ✅ 필수 규칙 체크리스트

**매수/매도 초기값 및 로직 패턴** (2.6절):
- [ ] 매수 조건식이 `매수 = True`로 시작하는가?
- [ ] 매수 조건식이 `if not (조건):` 또는 `elif not (조건):` 형태로 작성되었는가?
- [ ] 매도 조건식이 `매도 = False`로 시작하는가?
- [ ] 매도 조건식이 `if 조건:` 또는 `elif 조건:` 형태로 작성되었는가?
- [ ] 매수/매도 조건식이 조건 최적화 시스템과 호환되는가?

**self.vars 변수 인덱스 사용 규칙** (2.7절):
- [ ] `self.vars[0]`이 고정값 전용으로 사용되었는가? (예: `[[30], 30]`)
- [ ] `self.vars[0]`에 최적화 범위가 포함되지 않았는가?
- [ ] 최적화 변수가 `self.vars[1]`부터 시작하는가?
- [ ] 변수 인덱스가 연속으로 사용되었는가? (공백 없이)
- [ ] 매수 변수와 매도 변수의 인덱스 범위가 명확히 구분되는가?
- [ ] 각 변수마다 주석이 작성되었는가? (의미, 범위, 간격, 범위 개수)

**조건식 작성 시 if/elif 체인 구조** (2.8절):
- [ ] 첫 조건만 `if`, 나머지는 `elif`를 사용했는가?
- [ ] 독립된 `if`가 여러 개 사용되지 않았는가?
- [ ] 시간대별 분기가 `elif`로 연결되어 있는가?

**문서 구조** (2.1~2.4절):
- [ ] 파일 위치가 `docs/Condition/Tick/` 또는 `docs/Condition/Min/`인가?
- [ ] 파일명이 명명 규칙을 따르는가?
- [ ] 상단에 참조 문서 표기가 있는가? (`[[Back_Testing_Guideline_Tick]]`, `[[Condition_Document_Template_Guideline]]`)
- [ ] 개요 섹션에 5대 필수 항목이 포함되어 있는가?

**최적화 범위** (3.3절):
- [ ] 각 변수의 범위 개수가 계산되어 주석에 포함되어 있는가?
- [ ] 총 경우의 수가 계산되어 문서에 명시되어 있는가?
- [ ] 예상 시간 계산이 포함되어 있는가?
- [ ] GA 범위 변환 방법이 설명되어 있는가?

#### ⚠️ 일반적인 오류 패턴

다음은 조건식 작성 시 자주 발생하는 오류들입니다. 반드시 피해야 합니다:

**오류 1: 매수 초기값을 False로 설정**
```python
# ❌ 잘못됨
매수 = False

if 조건1 and 조건2 and 조건3:
    매수 = True
```

**오류 2: self.vars[0]에 최적화 범위 설정**
```python
# ❌ 잘못됨
self.vars[0] = [[20, 40, 10], 30]  # self.vars[0]은 고정값만!
```

**오류 3: 변수 인덱스 건너뛰기**
```python
# ❌ 잘못됨
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]
self.vars[3] = [[3.5, 5.0, 0.5], 4.0]  # self.vars[2]가 없음
```

**오류 4: 독립된 if 여러 개 사용**
```python
# ❌ 잘못됨
매수 = True

if not (조건1):
    매수 = False

if not (조건2):  # elif를 사용해야 함
    매수 = False

if not (조건3):  # elif를 사용해야 함
    매수 = False
```

**오류 5: 변수 주석 누락 또는 불충분**
```python
# ❌ 잘못됨
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]  # 등락율
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]   # (주석 없음)

# ✅ 올바름
self.vars[1] = [[6.0, 10.0, 1.0], 8.0]  # 등락율 상한: 6.0%~10.0%, 1.0% 간격, 범위 갯수: 5
self.vars[2] = [[1.5, 3.0, 0.5], 2.0]   # 시가등락율 하한: 1.5%~3.0%, 0.5% 간격, 범위 갯수: 4
```

### 9.4 추가 학습 자료

- **Back_Testing_Guideline_Tick.md**: Tick 변수 전체 목록 및 사용법
- **Back_Testing_Guideline_Min.md**: 분봉 변수 전체 목록 및 사용법
- **Condition_Tick_902_905_update_2.md**: 가장 완벽한 Tick 전략 사례
- **Condition_Tick_900_920.md**: 장초 20분 전략 사례
- **backtester/optimiz_conditions.py**: 조건 최적화 시스템 코드
- **stock/kiwoom_strategy_tick.py**: Tick 전략 실행 코드
- **stock/kiwoom_strategy_min.py**: Min 전략 실행 코드

---

**Last Update: 2025-11-24**

## 10. 변경 이력

### 2025-11-24 (Update 3)
**주요 업데이트: self.vars 인덱스 번호 규칙 명확화 및 검증 방법 추가**

추가된 내용:
1. **2.7절 규칙 3 대폭 보강**: self.vars 인덱스 번호 할당 원칙 명확화
   - 명확한 구간 정의: 고정값(0), 매수(1~24), 매도(25~49)
   - "왜 25번부터인가?" 근거 설명 추가
   - 구체적인 예시 추가 (매수 5개, 매도 3개 사용 케이스)
   - **인덱스 검증 방법** 3가지 코드 예시 제공
2. **2.9절 체크리스트 강화**: 매수/매도 변수 인덱스 검증 코드 추가
3. **0절 체크리스트 업데이트**: 인덱스 구간 준수 규칙 구체화

변경 이유:
- 기존 규칙 "충분히 떨어진 번호"가 모호하여 실무 적용 어려움
- 인덱스 건너뛰기 검증 방법이 없어 오류 발견 어려움
- 매수/매도 구간이 겹치는 경우 혼란 발생
- 변수 추가 시 인덱스 재조정 문제 발생

개선 효과:
- 명확한 구간 정의로 매수/매도 구분 용이 (1~24 vs 25~49)
- 검증 코드로 인덱스 오류 즉시 발견 가능
- 나중에 변수 추가 시 유연성 확보
- 문서 가독성 및 유지보수성 향상

### 2025-11-24 (Update 2)
**주요 업데이트: 필수 준수사항 체크리스트 및 셀프 체크 절차 추가**

추가된 내용:
1. **0절 추가**: 필수 준수사항 요약 체크리스트 - 13가지 필수 규칙 한눈에 확인
2. **2.9절 추가**: 준수 여부 셀프 체크 절차 - 3단계 점검 프로세스
   - 헤더/개요 정합성 확인
   - 조건식 구조·변수 검증
   - 검토/개선 기록 남기기
3. 섹션 번호 조정: 기존 2.9 → 2.10 (개요 섹션 작성 가이드)

변경 이유:
- 조건식 문서 작성 시 놓치기 쉬운 필수 규칙을 문서 최상단에 체크리스트로 정리
- 공통 계산 지표, 변수 인덱스 재사용, 백테스트 코드 호환성 등 실무 검증 항목 추가
- 문서 품질 검증을 위한 체계적인 셀프 체크 절차 제공

기대 효과:
- 조건식 문서 작성 전 필수 규칙 사전 숙지 용이
- 문서 완성 후 빠른 자가 검증 가능
- 검증 기록 남기기를 통한 문서 품질 추적

### 2025-11-24 (Update 1)
**주요 업데이트: 필수 규칙 추가 및 명확화**

추가된 내용:
1. **2.6절 추가**: 매수/매도 초기값 및 로직 패턴 - 조건 최적화 시스템과의 연관성 설명
2. **2.7절 추가**: self.vars 변수 인덱스 사용 규칙 - 고정값, 연속 인덱스, 주석 규칙 명확화
3. **2.8절 추가**: 조건식 작성 시 if/elif 체인 구조 - 독립 if 사용 금지
4. **9.3절 추가**: 조건식 검증 체크리스트 - 필수 규칙 준수 여부 확인
5. **일반적인 오류 패턴** 추가 - 자주 발생하는 5가지 오류와 해결 방법

변경 이유:
- 실제 조건식 문서 117개를 분석한 결과, 다수의 문서가 규칙을 위반하는 것으로 확인
- `backtester/optimiz_conditions.py`의 조건 최적화 시스템과 호환되지 않는 패턴 다수 발견
- `self.vars[0]`을 최적화 변수로 사용하거나 인덱스를 건너뛰는 오류 발견
- 매수 초기값을 `False`로 설정하거나 독립된 `if`를 여러 개 사용하는 오류 발견

기대 효과:
- 조건 최적화 시스템과의 호환성 향상
- 조건식 작성 시 일관성 확보
- 신규 조건식 작성 시 오류 감소
- 기존 조건식 검증 및 수정 용이

### 2025-01-15
**초기 문서 작성**
