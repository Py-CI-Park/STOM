# 백테스팅 변수 통합 관리 가이드

> **버전**: 1.0.0  
> **작성일**: 2026-01-07  
> **목적**: 백테스팅 분석에 사용되는 모든 변수(원본, 파생, 필터용)를 체계적으로 문서화하고, 하나의 통합 파일로 관리할 수 있는 방안 제시

---

## 목차

1. [개요](#1-개요)
2. [변수 분류 체계](#2-변수-분류-체계)
3. [원본 변수 (Raw Variables)](#3-원본-변수-raw-variables)
4. [파생 변수 (Derived Variables)](#4-파생-변수-derived-variables)
5. [필터 변수 (Filter Variables)](#5-필터-변수-filter-variables)
6. [세그먼트 필터 변수](#6-세그먼트-필터-변수)
7. [변수 생성 흐름](#7-변수-생성-흐름)
8. [통합 관리 방안](#8-통합-관리-방안)
9. [변수 명명 규칙](#9-변수-명명-규칙)
10. [코드 리팩토링 제안](#10-코드-리팩토링-제안)

---

## 1. 개요

### 1.1 문서 목적

STOM V1 백테스팅 시스템에서 분석에 사용되는 변수들이 여러 파일에 분산되어 있어 관리가 어렵습니다. 이 문서는:

1. **모든 변수를 체계적으로 분류**하고 문서화
2. **각 변수의 생성 위치와 사용처**를 명확히 정의
3. **통합 관리 파일(레지스트리)** 설계 방안 제시
4. **필터/세그먼트 필터에 사용할 변수 선택 기준** 정립

### 1.2 현재 변수 관리 현황

| 파일 | 역할 | 변수 유형 |
|------|------|-----------|
| `metric_registry.py` | 필터 후보 변수 목록 | `BUY_TIME_FILTER_COLUMNS`, `METRIC_DEFINITIONS` |
| `metrics_enhanced.py` | 파생 변수 계산 | 50+ 파생 변수 생성 |
| `filters.py` | 필터 조건 정의 및 평가 | 동적 필터 후보 생성 |
| `segmentation.py` | 세그먼트 분할 기준 | 시가총액/시간 구간 |
| `detail_schema.py` | CSV 출력 컬럼 순서 | 컬럼 정렬 규칙 |

### 1.3 문제점

- 변수 정의가 **여러 파일에 분산**
- 새 변수 추가 시 **여러 곳을 수정**해야 함
- 필터 후보/제외 변수 선택 기준이 **코드에 하드코딩**
- 타임프레임(Tick/Min)별 변수 차이가 **암묵적**으로 관리됨

---

## 2. 변수 분류 체계

### 2.1 시점 기준 분류

```
┌─────────────────────────────────────────────────────────────────┐
│                     변수 시점 분류                               │
├─────────────────────────────────────────────────────────────────┤
│  [매수 시점]          [보유 중]           [매도 시점]            │
│   - 매수등락율         - 변화량            - 매도등락율           │
│   - 매수체결강도       - 변화율            - 매도체결강도         │
│   - 매수당일거래대금   - 추세              - 매도당일거래대금     │
│   - 시가총액           - 위험신호          - 보유시간             │
│   - 위험도점수(★)                        - 수익금/수익률         │
│   - 거래품질점수(★)                                             │
│                                                                 │
│  ★ = 필터에 사용 가능 (룩어헤드 없음)                            │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 용도 기준 분류

| 분류 | 설명 | 예시 |
|------|------|------|
| **원본 변수** | 데이터베이스에서 로드되는 기본 데이터 | 매수등락율, 매수체결강도 |
| **파생 변수** | 원본 변수를 조합하여 계산 | 위험도점수, 거래품질점수 |
| **필터 변수** | 매수 진입 필터에 사용 가능한 변수 | 매수 시점 변수 + 일부 파생 변수 |
| **진단 변수** | 사후 분석용 (룩어헤드 포함) | 매수매도위험도점수, 등락율변화 |

### 2.3 타임프레임별 분류

| 타임프레임 | 전용 변수 접두사 | 예시 |
|------------|------------------|------|
| **Tick (초)** | `초당*`, `매수초당*` | 초당매수수량, 초당거래대금_당일비중 |
| **Min (분)** | `분당*`, `매수분당*` | 분당매수수량, 분당거래대금_당일비중 |
| **공통** | 접두사 없음 | 등락율변화, 위험도점수 |

---

## 3. 원본 변수 (Raw Variables)

### 3.1 매수 시점 원본 변수

백테스팅 엔진(`backengine_*.py`)에서 로드되어 `df_tsg`에 포함되는 변수들입니다.

| 변수명 | 단위 | 설명 | 필터 사용 |
|--------|------|------|-----------|
| **가격/금액** ||||
| `매수가` | 원 | 매수 체결가 | ✓ |
| `매수금액` | 원 | 매수 총금액 | ✗ (분석용) |
| **시장 지표** ||||
| `매수등락율` | % | 매수 시점 등락율 | ✓ |
| `매수시가등락율` | % | 시가 대비 등락율 | ✓ |
| `매수체결강도` | - | 매수 시점 체결강도 | ✓ |
| `매수당일거래대금` | 백만원 | 당일 거래대금 | ✓ |
| `매수전일비` | % | 전일 종가 대비 | ✓ |
| `매수회전율` | % | 시장 회전율 | ✓ |
| `매수전일동시간비` | % | 전일 동시간 대비 | ✓ |
| **가격 범위** ||||
| `매수고가` | 원 | 당일 고가 | ✓ |
| `매수저가` | 원 | 당일 저가 | ✓ |
| `매수고저평균대비등락율` | % | 고저 평균 대비 | ✓ |
| **호가 데이터** ||||
| `매수매도총잔량` | 주 | 매도 호가 총잔량 | ✓ |
| `매수매수총잔량` | 주 | 매수 호가 총잔량 | ✓ |
| `매수호가잔량비` | % | 매수/매도 잔량 비율 | ✓ |
| `매수매도호가1` | 원 | 매도1호가 | ✓ |
| `매수매수호가1` | 원 | 매수1호가 | ✓ |
| `매수스프레드` | % | 호가 스프레드 | ✓ |
| **수급 (Tick 전용)** ||||
| `매수초당매수수량` | 주 | 초당 매수 체결량 | ✓ (Tick) |
| `매수초당매도수량` | 주 | 초당 매도 체결량 | ✓ (Tick) |
| `매수초당거래대금` | 백만원 | 초당 거래대금 | ✓ (Tick) |
| **수급 (Min 전용)** ||||
| `매수분당매수수량` | 주 | 분당 매수 체결량 | ✓ (Min) |
| `매수분당매도수량` | 주 | 분당 매도 체결량 | ✓ (Min) |
| `매수분당거래대금` | 백만원 | 분당 거래대금 | ✓ (Min) |
| **기타** ||||
| `시가총액` | 억원 | 종목 시가총액 | ✓ |
| `매수시` / `매수분` / `매수초` | - | 매수 시각 | ✓ |

### 3.2 매도 시점 원본 변수

매도 시점에 기록되는 변수들입니다. **필터에 사용하면 룩어헤드(Lookahead)가 발생**합니다.

| 변수명 | 단위 | 설명 | 필터 사용 |
|--------|------|------|-----------|
| `매도등락율` | % | 매도 시점 등락율 | ✗ (룩어헤드) |
| `매도체결강도` | - | 매도 시점 체결강도 | ✗ (룩어헤드) |
| `매도당일거래대금` | 백만원 | 매도 시점 당일거래대금 | ✗ (룩어헤드) |
| `매도전일비` | % | 매도 시점 전일비 | ✗ (룩어헤드) |
| `매도회전율` | % | 매도 시점 회전율 | ✗ (룩어헤드) |
| `매도호가잔량비` | % | 매도 시점 호가잔량비 | ✗ (룩어헤드) |
| `보유시간` | 초/분 | 보유 기간 | ✗ (룩어헤드) |
| `수익금` | 원 | 실현 손익 | ✗ (룩어헤드) |
| `수익률` | % | 실현 수익률 | ✗ (룩어헤드) |

---

## 4. 파생 변수 (Derived Variables)

### 4.1 파생 변수 생성 위치

**파일**: `backtester/analysis_enhanced/metrics_enhanced.py`  
**함수**: `CalculateEnhancedDerivedMetrics(df_tsg, timeframe, save_file_name)`

### 4.2 변화량 지표 (매도 - 매수)

| 변수명 | 산출 공식 | 필터 사용 |
|--------|-----------|-----------|
| `등락율변화` | 매도등락율 - 매수등락율 | ✗ (룩어헤드) |
| `체결강도변화` | 매도체결강도 - 매수체결강도 | ✗ (룩어헤드) |
| `전일비변화` | 매도전일비 - 매수전일비 | ✗ (룩어헤드) |
| `회전율변화` | 매도회전율 - 매수회전율 | ✗ (룩어헤드) |
| `호가잔량비변화` | 매도호가잔량비 - 매수호가잔량비 | ✗ (룩어헤드) |

### 4.3 변화율 지표 (매도 / 매수)

| 변수명 | 산출 공식 | 필터 사용 |
|--------|-----------|-----------|
| `거래대금변화율` | 매도당일거래대금 / 매수당일거래대금 | ✗ (룩어헤드) |
| `체결강도변화율` | 매도체결강도 / 매수체결강도 | ✗ (룩어헤드) |

### 4.4 매수 시점 점수 지표 (필터 사용 가능)

| 변수명 | 범위 | 산출 로직 | 필터 사용 |
|--------|------|-----------|-----------|
| **모멘텀점수** | -30~+30 | `(등락율_norm*0.4 + 체결강도_norm*0.6) * 10` | ✓ |
| **거래품질점수** | 0~100 | 체결강도/호가잔량/시가총액 가산, 등락율/스프레드 감산 | ✓ |
| **위험도점수** | 0~100 | 등락율/체결강도/거래대금/시가총액/호가/스프레드 기반 | ✓ |

#### 4.4.1 위험도점수 산출 로직

```python
위험도점수 = 0

# 1) 과열 위험: 매수등락율
if 매수등락율 >= 20: 위험도점수 += 20
if 매수등락율 >= 25: 위험도점수 += 10
if 매수등락율 >= 30: 위험도점수 += 10

# 2) 체결강도 약세/과열
if 매수체결강도 < 80: 위험도점수 += 15
if 매수체결강도 < 60: 위험도점수 += 10
if 매수체결강도 >= 150: 위험도점수 += 10
if 매수체결강도 >= 200: 위험도점수 += 10
if 매수체결강도 >= 250: 위험도점수 += 10

# 3) 유동성 위험: 당일거래대금
trade_money_eok = 매수당일거래대금 / 100  # 억 환산
if trade_money_eok < 50: 위험도점수 += 15
if trade_money_eok < 100: 위험도점수 += 10

# 4) 소형주 위험: 시가총액
if 시가총액 < 1000: 위험도점수 += 15
if 시가총액 < 5000: 위험도점수 += 10

# 5) 호가 불균형
if 매수호가잔량비 < 90: 위험도점수 += 10
if 매수호가잔량비 < 70: 위험도점수 += 15

# 6) 슬리피지 위험
if 매수스프레드 >= 0.5: 위험도점수 += 10
if 매수스프레드 >= 1.0: 위험도점수 += 10

# 7) 회전율 위험
if 매수회전율 < 10: 위험도점수 += 5
if 매수회전율 < 5: 위험도점수 += 10

# 8) 변동성 위험
if 매수변동폭비율 >= 7.5: 위험도점수 += 10
if 매수변동폭비율 >= 10: 위험도점수 += 10
if 매수변동폭비율 >= 15: 위험도점수 += 10

위험도점수 = clip(위험도점수, 0, 100)
```

### 4.5 수급 비율 지표 (Tick/Min 분기)

#### Tick 모드 전용

| 변수명 | 산출 공식 | 필터 사용 |
|--------|-----------|-----------|
| `초당매수수량_매도총잔량_비율` | 초당매수수량 / 매도총잔량 * 100 | ✓ |
| `매도잔량_매수잔량_비율` | 매도총잔량 / 매수총잔량 | ✓ |
| `매수잔량_매도잔량_비율` | 매수총잔량 / 매도총잔량 | ✓ |
| `초당매도_매수_비율` | 초당매도수량 / 초당매수수량 | ✓ |
| `초당매수_매도_비율` | 초당매수수량 / 초당매도수량 | ✓ |
| `현재가_고저범위_위치` | (매수가-저가) / (고가-저가) * 100 | ✓ |
| `초당거래대금_당일비중` | 초당거래대금 / 당일거래대금 * 10000 | ✓ |
| `초당순매수수량` | 초당매수수량 - 초당매도수량 | ✓ |
| `초당순매수금액` | 초당순매수수량 * 매수가 / 1,000,000 | ✓ |
| `초당순매수비율` | 초당매수수량 / (초당매수+초당매도) * 100 | ✓ |

#### Min 모드 전용

| 변수명 | 산출 공식 | 필터 사용 |
|--------|-----------|-----------|
| `분당매수수량_매도총잔량_비율` | 분당매수수량 / 매도총잔량 * 100 | ✓ |
| `분당매도_매수_비율` | 분당매도수량 / 분당매수수량 | ✓ |
| `분당매수_매도_비율` | 분당매수수량 / 분당매도수량 | ✓ |
| `현재가_분봉고저범위_위치` | (매수가-분봉저가) / (분봉고가-분봉저가) * 100 | ✓ |
| `분당거래대금_당일비중` | 분당거래대금 / 당일거래대금 * 10000 | ✓ |
| `분당순매수수량` | 분당매수수량 - 분당매도수량 | ✓ |
| `분당순매수금액` | 분당순매수수량 * 매수가 / 1,000,000 | ✓ |
| `분당순매수비율` | 분당매수수량 / (분당매수+분당매도) * 100 | ✓ |

### 4.6 당일거래대금 시계열 비율

| 변수명 | 산출 공식 | 필터 사용 |
|--------|-----------|-----------|
| `당일거래대금_전틱분봉_비율` | 현재 당일거래대금 / 직전 당일거래대금 | ✓ |
| `당일거래대금_5틱분봉평균_비율` | 현재 당일거래대금 / 최근 5틱/분봉 평균 | ✓ |
| `당일거래대금_매수매도_비율` | 매도당일거래대금 / 매수당일거래대금 | ✗ (룩어헤드) |

### 4.7 진단용 지표 (룩어헤드 포함)

| 변수명 | 범위 | 설명 | 필터 사용 |
|--------|------|------|-----------|
| `매수매도위험도점수` | 0~100 | 매수→매도 변화 기반 위험도 | ✗ (사후진단) |
| `시간대평균수익률` | % | 시간대별 평균 수익률 | ✗ (사후진단) |
| `타이밍점수` | -∞~+∞ | 시간대 타이밍 점수 | ✗ (사후진단) |
| `리스크조정수익률` | - | 수익률 / 위험 요소 | ✗ (사후진단) |
| `연속이익` / `연속손실` | 정수 | 연속 손익 횟수 | ✗ (사후진단) |

---

## 5. 필터 변수 (Filter Variables)

### 5.1 필터 후보 변수 정의

**파일**: `backtester/analysis/metric_registry.py`

```python
BUY_TIME_FILTER_COLUMNS: List[str] = [
    # 원본 변수
    '매수등락율', '매수시가등락율', '매수당일거래대금', '매수체결강도',
    '매수전일비', '매수회전율', '매수전일동시간비', '매수고가', '매수저가',
    '매수고저평균대비등락율', '매수매도총잔량', '매수매수총잔량',
    '매수호가잔량비', '매수매도호가1', '매수매수호가1', '매수스프레드',
    '매수초당매수수량', '매수초당매도수량', '매수초당거래대금',
    '시가총액', '매수가', '매수시', '매수분', '매수초',
    
    # 파생 변수 (매수 시점 기준)
    '모멘텀점수', '매수변동폭', '매수변동폭비율', '거래품질점수', '위험도점수',
    
    # 수급 비율 (Tick)
    '초당매수수량_매도총잔량_비율', '매도잔량_매수잔량_비율', '매수잔량_매도잔량_비율',
    '초당매도_매수_비율', '초당매수_매도_비율', '현재가_고저범위_위치',
    '초당거래대금_당일비중', '초당순매수수량', '초당순매수금액', '초당순매수비율',
    
    # 당일거래대금 비율
    '당일거래대금_전틱분봉_비율', '당일거래대금_5틱분봉평균_비율',
]
```

### 5.2 필터 후보 제외 조건

**파일**: `backtester/analysis_enhanced/filters.py` - `_is_buytime_candidate()` 함수

```python
# 제외되는 변수 패턴
EXCLUDED_PATTERNS = [
    # 분석 전용
    'ANALYSIS_ONLY_COLUMNS',
    
    # 수익 결과 기반 (룩어헤드)
    '수익금', '수익률', '보유시간', '매수시간', '매도시간', '매수일자',
    '추가매수시간', '매도조건',
    
    # 매도 시점 변수 (룩어헤드)
    '매도*' (매도잔량_매수잔량_비율 제외),
    
    # 변화량 변수 (룩어헤드)
    '*변화*',
    
    # 사후 진단용
    '이익금액', '손실금액', '이익여부', '시간대평균수익률', '타이밍점수',
    '리스크조정수익률', '연속이익', '연속손실', '매수매도위험도점수',
    
    # 시간 컬럼 (별도 처리)
    '매수시', '매수분', '매수초',
]
```

### 5.3 필터 평가 기준

| 기준 | 값 | 등급 |
|------|---|------|
| p-value | < 0.01 | ★★★ (매우 유의) |
| p-value | < 0.05 | ★★ (유의) |
| p-value | < 0.10 | ★ (약간 유의) |
| Cohen's d | > 0.8 | 큰 효과 |
| Cohen's d | 0.5~0.8 | 중간 효과 |
| Cohen's d | 0.2~0.5 | 작은 효과 |
| 수익 개선 | > 15% + 유의 | ★★★ (강력 권장) |
| 수익 개선 | > 5% + p<0.1 | ★★ (권장) |
| 수익 개선 | > 0 | ★ (참고) |

---

## 6. 세그먼트 필터 변수

### 6.1 세그먼트 분할 기준

**파일**: `backtester/segment_analysis/segmentation.py`

#### 시가총액 구간

| 라벨 | 범위 (억원) | 설명 |
|------|------------|------|
| `초소형주` | 0 ~ 2,500 | 시가총액 2,500억 미만 |
| `소형주` | 2,500 ~ 5,000 | 시가총액 2,500~5,000억 |
| `중형주` | 5,000 ~ 10,000 | 시가총액 5,000~10,000억 |
| `대형주` | 10,000 ~ ∞ | 시가총액 10,000억 이상 |

#### 시간 구간

| 라벨 | 범위 (HHMMSS) | 설명 |
|------|---------------|------|
| `T1_090000_090500` | 90000 ~ 90500 | 09:00:00 ~ 09:05:00 |
| `T2_090500_091000` | 90500 ~ 91000 | 09:05:00 ~ 09:10:00 |
| `T3_091000_091500` | 91000 ~ 91500 | 09:10:00 ~ 09:15:00 |
| `T4_091500_092000` | 91500 ~ 92000 | 09:15:00 ~ 09:20:00 |

### 6.2 세그먼트 필터에 사용되는 변수

세그먼트 필터 코드 생성 시 사용되는 런타임 변수들:

```python
# backtester/segment_analysis/code_generator.py - _get_segment_runtime_blocks()

SEGMENT_RUNTIME_VARIABLES = [
    '시가총액',        # 세그먼트 분할 기준
    '시분초',          # 시간 구간 판별 (매수시*10000 + 매수분*100 + 매수초)
    
    # 파생 변수 (런타임 계산 필요)
    '거래품질점수',
    '위험도점수',
    '모멘텀점수',
    '초당순매수수량',
    '초당순매수비율',
    # ... (필터 조합에 따라 동적)
]
```

### 6.3 세그먼트 필터 선택 기준

| 단계 | 조건 | 설명 |
|------|------|------|
| 1 | `improvement > 0` | 수익 개선 효과 있음 |
| 2 | `p_value < 0.1` | 통계적으로 의미 있음 |
| 3 | `effect_size > 0.2` | 효과 크기 존재 |
| 4 | `excluded_ratio < 85%` | 과도한 제외 방지 |
| 5 | `remaining_trades >= 30` | 최소 잔여 거래수 확보 |

---

## 7. 변수 생성 흐름

### 7.1 전체 흐름도

```
┌─────────────────────────────────────────────────────────────────────┐
│                    백테스팅 변수 생성 흐름                            │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. 데이터베이스 로드 (backengine_*.py)                               │
│     - stock_tick.db / coin_min.db 등                                │
│     - 원본 변수 로드: 매수*, 매도*, 시가총액 등                        │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. 파생 변수 계산 (metrics_enhanced.py)                             │
│     - CalculateEnhancedDerivedMetrics()                              │
│     - 타임프레임 감지 → Tick/Min 분기                                 │
│     - 변화량/변화율/점수/비율 계산                                    │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. 필터 후보 생성 (filters.py)                                      │
│     - _is_buytime_candidate()로 필터 가능 변수 선별                   │
│     - FindOptimalThresholds()로 최적 임계값 탐색                      │
│     - 통계적 유의성 검증 (t-test, Cohen's d)                         │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  4. 세그먼트 분할 (segmentation.py)                                  │
│     - SegmentBuilder.build_segments()                                │
│     - 시가총액 × 시간 → 16개 세그먼트                                 │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  5. 세그먼트별 필터 최적화 (combination_optimizer.py)                 │
│     - 세그먼트별 최적 필터 조합 탐색                                   │
│     - 전역 최적 조합 선택                                             │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  6. 코드 생성 (code_generator.py)                                    │
│     - build_segment_filter_code()                                    │
│     - 런타임 변수 매핑 포함                                           │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│  7. CSV 출력 (exports.py)                                            │
│     - detail.csv: 모든 변수 포함                                      │
│     - filter.csv: 필터 분석 결과                                      │
│     - segment_*.csv: 세그먼트별 결과                                  │
└─────────────────────────────────────────────────────────────────────┘
```

### 7.2 함수 호출 순서

```python
# 백테스팅 완료 후 분석 흐름

# 1. 기본 분석
df_result = GetBackResult(...)

# 2. 파생 변수 계산
df_enhanced = CalculateEnhancedDerivedMetrics(df_result, timeframe='auto')

# 3. 필터 분석
filter_results = AnalyzeFilterEffectsEnhanced(df_enhanced)

# 4. 세그먼트 분할
builder = SegmentBuilder(config)
segments = builder.build_segments(df_enhanced)

# 5. 세그먼트별 필터 최적화
optimizer = CombinationOptimizer(segments)
global_best = optimizer.optimize()

# 6. 코드 생성
code_lines, summary = build_segment_filter_code(global_best, config)
```

---

## 8. 통합 관리 방안

### 8.1 현재 문제점

1. **변수 정의 분산**: metric_registry.py, metrics_enhanced.py, filters.py 등
2. **하드코딩된 제외 로직**: _is_buytime_candidate() 내부
3. **타임프레임 분기 복잡**: if timeframe == 'tick': ... else: ...
4. **새 변수 추가 어려움**: 여러 파일 수정 필요

### 8.2 제안: 통합 변수 레지스트리 (variable_registry.py)

모든 변수를 **하나의 설정 파일**로 관리하는 방안입니다.

#### 8.2.1 설계 개요

```python
# backtester/variable_registry.py

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum

class VariableScope(Enum):
    """변수 시점 분류"""
    BUY = 'buy'           # 매수 시점
    SELL = 'sell'         # 매도 시점
    COMBINED = 'combined' # 매수+매도 조합
    ANALYSIS = 'analysis' # 분석 전용

class VariableTimeframe(Enum):
    """타임프레임 분류"""
    TICK = 'tick'   # Tick 전용
    MIN = 'min'     # Min 전용
    ALL = 'all'     # 공통

@dataclass
class VariableDefinition:
    """변수 정의"""
    name: str                           # 변수명
    scope: VariableScope                # 시점 분류
    timeframe: VariableTimeframe        # 타임프레임
    unit: str                           # 단위
    formula: List[str]                  # 산출 공식
    category: str                       # 카테고리 (등락율, 체결강도, 호가 등)
    for_filter: bool = True             # 필터 사용 가능 여부
    for_segment_filter: bool = True     # 세그먼트 필터 사용 가능 여부
    runtime_compatible: bool = True     # 런타임 계산 가능 여부
    lookahead_free: bool = True         # 룩어헤드 없음 여부
    description: str = ''               # 설명
    source_columns: List[str] = field(default_factory=list)  # 의존 컬럼
```

#### 8.2.2 변수 등록 예시

```python
# 모든 변수를 YAML 또는 Python dict로 정의

VARIABLE_REGISTRY: Dict[str, VariableDefinition] = {
    # === 매수 시점 원본 변수 ===
    '매수등락율': VariableDefinition(
        name='매수등락율',
        scope=VariableScope.BUY,
        timeframe=VariableTimeframe.ALL,
        unit='%',
        formula=['원본 데이터'],
        category='등락율',
        for_filter=True,
        for_segment_filter=True,
        lookahead_free=True,
        description='매수 시점 등락율',
    ),
    
    # === 파생 변수 ===
    '위험도점수': VariableDefinition(
        name='위험도점수',
        scope=VariableScope.BUY,
        timeframe=VariableTimeframe.ALL,
        unit='점수(0~100)',
        formula=[
            '매수등락율 기반 가산 (>=20: +20, >=25: +10, >=30: +10)',
            '매수체결강도 기반 가산/감산',
            '매수당일거래대금 기반 가산',
            '시가총액 기반 가산',
            '매수호가잔량비 기반 가산',
            '매수스프레드 기반 가산',
            '매수회전율 기반 가산',
            '매수변동폭비율 기반 가산',
            'clip(0, 100)',
        ],
        category='위험신호',
        for_filter=True,
        for_segment_filter=True,
        lookahead_free=True,
        description='매수 시점 종합 위험도 점수 (룩어헤드 없음)',
        source_columns=['매수등락율', '매수체결강도', '매수당일거래대금', '시가총액', 
                       '매수호가잔량비', '매수스프레드', '매수회전율', '매수변동폭비율'],
    ),
    
    # === Tick 전용 변수 ===
    '초당매수수량_매도총잔량_비율': VariableDefinition(
        name='초당매수수량_매도총잔량_비율',
        scope=VariableScope.BUY,
        timeframe=VariableTimeframe.TICK,
        unit='%',
        formula=['매수초당매수수량 / 매수매도총잔량 * 100'],
        category='수급',
        for_filter=True,
        for_segment_filter=True,
        lookahead_free=True,
        description='초당 매수 수량의 매도 잔량 대비 비율',
        source_columns=['매수초당매수수량', '매수매도총잔량'],
    ),
    
    # === 룩어헤드 변수 (필터 사용 불가) ===
    '등락율변화': VariableDefinition(
        name='등락율변화',
        scope=VariableScope.COMBINED,
        timeframe=VariableTimeframe.ALL,
        unit='%p',
        formula=['매도등락율 - 매수등락율'],
        category='변화량',
        for_filter=False,
        for_segment_filter=False,
        lookahead_free=False,
        description='매도-매수 등락율 변화량 (사후 진단용)',
        source_columns=['매도등락율', '매수등락율'],
    ),
}
```

#### 8.2.3 레지스트리 활용 함수

```python
class VariableRegistry:
    """변수 레지스트리 관리 클래스"""
    
    def __init__(self, definitions: Dict[str, VariableDefinition] = None):
        self.definitions = definitions or VARIABLE_REGISTRY
    
    def get_filter_candidates(self, timeframe: str = 'tick') -> List[str]:
        """필터 후보 변수 목록 반환"""
        tf = VariableTimeframe.TICK if timeframe == 'tick' else VariableTimeframe.MIN
        return [
            name for name, defn in self.definitions.items()
            if defn.for_filter 
               and defn.lookahead_free
               and defn.timeframe in (tf, VariableTimeframe.ALL)
        ]
    
    def get_segment_filter_candidates(self, timeframe: str = 'tick') -> List[str]:
        """세그먼트 필터 후보 변수 목록 반환"""
        tf = VariableTimeframe.TICK if timeframe == 'tick' else VariableTimeframe.MIN
        return [
            name for name, defn in self.definitions.items()
            if defn.for_segment_filter 
               and defn.lookahead_free
               and defn.runtime_compatible
               and defn.timeframe in (tf, VariableTimeframe.ALL)
        ]
    
    def get_by_category(self, category: str) -> List[str]:
        """카테고리별 변수 목록 반환"""
        return [
            name for name, defn in self.definitions.items()
            if defn.category == category
        ]
    
    def get_by_scope(self, scope: VariableScope) -> List[str]:
        """시점별 변수 목록 반환"""
        return [
            name for name, defn in self.definitions.items()
            if defn.scope == scope
        ]
    
    def is_lookahead_free(self, name: str) -> bool:
        """룩어헤드 여부 확인"""
        defn = self.definitions.get(name)
        return defn.lookahead_free if defn else False
    
    def get_formula(self, name: str) -> List[str]:
        """변수 산출 공식 반환"""
        defn = self.definitions.get(name)
        return defn.formula if defn else []
```

### 8.3 YAML 기반 설정 파일 대안

더 간단한 관리를 위해 YAML 파일 사용도 고려할 수 있습니다.

```yaml
# backtester/config/variables.yaml

variables:
  # 매수 시점 원본 변수
  매수등락율:
    scope: buy
    timeframe: all
    unit: "%"
    category: 등락율
    for_filter: true
    lookahead_free: true
    
  # 파생 변수
  위험도점수:
    scope: buy
    timeframe: all
    unit: "점수(0~100)"
    category: 위험신호
    for_filter: true
    lookahead_free: true
    formula:
      - "매수등락율 기반 가산"
      - "매수체결강도 기반 가산"
      - "clip(0, 100)"
    source_columns:
      - 매수등락율
      - 매수체결강도
      
  # Tick 전용
  초당매수수량_매도총잔량_비율:
    scope: buy
    timeframe: tick
    unit: "%"
    category: 수급
    for_filter: true
    lookahead_free: true
    formula:
      - "매수초당매수수량 / 매수매도총잔량 * 100"

# 필터 제외 패턴
filter_exclude_patterns:
  - "수익금*"
  - "매도*"  # 매도잔량_매수잔량_비율 제외
  - "*변화*"
  - "보유시간"

# 카테고리 정의
categories:
  등락율: ["매수등락율", "매수시가등락율", "등락율변화"]
  체결강도: ["매수체결강도", "체결강도변화", "체결강도변화율"]
  호가: ["매수호가잔량비", "매수스프레드", "매도잔량_매수잔량_비율"]
  수급: ["초당매수수량_매도총잔량_비율", "초당순매수비율"]
  위험신호: ["위험도점수", "거래품질점수", "급락신호"]
```

---

## 9. 변수 명명 규칙

### 9.1 접두사 규칙

| 접두사 | 의미 | 예시 |
|--------|------|------|
| `매수*` | 매수 시점 변수 | 매수등락율, 매수체결강도 |
| `매도*` | 매도 시점 변수 | 매도등락율, 매도체결강도 |
| `초당*` | Tick 모드 전용 | 초당매수수량, 초당거래대금 |
| `분당*` | Min 모드 전용 | 분당매수수량, 분당거래대금 |

### 9.2 접미사 규칙

| 접미사 | 의미 | 예시 |
|--------|------|------|
| `*변화` | 매도-매수 차이 | 등락율변화, 체결강도변화 |
| `*변화율` | 매도/매수 비율 | 거래대금변화율 |
| `*점수` | 0~100 정규화 점수 | 위험도점수, 거래품질점수 |
| `*비율` | 두 값의 비율 | 매도잔량_매수잔량_비율 |
| `*비중` | 전체 대비 비중 | 초당거래대금_당일비중 |
| `*추세` | 방향성 라벨 | 등락추세, 체결강도추세 |
| `*신호` | Boolean 플래그 | 급락신호, 매도세증가 |
| `*_ML` | ML 예측값 | 손실확률_ML, 위험도_ML |

### 9.3 카테고리별 명명

| 카테고리 | 키워드 | 예시 |
|----------|--------|------|
| 가격 | 가, 고가, 저가 | 매수가, 매수고가 |
| 등락율 | 등락 | 매수등락율, 등락율변화 |
| 체결강도 | 체결 | 매수체결강도, 체결강도변화 |
| 거래대금 | 거래대금, 거래량 | 매수당일거래대금 |
| 호가 | 호가, 잔량, 스프레드 | 매수호가잔량비 |
| 수급 | 순매수, 매수_매도 | 초당순매수비율 |
| 시가총액 | 시가총액 | 시가총액 |
| 시간 | 시, 분, 초 | 매수시, 보유시간 |

---

## 10. 코드 리팩토링 제안

### 10.1 단계별 리팩토링 계획

#### Phase 1: 레지스트리 파일 생성 (권장)

1. `backtester/variable_registry.py` 생성
2. 모든 변수 정의를 `VariableDefinition` 데이터클래스로 마이그레이션
3. 기존 `metric_registry.py`의 `BUY_TIME_FILTER_COLUMNS`를 레지스트리에서 동적 생성

#### Phase 2: filters.py 리팩토링

1. `_is_buytime_candidate()` 함수를 레지스트리 기반으로 변경
2. `_categorize()` 함수를 레지스트리의 `category` 필드 활용
3. 하드코딩된 제외 목록 제거

#### Phase 3: metrics_enhanced.py 리팩토링

1. 파생 변수 계산 함수를 레지스트리 기반으로 모듈화
2. 타임프레임 분기를 레지스트리의 `timeframe` 필드로 자동화
3. 새 변수 추가 시 레지스트리만 수정하면 되도록 구조화

#### Phase 4: code_generator.py 리팩토링

1. 런타임 변수 매핑을 레지스트리에서 동적 생성
2. `_get_segment_runtime_blocks()` 함수 단순화

### 10.2 예상 효과

| 항목 | 현재 | 리팩토링 후 |
|------|------|-------------|
| 새 변수 추가 | 3~5개 파일 수정 | 1개 파일 수정 |
| 필터 후보 관리 | 하드코딩 | 설정 기반 |
| 타임프레임 분기 | if-else 분기 | 자동 필터링 |
| 문서화 | 수동 관리 | 레지스트리에서 자동 생성 가능 |
| 일관성 검증 | 어려움 | 레지스트리 기반 검증 가능 |

### 10.3 호환성 유지

리팩토링 시 기존 코드와의 호환성을 유지하기 위해:

1. **기존 상수 유지**: `BUY_TIME_FILTER_COLUMNS`는 레지스트리에서 동적 생성 후 동일 이름으로 export
2. **점진적 마이그레이션**: 한 번에 전체 변경하지 않고 모듈별로 점진적 전환
3. **테스트 커버리지**: 리팩토링 전 기존 동작 검증을 위한 테스트 추가

---

## 부록: 전체 변수 목록

### A. 필터 사용 가능 변수 (룩어헤드 없음)

```
# 원본 변수 (30개)
매수등락율, 매수시가등락율, 매수당일거래대금, 매수체결강도, 매수전일비,
매수회전율, 매수전일동시간비, 매수고가, 매수저가, 매수고저평균대비등락율,
매수매도총잔량, 매수매수총잔량, 매수호가잔량비, 매수매도호가1, 매수매수호가1,
매수스프레드, 매수초당매수수량, 매수초당매도수량, 매수초당거래대금,
매수분당매수수량, 매수분당매도수량, 매수분당거래대금,
시가총액, 매수가, 매수시, 매수분, 매수초

# 파생 변수 - 점수 (3개)
모멘텀점수, 거래품질점수, 위험도점수

# 파생 변수 - 변동폭 (2개)
매수변동폭, 매수변동폭비율

# 파생 변수 - 수급 비율 Tick (10개)
초당매수수량_매도총잔량_비율, 매도잔량_매수잔량_비율, 매수잔량_매도잔량_비율,
초당매도_매수_비율, 초당매수_매도_비율, 현재가_고저범위_위치,
초당거래대금_당일비중, 초당순매수수량, 초당순매수금액, 초당순매수비율

# 파생 변수 - 수급 비율 Min (8개)
분당매수수량_매도총잔량_비율, 분당매도_매수_비율, 분당매수_매도_비율,
현재가_분봉고저범위_위치, 분당거래대금_당일비중,
분당순매수수량, 분당순매수금액, 분당순매수비율

# 파생 변수 - 거래대금 시계열 (2개)
당일거래대금_전틱분봉_비율, 당일거래대금_5틱분봉평균_비율
```

### B. 필터 사용 불가 변수 (룩어헤드 포함)

```
# 매도 시점 원본 변수
매도등락율, 매도체결강도, 매도당일거래대금, 매도전일비, 매도회전율,
매도호가잔량비, 매도고가, 매도저가

# 결과 변수
수익금, 수익률, 보유시간, 매도조건

# 변화량/변화율 변수
등락율변화, 체결강도변화, 전일비변화, 회전율변화, 호가잔량비변화,
거래대금변화율, 체결강도변화율, 당일거래대금_매수매도_비율

# 추세/신호 변수
등락추세, 체결강도추세, 거래량추세, 급락신호, 매도세증가, 거래량급감

# 진단용 점수
매수매도위험도점수, 시간대평균수익률, 타이밍점수, 리스크조정수익률,
연속이익, 연속손실, 이익여부
```

---

## 구현 상태

### 완료된 구현 (2026-01-07)

✅ **변수 레지스트리 (`backtester/variable_registry.py`)** - 약 1,230줄
- `VariableScope` enum: BUY, SELL, COMBINED, ANALYSIS
- `VariableTimeframe` enum: TICK, MIN, ALL
- `VariableDefinition` dataclass: 변수 정의 (name, scope, timeframe, for_filter, lookahead_free, category, formula 등)
- `VARIABLE_REGISTRY` dict: 67개 변수 등록 (원본 30+ 파생 37)
- `VariableRegistry` 클래스: 헬퍼 메서드 (get_filter_candidates, is_lookahead_free, get_by_category 등)
- `get_buy_time_filter_columns()`: metric_registry.py 호환 함수

✅ **기존 코드 연동**
- `filters.py`: `_categorize()`, `_is_buytime_candidate()` 함수가 레지스트리를 우선 참조하도록 수정
- `metric_registry.py`: 레지스트리 참조 안내 주석 추가 (레거시 호환성 유지)

### 사용 방법

```python
from backtester.variable_registry import get_registry, get_buy_time_filter_columns

# 싱글톤 레지스트리 가져오기
registry = get_registry()

# 필터 후보 변수 목록 (Tick)
tick_filter_cols = registry.get_filter_candidates('tick')  # 38개

# 변수 정의 조회
var_def = registry.get('위험도점수')
print(f"Category: {var_def.category}")       # 위험신호
print(f"For filter: {var_def.for_filter}")   # True
print(f"Lookahead free: {var_def.lookahead_free}")  # True

# 카테고리별 변수 조회
price_vars = registry.get_by_category('가격')

# 레거시 호환
from backtester.variable_registry import get_buy_time_filter_columns
columns = get_buy_time_filter_columns('tick')  # metric_registry.py와 동일한 형태
```

### 단일 소스 원칙 (Single Source of Truth)

**변수 관리의 단일 소스**: `backtester/variable_registry.py`

새로운 변수 추가 시:
1. `variable_registry.py`에 `VariableDefinition` 등록 (필수)
2. `metric_registry.py`의 `BUY_TIME_FILTER_COLUMNS` 업데이트 (선택, 레거시 호환)
3. `metrics_enhanced.py`에 계산 로직 추가 (파생 변수인 경우)

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|-----------|
| 1.0.0 | 2026-01-07 | 최초 작성 |
| 1.1.0 | 2026-01-07 | 변수 레지스트리 구현 완료 (`variable_registry.py`), filters.py 연동 |

---

## 관련 문서

- [Back_Testing_Guideline_Tick.md](./Back_Testing_Guideline_Tick.md) - 틱 백테스팅 가이드
- [Back_Testing_Guideline_Min.md](./Back_Testing_Guideline_Min.md) - 분봉 백테스팅 가이드
- [Segmented_Filter_Optimization_Research.md](../Study/ResearchReports/2025-12-20_Segmented_Filter_Optimization_Research.md) - 세그먼트 필터 연구
